/*
 * Copyright 2009 The Native Client Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can
 * be found in the LICENSE file.
 */

/*
 * Defines runtime support for the API to the modeled ARM instructions.
 */

#ifndef NATIVE_CLIENT_PRIVATE_TOOLS_NCV_ARM_ARM_INSTS_RT_H__
#define NATIVE_CLIENT_PRIVATE_TOOLS_NCV_ARM_ARM_INSTS_RT_H__

#include "native_client/src/trusted/validator_arm/arm_insts.h"

EXTERN_C_BEGIN

/*
 * Model an ARM instruction that isn't known.
 */
extern const OpInfo kUndefinedArmOp;

/*
 * Appends text describing the given OpInfo data into the buffer,
 * at the cursor position. When the buffer fills, no additional text
 * is added to the buffer, even though the cursor is incremented
 * accordingly.
 *
 * Note: Buffer overflow occurs iff the cursor is greater than or
 * equal to the buffer size.
 */
void OpInfoAppend(char* buffer,
                  size_t buffer_size,
                  const OpInfo* op,
                  size_t* cursor);

/*
 * Prints text describing the given OpInfo data into the buffer.
 * Returns true if the buffer doesn't overflow.
 */
Bool DescribeOpInfo(char* buffer, size_t buffer_size, const OpInfo* op);

/*
 * Prints the given instruction into the given buffer. Returns true
 * if buffer overflow doesn't occur.
 */
Bool DescribeInst(char* buffer,
                  size_t buffer_size,
                  const NcDecodedInstruction* inst);

/*
 * Given the current value of the program counter, and
 * an immediate displacement (24 bit address) from an instruction, compute the
 * corresponding absolute address
 */
uint32_t RealAddress(uint32_t pc, uint32_t displacement);

/*
 * Rotate the address right by the rotate value.
 */
uint32_t ImmediateRotateRight(uint32_t immediate, int32_t rotate);

/*
 * Given an instruction, and an instruction type, apply the corresponding masks
 * to define the corresponding set of extracted values.
 */
void DecodeValues(uint32_t inst, ArmInstType inst_type,
                  InstValues* values);

/*
 * Returns true if the actual value matches the expected value,
 * or one of the (above) special patterns apply. The mask defines
 * the bits to be checked.
 */
Bool ValuesDefaultMatch(int32_t actual, int32_t expected, uint32_t mask);

/* Defines a function to check that args 1 and 4 of
 * the decoded instruction are not equal.
 */
Bool Args_1_4_NotEqual(NcDecodedInstruction* inst);

/*
 * Define a function to check that the decoded instruction doesn't use
 * register r15 for the (decoded) arg1 value.
 */
Bool Arg1IsntR15(NcDecodedInstruction* inst);

/*
 * Define a function to check that the offset generated by args 3 and 4
 * do not generate the offset zero.
 */
Bool Args_3_4_NotBothZero(NcDecodedInstruction* inst);

/*
 * Check that arg1 isn't in the set of listed
 * load/store multiple registers.
 */
Bool Arg1NotInLoadStoreRegisters(NcDecodedInstruction* inst);

/*
 * Check that r15 isn't in the set of listed
 * load/store multiple registers.
 */
Bool R15NotInLoadStoreRegisters(NcDecodedInstruction* inst);

/*
 * Check that r15 is in the set of listed load/store multiple
 * registers.
 */
Bool R15InLoadStoreRegisters(NcDecodedInstruction* inst);

EXTERN_C_END

#endif  /* NATIVE_CLIENT_PRIVATE_TOOLS_NCV_ARM_ARM_INSTS_RT_H__ */
