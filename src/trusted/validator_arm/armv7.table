# ARMv7 Instruction Encodings
#
# This table is derived from the "ARM Architecture Reference Manual, ARMv7-A
# and ARMv7-R edition" and is used here with the permission of ARM Limited.
# Reproduction for purposes other than the development and distribution of
# Native Client may require the explicit permission of ARM Limited.

# This file defines the Native Client "instruction classes" assigned to every
# possible ARMv7 instruction encoding.  It is organized into a series of tables,
# and directly parallels the ARM Architecture Reference Manual cited above.
#
# Each table consists of
# - A name,
# - A citation in the Architecture Reference Manual,
# - One or more columns defining bitfields to match, and
# - One or more rows describing patterns in those bitfields.
#
# A leading tilde (~) negates a pattern.  A hyphen (-) is short for a string of
# don't-care bits (x).  A double-quote (") indicates that a pattern is the same
# as the row above it.
#
# Each row may specify a terminal instruction class ("=InstClass"), or forward
# the reader to a different table ("->table_name").
#
# If an encoding is not valid in every ARM architecture rev, the instruction
# class may indicate the rev or feature that makes the encoding valid in
# parentheses.
#
# For documentation and testing, an "=InstClass" can be followed by up to 3
# additional identifiers, and has the form:
#     =InstClass Rule Pattern Constraints
# where
#     InstClass - is the class decoder to return when matched.
#     Rule - is the Arm rule that applies to the match (see below).
#     Pattern - is a bitpattern for testing instances of the rule.
#     Constraints - identifies what additional constraints are assumed
#            by the corresponding rule.
#
# The Rules are identified with an identifier of the form:
#     NNN_Rule_SS_AA_Pppp
# where
#    NNN is the nmenonic of the instruction.
#    SS is the section number in A8.6.SS that define the instruction.
#    AA is the instruction form on that page,
#    pp is the page number in A8-pp that the instruction is on.
#
# Patterns are sequences of 32 characters as follows:
#   '1' - Bit must be value 1.
#   '0' - Bit must be value 0.
#   'cccc' - Bits defining condition.
#   'dddd' - Bits defining register Rd.
#   'ii...i' - Bits defining an immediate value.
#   'II...I' - Bits defining an immediate value (test sampling only).
#   'mmmm' - Bits defining register Rm.
#   'nnnn' - Bits defining register Rn.
#   'ssss' - Bits defining register Rs.
#   'tttt' - Bits defining register Rt.
#   'tt'   - Bits defining the shift type (for register operations).
#   'u'    - Bit(20) defining whether register flags is updated.
#   'w'    - Bit(21) defining writes flag.
#   'd'    - Bit(23) Direction (add vs subtract) of offset.
#   'p'    - Bit(24) defining if pre-indexing should be used.
#
# Constraints identifiers used are:
#    Imm5NotZero - The immediate (5-bit) value must not be zero.
#    NotRdIsPcAndS - not (Rd is Pc (R15) and S=1 (updates register bit)).
#    NeitherRdIsPcAndSNorRnIsPcAndNotS - Neither
#        (1) Rd is Pc and S=1; nor
#        (2) Rn is Pc ans S=0;
#    RegsNotPc - All register defined by instruction are not Pc (R15).
#    RdCanBePc - Overrides Nacl Constraint that Rd!=Pc.
#    RdCanBePcAndNotRdIsPcAndS - Overrides Nacl Constraint that Rd!=Pc,
#         and adds constraint Rd not Pc (R15) and S=1 (updates
#         register bit).

##############################################################
# The following defines a class decoder hierarchy used to select the
# appropriate tester. We want to add class hierarchy information for
# classes that want their tester to be defined on a superclass.
# By providing this information, the generator can pick out
# the corresponding baseline class tester to use, and does
# not need to define separate testers for derived classes of
# the baseline class tester.
# #############################################################

class ForbiddenCondNop : UnsafeCondNop
class Load3RegisterDoubleOp : LoadStore3RegisterDoubleOp
class Load3RegisterOp : LoadStore3RegisterOp
class MaskedBinary2RegisterImmediateOp : Binary2RegisterImmediateOp
class MaskedBinaryRegisterImmediateTest : BinaryRegisterImmediateTest
class Store3RegisterDoubleOp : LoadStore3RegisterDoubleOp
class Store3RegisterOp : LoadStore3RegisterOp

##############################################################
# The following define decoder tables.
##############################################################

+-- ARMv7 (See Section A5.1)
| cond(31:28) op1(27:25) op(4)
| ~1111       00x        -     ->dp_misc
| "           010        -     ->load_store_word_byte
| "           011        0     ->load_store_word_byte
| "           "          1     ->media
| "           10x        -     ->branch_block_xfer
| "           11x        -     ->super_cop
| 1111        -          -     ->unconditional
+--

+-- dp_misc (See Section A5.2)
| op(25) op1(24:20) op2(7:4)
| 0      ~10xx0     xxx0     ->dp_reg
| "      "          0xx1     ->dp_reg_shifted
| "      10xx0      0xxx     ->misc
| "      "          1xx0     ->half_mult
| "      0xxxx      1001     ->mult
| "      1xxxx      1001     ->sync
| "      ~0xx1x     1011     ->extra_load_store
| "      "          11x1     "
| "      0xx1x      1011     =Forbidden  # Load/Store Unprivileged, plus undef
| "      "          11x1     "
| 1      ~10xx0     -        ->dp_immed
| "      10000      -        = Unary1RegisterImmediateOp => Defs12To15
                                  Mov_Rule_96_A2_P_194
                                  cccc00110000iiiiddddIIIIIIIIIIII
                                  RegsNotPc
                                  (v6T2)
| "      10100      -        =DataProc(v6T2)  # MOVT A8-200
| "      10x10      -        ->msr_and_hints
+--

+-- dp_reg (See Section A5.2.1)
| op1(24:20) op2(11:7) op3(6:5)
| 0000x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     And_Rule_7_A1_P36
                                     cccc0000000unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0001x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Eor_Rule_45_A1_P96
                                     cccc0000001unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0010x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
# Note: For arm, the case where Rn=SP is NOT a special case (only in thumb2).
# Hence, parse restriction does not apply (See Sub_Rule_216_P428 in manual).
                                     SubRule_213_A1_P422
                                     cccc0000010unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0011x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Rsb_Rule_143_P286
                                     cccc0000011unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0100x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
# Note: For arm, the case where Rn=SP is NOT a special case (only in thumb2).
# Hence, parse restriction does not apply (See Add_Rule_8_A1_P28 in manual).
                                     Add_Rule_6_A1_P24
                                     cccc0000100unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0101x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Adc_Rule_2_A1_P16
                                     cccc0000101unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0110x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Sbc_Rule_152_A1_P304
                                     cccc0000110unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0111x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Rsc_Rule_146_A1_P292
                                     cccc0000111unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 10001      -         -        = Binary2RegisterImmedShiftedTest
                                     => MaybeSetsConds
                                     Tst_Rule_231_A1_P456
                                     cccc00010001nnnn0000iiiiitt0mmmm 
| 10011      -         -        = Binary2RegisterImmedShiftedTest
                                     => MaybeSetsConds
                                     Teq_Rule_228_A1_P450
                                     cccc00010011nnnn0000iiiiitt0mmmm
| 10101      -         -        = Binary2RegisterImmedShiftedTest
                                     => MaybeSetsConds
                                     Cmp_Rule_36_A1_P82
                                     cccc00010101nnnn0000iiiiitt0mmmm
| 10111      -         -        = Binary2RegisterImmedShiftedTest
                                     => MaybeSetsConds
                                     Cmn_Rule_33_A1_P76
                                     cccc00010111nnnn0000iiiiitt0mmmm
| 1100x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Orr_Rule_114_A1_P230
                                     cccc0001100unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 1101x      00000     00       = Unary2RegisterOp
                                     Mov_Rule_97_A1_P196
                                     cccc0001101udddd000000000000mmmm
                                     NotRdIsPcAndS
| "          ~00000    00       = Unary2RegisterImmedShiftedOp
                                    Lsl_Rule_88_A1_P178
                                    cccc0001101u0000ddddiiiii000mmmm
                                    Imm5NotZero
| "          -         01       = Unary2RegisterImmedShiftedOp
                                    Lsr_Rule_90_A1_P182
                                    cccc0001101u0000ddddiiiii010mmmm
| "          -         10       = Unary2RegisterImmedShiftedOp
                                    Asr_Rule_14_A1_P40
                                    cccc0001101u0000ddddiiiii100mmmm
| "          00000     11       = Unary2RegisterOp
                                    Rrx_Rule_141_A1_P282
                                    cccc0001101udddd000000000110mmmm
| "          ~00000    11       = Unary2RegisterImmedShiftedOp
                                     Ror_Rule_139_A1_P278
                                     cccc0001101u0000ddddiiiii110mmmm
                                     Imm5NotZero
| 1110x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Bic_Rule_20_A1_P52
                                     cccc0001110unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 1111x      -         -        = Unary2RegisterImmedShiftedOp
                                     Mvn_Rule_107_A1_P216
                                     cccc0001111u0000ddddiiiiitt0mmmm
                                     NotRdIsPcAndS
+--

+-- dp_reg_shifted (See Section A5.2.2)
| op1(24:20) op2(6:5)
| 0000x      -        = Binary4RegisterShiftedOp And_Rule_13_A1_P38
                           cccc0000000unnnnddddssss0tt1mmmm RegsNotPc
| 0001x      -        = Binary4RegisterShiftedOp Eor_Rule_46_A1_P98
                           cccc0000001unnnnddddssss0tt1mmmm RegsNotPc
| 0010x      -        = Binary4RegisterShiftedOp Sub_Rule_214_A1_P424
                           cccc0000010unnnnddddssss0tt1mmmm RegsNotPc
| 0011x      -        = Binary4RegisterShiftedOp => Defs12To15RdRnRsRmNotPc
                           Rsb_Rule_144_A1_P288
                           cccc0000011snnnnddddssss0tt1mmmm
                           RegsNotPc
| 0100x      -        = Binary4RegisterShiftedOp => Defs12To15RdRnRsRmNotPc
                           Add_Rule_7_A1_P26 
                           cccc0000100snnnnddddssss0tt1mmmm
                           RegsNotPc
| 0101x      -        = Binary4RegisterShiftedOp Adc_Rule_3_A1_P18
                           cccc0000101unnnnddddssss0tt1mmmm RegsNotPc      
| 0110x      -        = Binary4RegisterShiftedOp Sbc_Rule_153_A1_P306
                           cccc0000110unnnnddddssss0tt1mmmm RegsNotPc
| 0111x      -        = Binary4RegisterShiftedOp Rsc_Rule_147_A1_P294
                           cccc0000111unnnnddddssss0tt1mmmm
| 10001      -        = Binary3RegisterShiftedTest Tst_Rule_232_A1_P458
                           cccc00010001nnnn0000ssss0tt1mmmm RegsNotPc
| 10011      -        = Binary3RegisterShiftedTest Teq_Rule_229_A1_P452
                           cccc00010011nnnn0000ssss0tt1mmmm RegsNotPc
| 10101      -        = Binary3RegisterShiftedTest Cmp_Rule_37_A1_P84
                           cccc00010101nnnn0000ssss0tt1mmmm RegsNotPc
| 10111      -        = Binary3RegisterShiftedTest Cmn_Rule_34_A1_P78
                           cccc00010111nnnn0000ssss0tt1mmmm RegsNotPc
| 1100x      -        = Binary4RegisterShiftedOp Orr_Rule_115_A1_P212
                           cccc0001100unnnnddddssss0tt1mmmm RegsNotPc
| 1101x      00       = Binary3RegisterOp Lsl_Rule_89_A1_P180
                           cccc0001101u0000ddddmmmm0001nnnn RegsNotPc
| "          01       = Binary3RegisterOp Lsr_Rule_91_A1_P184
                           cccc0001101u0000ddddmmmm0011nnnn RegsNotPc
| "          10       = Binary3RegisterOp Asr_Rule_15_A1_P42
                           cccc0001101u0000ddddmmmm0101nnnn RegsNotPc
| "          11       = Binary3RegisterOp Ror_Rule_140_A1_P280
                           cccc0001101u0000ddddmmmm0111nnnn RegsNotPc
| 1110x      -        = Binary4RegisterShiftedOp Bic_Rule_21_A1_P54
                           cccc0001110unnnnddddssss0tt1mmmm RegsNotPc
| 1111x      -        = Unary3RegisterShiftedOp Mvn_Rule_108_A1_P218
                           cccc0001111u0000ddddssss0tt1mmmm RegsNotPc
+--

+-- dp_immed (See Section A5.2.3)
# Note: The two interesting instructions in this set are
# TestIfAddressMasked and MaskAddress. These two instructions are the
# ones that we# allow testing/setting of bits to mask data addresses
# appropriately.
| op(24:20) Rn(19:16)
| 0000x      -        = Binary2RegisterImmediateOp And_Rule_11_A1_P34
                           cccc0010000unnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0001x      -        = Binary2RegisterImmediateOp Eor_Rule_44_A1_P94
                           cccc0010001unnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0010x      ~1111    = Binary2RegisterImmediateOp Sub_Rule_212_A1_P420
                           cccc0010010unnnnddddiiiiiiiiiiii
                           NeitherRdIsPcAndSNorRnIsPcAndNotS
                        # Note: Table says that op=0010x for ADR, but
                        # patterns for ADR do not match (page A8-32).
                        # Causes parsing conflicts with SUB (previous
                        # row). Added restriction to ADR that bit 20
                        # (updates flags register) must be 0 (rather than
                        # x), to match what is on A8.6.10 (page A8-32).
                        # Note that this also matches restrictions of
                        # A8.6.212 (page A8-420).
| 00100      1111     = Unary1RegisterImmediateOp Adr_Rule_10_A2_P32
                           cccc001001001111ddddiiiiiiiiiiii
                        # Note: Table says that op=0010x should be ADR,
                        # but patterns for ADR do not match (page A8-32).
                        # Causes conflicts with SUB (two rows up). However,
                        # this case matches the patterns for SUB in A8.6.212
                        # (page A8-420). Assuming SUB should be recognized.
| 00101      1111     = Binary2RegisterImmediateOp Sub_Rule_212_A1_P420
                           cccc001001011111ddddiiiiiiiiiiii
                           NeitherRdIsPcAndSNorRnIsPcAndNotS
| 0011x      -        = Binary2RegisterImmediateOp Rsb_Rule_142_A1_P284
                           cccc0010011unnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0100x      ~1111    = Binary2RegisterImmediateOp Add_Rule_5_A1_P22
                           cccc0010100unnnnddddiiiiiiiiiiii 
                           NeitherRdIsPcAndSNorRnIsPcAndNotS
                        # Note: Table says that op=0100x for ADR, but
                        # patterns for ADR do not match (page A8-32).
                        # Causes parsing conflicts with ADD (previous
                        # row). Added restriction to ADR that bit 20
                        # (updates flags register) must be 0 (rather than
                        # x), to match what is on A8.6.10 (page A8-32).
                        # Note that this also matches restrictions of
                        # A8.6.5 (page A8-22).
| 01000      1111     = Unary1RegisterImmediateOp Adr_Rule_10_A1_P32
                          cccc001010001111ddddiiiiiiiiiiii
                        # Note: Table says that op=0100x should be ADR,
                        # but patterns for ADR do not match (page A8-32).
                        # Causes conflicts with Add (two rows up). However,
                        # this case matches the patterns for ADD in A8.6.5
                        # (page A8-22). Assuming ADD should be recognized.
| 01001      1111     = Binary2RegisterImmediateOp Add_Rule_5_A1_P22
                           cccc001010011111ddddiiiiiiiiiiii 
                           NeitherRdIsPcAndSNorRnIsPcAndNotS
| 0101x      -        = Binary2RegisterImmediateOp Adc_Rule_6_A1_P14
                           cccc0010101unnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0110x      -        = Binary2RegisterImmediateOp Sbc_Rule_151_A1_P302
                           cccc0010110unnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0111x      -        = Binary2RegisterImmediateOp Rsc_Rule_145_A1_P290
                           cccc0010111unnnnddddiiiiiiiiiiii NotRdIsPcAndS
                        # Note: Following instruction is used to test
                        # if the immediate value appropriately (data address)
                        # masks the value in Rn.
| 10001      -        = MaskedBinaryRegisterImmediateTest
                           => TestIfAddressMasked
                           Tst_Rule_230_A1_P454
                           cccc00110001nnnn0000iiiiiiiiiiii
| 10011      -        = BinaryRegisterImmediateTest Teq_Rule_227_A1_P448
                           cccc00110011nnnn0000iiiiiiiiiiii
| 10101      -        = BinaryRegisterImmediateTest Cmp_Rule_35_A1_P80
                           cccc00110101nnnn0000iiiiiiiiiiii
| 10111      -        = BinaryRegisterImmediateTest Cmn_Rule_32_A1_P74
                           cccc00110111nnnn0000iiiiiiiiiiii
| 1100x      -        = Binary2RegisterImmediateOp Orr_Rule_113_A1_P228
                           cccc0011100unnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 1101x      -        = Unary1RegisterImmediateOp Mov_Rule_96_A1_P194
                           cccc0011101u0000ddddiiiiiiiiiiii NotRdIsPcAndS
                        # Note: The following instruction is used to mask
                        # memory addresses.
| 1110x      -        = MaskedBinary2RegisterImmediateOp => MaskAddress
                           Bic_Rule_19_A1_P50
                           cccc0011110unnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 1111x      -        = Unary1RegisterImmediateOp Mvn_Rule_106_A1_P214
                           cccc0011111u0000ddddiiiiiiiiiiii NotRdIsPcAndS
+--

+-- mult (See Section A5.2.5)
| op(23:20)
| 000x      =Multiply          # MUL
| 001x      =Multiply          # MLA
| 0100      =LongMultiply(v6)  # UMAAL
| 0101      =Undefined
| 0110      =Multiply(v6T2)    # MLS
| 0111      =Undefined
| 100x      =LongMultiply  # UMULL
| 101x      =LongMultiply  # UMLAL
| 110x      =LongMultiply  # SMULL
| 111x      =LongMultiply  # SMLAL
+--

+-- sat_add_sub (See Section A5.2.6)
| op(22:21)
| 00        =SatAddSub(v5TE)  # QADD
| 01        =SatAddSub(v5TE)  # QSUB
| 10        =SatAddSub(v5TE)  # QDADD
| 11        =SatAddSub(v5TE)  # QDSUB
+--

+-- half_mult (See Section A5.2.7)
| op1(22:21) op(5)
| 00         -     =Multiply(v5TE)      # SMLABB et al.
| 01         0     =Multiply(v5TE)      # SMLAWB et al.
| 01         1     =Multiply(v5TE)      # SMULWB et al.
| 10         -     =LongMultiply(v5TE)  # SMLALBB
| 11         -     =Multiply(v5TE)      # SMULBB et al.
+--

+-- extra_load_store (See Section A5.2.8)
| op2(6:5) op1(24:20) Rn(19:16)
| 01       xx0x0      -         = Store3RegisterOp => StrRegister
                                  Strh_Rule_208_A1_P412
                                  cccc000pd0w0nnnntttt00001011mmmm
| "        xx0x1      -         = Load3RegisterOp => LdrRegister
                                  Ldrh_Rule_76_A1_P156
                                  cccc000pd0w1nnnntttt00001011mmmm
| "        xx1x0      -         =StoreImmediate     # STRH(immediate) A8-410
| "        xx1x1      ~1111     =LoadImmediate      # LDRH(immediate) A8=152
| "        "          1111      =LoadImmediate      # LDRH(literal)   A8-154
| 10       xx0x0      -         = Load3RegisterDoubleOp => LoadDoubleR
                                  Ldrd_Rule_68_A1_P140
                                  cccc000pd0w0nnnntttt00001101mmmm (v5TE)
| "        xx0x1      -         = Load3RegisterOp => LdrRegister 
                                  Ldrsb_Rule_80_A1_P164
                                  cccc000pd0w1nnnntttt00001101mmmm
| "        xx1x0      ~1111     =LoadDoubleI(v5TE)  # LDRD(immediate) A8-136
| "        "          1111      =LoadDoubleI(v5TE)  # LDRD(literal)   A8-138
| "        xx1x1      ~1111     =LoadImmediate      # LDRSB(immediate)A8-160
| "        "          1111      =LoadImmediate      # LDRSB(literal)  A8-162
| 11       xx0x0      -         = Store3RegisterDoubleOp => StoreDoubleR
                                  Strd_Rule_201_A1_P398
                                  cccc000pd0w0nnnntttt00001111mmmm
| "        xx0x1      -         =LoadRegister       # LDRSH(register) A8-172
| "        xx1x0      -         =StoreImmediate     # STRD(immediate) A8-396
| "        xx1x1      ~1111     =LoadImmediate      # LDRSH(immediate)A8-168
| "        "          1111      =LoadImmediate      # LDRSH(literal)  A8-170
+--

# Unprivileged load-store table omitted: modeled as Forbidden.
# They are not expected in user code.

+-- sync (See Section A5.2.10)
| op(23:20)
| 0x00      =Deprecated      # SWP, SWPB  TODO(cbiffle): model these?
| 1000      =StoreExclusive(v6)        # STREX
| 1001      =LoadExclusive(v6)         # LDREX
| 1010      =StoreExclusive(v6K)       # STREXD
| 1011      =LoadDoubleExclusive(v6K)  # LDREXD
| 1100      =StoreExclusive(v6K)       # STREXB
| 1101      =LoadExclusive(v6K)        # LDREXB
| 1110      =StoreExclusive(v6K)       # STREXH
| 1111      =LoadExclusive(v6K)        # LDREXH
| else:     =Undefined(v6K)            # Note on page A5-16
+--

+-- msr_and_hints (See Section A5.2.11)
| op(22) op1(19:16) op2(7:0)
| 0      0000       0000_0000  = CondNop => EffectiveNoOp
                                 # TODO(karl) fix actual class decoder
                                 Nop_Rule_110_A1_P222
                                 cccc0011001000001111000000000000 (v6K,v6T2)
| "      "          0000_0001  = CondNop => EffectiveNoOp 
                                 # TODO(karl) fix actual class decoder
                                 Yield_Rule_413_A1_P812
                                 cccc0011001000001111000000000001 (v6K)
| "      "          0000_0010  = ForbiddenCondNop => Forbidden
                                 # Don't allow, may put hardware to sleep
                                 # until a send event occurs.
                                 Wfe_Rule_411_A1_P808
                                 cccc0011001000001111000000000010 (v6K)
| "      "          0000_0011  = ForbiddenCondNop => Forbidden
                                 # Don't allow, may put hardware to sleep
                                 # until a send event occurs.
                                 Wfi_Rule_412_A1_P810
                                 cccc0011001000001111000000000011 (v6K)
| "      "          0000_0100  = ForbiddenCondNop => Forbidden
                                 # Don't allow, causes an event to be
                                 # signalled to all processors in the
                                 # multiprocessor system.
                                 Sev_Rule_158_A1_P316
                                 cccc0011001000001111000000000100 (v6K)
| "      "          1111_xxxx  = CondNop => EffectiveNoOp
                                 # TODO(karl) fix actual
                                 Dbg_Rule_40_A1_P88
                                 cccc001100100000111100001111iiii (v7)
# TODO(karl): Define a baseline class decoder for the following two rows.
| "      0100       -          =MoveToStatusRegister  # MSR(immediate) A8-208
| "      1x00       -          =MoveToStatusRegister  # MSR(immediate) A8-208
| "      xx01       -          = ForbiddenCondNop => Forbidden
                                 Msr_Rule_B6_1_6_A1_PB6_12
                                 cccc00110010ii011111iiiiiiiiiiii
                                 # MSR(immediate), ring0 version
| "      xx1x       -          = ForbiddenCondNop => Forbidden
                                 Msr_Rule_B6_1_6_A1_PB6_12
                                 cccc00110010ii1i1111iiiiiiiiiiii
                                 # MSR(immediate), ring0 version
| 1      -          -          = ForbiddenCondNop => Forbidden
                                 Msr_Rule_B6_1_6_A1_PB6_12
                                 cccc00110110iiii1111iiiiiiiiiiii
                                 # MSR(immediate), ring0 version
| else:                        = Forbidden  # Unallocated hints, page A5-17
+--

+-- misc (See Section A5.2.12)
| op2(6:4) op(22:21) op1(19:16)
| 000      x0        xxxx       =DataProc      # MRS
| "        01        xx00       =MoveToStatusRegister  # MSR(register)
| "        01        xx01       =Forbidden     # MSR(register), ring0 version
| "        "         xx1x       =Forbidden     # MSR(register), ring0 version
| "        11        -          =Forbidden     # MSR(register), ring0 version
| 001      01        -          =BxBlx(v4T)    # BX
| "        11        -          =DataProc(v6)  # CLZ
| 010      01        -          =Forbidden     # BXJ
| 011      01        -          =BxBlx(v5T)    # BLX(register)
| 101      -         -          ->sat_add_sub
| 111      01        -          =Breakpoint(v5T)  # BKPT
| 111      11        -          =Forbidden     # SMC
| else:                         =Undefined     # Note on page A5-18
+--

+-- load_store_word_byte (See Section A5.3)
| A(25) op1(24:20) B(4) Rn(19:16)
# Following 2 rows implement op1 = xx0x0 & ~0x010
| 0     1x0x0      -    -        =StoreImmediate  # STR(immediate) A8-384
| "     0x000      "    "        "
# Following 2 rows implement op1 = xx0x0 & ~0x010
| 1     1x0x0      0    -        =StoreRegister   # STR(register) A8-386
| "     0x000      "    "        "
| 0     0x010      -    -        =Forbidden       # STRT A8-416
| 1     0x010      0    -        "
# Following 2 rows implement op1 = xx0x1 & ~0x011
| 0     1x0x1      -    ~1111    =LoadImmediate   # LDR(immediate) A8-120
| "     0x001      "    "        "
# Following 2 rows implement op1 = xx0x1 & ~0x011
| "     1x0x1      "    1111     =LoadImmediate   # LDR(literal) A8-122
| "     0x001      "    "        "
# Following 2 rows implement op1 = xx0x1 & ~0x011
| 1     1x0x1      0    -        =LoadRegister    # LDR(register) A8-124
| "     xx001      "    "        "
| 0     0x011      -    -        =Forbidden       # LDRT A8-176
| 1     0x011      0    -        "
# Following 2 rows implement op1 = xx1x0 & ~0x110
| 0     1x1x0      -    -        =StoreImmediate  # STRB(immediate) A8-390
| "     0x100      "    "        "
# Following 2 rows implement op1 = xx1x0 & ~0x110
| 1     1x1x0      0    -        =StoreRegister   # STRB(register) A8-392
| "     0x100      "    "        "
| 0     0x110      -    -        =Forbidden       # STRBT A8-394
| 1     0x110      0    -        "
# Following 2 rows implement op1 = xx1x1 & ~0x111
| 0     1x1x1      -    ~1111    =LoadImmediate   # LDRB(immediate) A8-128
| "     0x101      "    "        "
# Following 2 rows implement op1 = xx1x1 & ~0x111
| "     1x1x1      "    1111     =LoadImmediate   # LDRB(literal) A8-130
| "     0x101      "    "        "
# Following 2 rows implement op1 = xx1x1 & ~0x111
| 1     1x1x1      0    -        =LoadRegister    # LDRB(register) A8-132
| "     0x101      "    "        "
| 0     0x111      -    -        =Forbidden       # LDRBT          A8-132
| 1     0x111      0    -        "
+--

+-- media (See Section A5.4)
| op1(24:20) op2(7:5) Rd(15:12) Rn(3:0)
| 000xx      -        -         -       ->parallel_add_sub  # signed
| 001xx      -        -         -       ->parallel_add_sub  # unsigned
| 01xxx      -        -         -       ->pack_sat_rev
| 10xxx      -        -         -       ->signed_mult
| 11000      000      1111      -       =Multiply(v6)    # USAD8
| "          000      ~1111     -       =Multiply(v6)    # USADA8
| 1101x      x10      -         -       =DataProc(v6T2)  # SBFX
| 1110x      x00      -         1111    = Unary1RegisterBitRange
                                          Bfc_17_A1_P46 (v6T2)
| "          x00      -         ~1111   =DataProc(v6T2)  # BFI
| 1111x      x10      -         -       =DataProc(v6T2)  # UBFX
| 11111      111      -         -       =Roadblock  # Permanently Undefined
| else:                                 =Undefined  # Note on page A5-21
+--

+-- parallel_add_sub (See Sections A5.4.1, A5.4.2)
# N.B. These instructions are defined as UNPREDICTABLE when using r15 as any
# operand.  This "UNPREDICTABLE" means the result is not defined, and is very
# different than UNDEFINED.  Since we don't allow these ops to write r15, and
# don't consider them suitable for producing a sandboxed address, we don't need
# the result to be defined, and we don't model this here.
| op1(21:20) op2(7:5)
| 01         000      =DataProc(v6)  # UADD16
| 01         001      =DataProc(v6)  # UASX
| 01         010      =DataProc(v6)  # USAX
| 01         011      =DataProc(v6)  # USUB16
| 01         100      =DataProc(v6)  # UADD8
| 01         111      =DataProc(v6)  # USUB8
| 10         000      =DataProc(v6)  # UQADD16
| 10         001      =DataProc(v6)  # UQASX
| 10         010      =DataProc(v6)  # UQSAX
| 10         011      =DataProc(v6)  # UQSUB16
| 10         100      =DataProc(v6)  # UQADD8
| 10         111      =DataProc(v6)  # UQSUB8
| 11         000      =DataProc(v6)  # UHADD16
| 11         001      =DataProc(v6)  # UHASX
| 11         010      =DataProc(v6)  # UHSAX
| 11         011      =DataProc(v6)  # UHSUB16
| 11         100      =DataProc(v6)  # UHADD8
| 11         111      =DataProc(v6)  # UHSUB8
| else:               =Undefined  # Note on page A5-23
+--

+-- pack_sat_rev (See Section A5.4.3)
| op1(22:20) op2(7:5) A(19:16)
| 000        xx0      -        =PackSatRev(v6)    # PKH
| 01x        xx0      -        =PackSatRev(v6)    # SSAT
| 11x        xx0      -        =PackSatRev(v6)    # USAT
| 000        011      ~1111    =PackSatRev(v6)    # SXTAB16
| "          "        1111     =PackSatRev(v6)    # SXTB16
| "          101      -        =PackSatRev(v6)    # SEL
| 010        001      -        =PackSatRev(v6)    # SSAT16
| "          011      ~1111    =PackSatRev(v6)    # SXTAB
| "          "        1111     =PackSatRev(v6)    # SXTB
| 011        001      -        =PackSatRev(v6)    # REV
| "          011      ~1111    =PackSatRev(v6)    # SXTAH
| "          "        1111     =PackSatRev(v6)    # SXTH
| 011        101      -        =PackSatRev(v6)    # REV16
| 100        011      ~1111    =PackSatRev(v6)    # UXTAB16
| "          "        1111     =PackSatRev(v6)    # UXTB16
| 110        001      -        =PackSatRev(v6)    # USAT16
| "          011      ~1111    =PackSatRev(v6)    # UXTAB
| "          "        1111     =PackSatRev(v6)    # UXTB
| 111        001      -        =PackSatRev(v6T2)  # RBIT
| "          011      ~1111    =PackSatRev(v6)    # UXTAH
| "          "        1111     =PackSatRev(v6)    # UXTH
| "          101      -        =PackSatRev(v6)    # REVSH
| else:                        =Undefined  # Note on page A5-24
+--

+-- signed_mult (See Section A5.4.4)
| op1(22:20) op2(7:5) A(15:12)
| 000        00x      ~1111    =Multiply(v6T2)          # SMLAD
| "          "        1111     =Multiply(v6T2)          # SMUAD
| "          01x      ~1111    =Multiply(v6T2)          # SMLSD
| "          "        -        =Multiply(v6T2)          # SMUSD
| 100        00x      -        =LongMultiply(v6T2)      # SMLALD
| "          01x      -        =LongMultiply(v6T2)      # SMLSLD
| 101        00x      ~1111    =Multiply(v6T2)          # SMMLA
| "          "        1111     =Multiply(v6T2)          # SMMUL
| "          11x      -        =Multiply(v6T2)          # SMMLS
| else:                        =Undefined  # Note on page A5-26
+--

+-- branch_block_xfer (See Section A5.5)
| op(25:20) R(15)
| 0000x0    -     =StoreImmediate  # STMDA / STMED
| 0000x1    -     =LoadMultiple    # LDMDA / LDMFA
| 0010x0    -     =StoreImmediate  # STM / STMIA / STMEA
| 0010x1    -     =LoadMultiple    # LDM / LDMIA / LDMFD
| 0100x0    -     =StoreImmediate  # STMDB / STMFD
| 0100x1    -     =LoadMultiple    # LDMDB / LDMEA
| 0110x0    -     =StoreImmediate  # STMIB / STMFA
| 0110x1    -     =LoadMultiple    # LDMIB / LDMED
| 0xx1x0    -     =Forbidden       # STM, ring0 version
| 0xx1x1    0     =Forbidden       # LDM, ring0 version
| "         1     =Forbidden       # LDM, exception return
| 10xxxx    -     =Branch          # B
| 11xxxx    -     =Branch          # BL
+--

+-- super_cop (See Section A5.6)
# N.B. The ISA spec models the "Advanced SIMD" operations separately from other
# coprocessor operations.  We don't, so the coproc column is omitted.
| op1(25:20) op(4) Rn(19:16)
| 0xxxx0     -     -         =StoreCoprocessor  # STC
| 0xxxx1     -     ~1111     =LoadCoprocessor   # LDC(immediate), LDC2(immediate)
| "          "     1111      =LoadCoprocessor   # LDC(literal), LDC2(literal)
| 00000x     -     -         =Undefined
| 000100     -     -         =CoprocessorOp(v5TE)  # MCRR, MCRR2
| 000101     -     -         =MoveDoubleFromCoprocessor(v5TE)  # MRRC, MRRC2
| 10xxxx     0     -         =CoprocessorOp     # CDP, CDP2
| 10xxx0     1     -         =CoprocessorOp     # MCR, MCR2
| 10xxx1     1     -         =MoveFromCoprocessor  # MRC, MRC2
| 11xxxx     -     -         =Forbidden         # SVC (nee SWI)
+--

+-- unconditional (See Section A5.7)
| op1(27:20) op(4) Rn(19:16)
| 0xxx_xxxx  -     -         ->misc_hints_simd
| 100x_x1x0  -     -         =Forbidden         # SRS
| 100x_x0x1  -     -         =Forbidden         # RFE
| 101x_xxxx  -     -         =Forbidden         # BLX(immediate)
| 1100_0x11  -     ~1111     =LoadCoprocessor(v5)   # LDC(immed), LDC2(immed)
| 1100_1xx1  -     1111      =LoadCoprocessor(v5)   # LDC(literal), LDC2(literal)
| 1101_xxx1  -     1111      =LoadCoprocessor(v5)   # LDC(literal), LDC2(literal)
| 1100_0x10  -     -         =StoreCoprocessor(v5)  # STC, STC2
| 1100_1xx0  -     -         "
| 1101_xxx0  -     -         "
| 1100_0100  -     -         =CoprocessorOp(v6)  # MCRR, MCRR2
| 1100_0101  -     -         =MoveDoubleFromCoprocessor(v6)  # MRRC, MRRC2
| 1110_xxxx  0     -         =CoprocessorOp(v5)  # CDP, CDP2
| 1110_xxx0  1     -         =CoprocessorOp(v5)  # MCR, MCR2
| 1110_xxx1  1     -         =MoveFromCoprocessor(v5)  # MRC, MRC2
| else:                      =Undefined         # Note on page A5-30
+--

+-- misc_hints_simd (See Section A5.7.1)
| op1(26:20) op2(7:4) Rn(19:16)
| 001_0000   xx0x     xxx0      =Forbidden  # CPS
| 001_0000   0000     xxx1      =Forbidden  # SETEND
| 01x_xxxx   -        -         ->simd_dp
| 100_xxx0   -        -         ->simd_load_store
| 100_x001   -        -         =EffectiveNoOp(MP)    # Unallocated memory hint
| 100_x101   -        -         =EffectiveNoOp(v7)    # PLI(immediate, literal)
| 101_x001   -        ~1111     =EffectiveNoOp(MP)    # PLDW(immediate)
| "          -        1111      =Unpredictable
| 101_x101   -        ~1111     =EffectiveNoOp(v5TE)  # PLD(immediate)
| 101_x101   -        1111      =EffectiveNoOp(v5TE)  # PLD(literal)
| 101_0111   0001     -         =EffectiveNoOp(v6K)   # CLREX
| "          0100     -         =EffectiveNoOp(v6T2)  # DSB
| "          0101     -         =EffectiveNoOp(v7)    # DMB
| "          0110     -         =EffectiveNoOp(v6T2)  # ISB
| 10x_xx11   -        -         =Unpredictable
| 110_x001   xxx0     -         =EffectiveNoOp(MP)    # Unallocated memory hint
| 110_x101   xxx0     -         =EffectiveNoOp(v7)    # PLI(register)
| 111_x001   xxx0     -         =EffectiveNoOp(MP)    # PLDW(register)
| 111_x101   xxx0     -         =EffectiveNoOp(v5TE)  # PLD(register)
| 11x_xx11   xxx0     -         =Unpredictable
| else:                         =Undefined   # Note on page A5-31
+--

+-- simd_dp (See Section A7.4)
| U(24) A(23:19) B(11:8) C(7:4)
| -     0xxxx    -       -      ->simd_dp_3same
| "     1x000    -       0xx1   ->simd_dp_1imm
| "     1x001    -       0xx1   ->simd_dp_2shift
| "     1x01x    -       0xx1   "
| "     1x1xx    -       0xx1   "
| "     1xxxx    -       1xx1   "
| "     1x0xx    -       x0x0   ->simd_dp_3diff
| "     1x10x    -       x0x0   "
| "     1x0xx    -       x1x0   ->simd_dp_2scalar
| "     1x10x    -       x1x0   "
| 0     1x11x    -       xxx0   =EffectiveNoOp  # VEXT
| 1     1x11x    0xxx    xxx0   ->simd_dp_2misc
| "     "        10xx    xxx0   =EffectiveNoOp  # VTBL, VTBX
| "     "        1100    0xx0   =EffectiveNoOp  # VDUP(scalar)
| else:                         =Undefined  # Note on page A7-10
+--

+-- simd_dp_3same (See Section A7.4.1)
# This table is much larger than it needs to be, since we don't model these
# ops (they work entirely in a separate register set, and cannot access memory).
# Unfortunately there are some UNDEFINED holes here, so we have to be precise.
| A(11:8) B(4) U(24) C(21:20)
| 0000    0    -     -        =EffectiveNoOp  # VHADD
| "       1    -     -        =EffectiveNoOp  # VQADD
| 0001    0    -     -        =EffectiveNoOp  # VRHADD
| "       1    0     00       =EffectiveNoOp  # VAND(register)
| "       "    "     01       =EffectiveNoOp  # VBIC(register)
| "       "    "     10       =EffectiveNoOp  # VORR(register)
| "       "    "     11       =EffectiveNoOp  # VORN(register)
| "       1    1     00       =EffectiveNoOp  # VEOR(register)
| "       "    "     01       =EffectiveNoOp  # VBSL
| "       "    "     10       =EffectiveNoOp  # VBIT
| "       "    "     11       =EffectiveNoOp  # VBIF
| 0010    0    -     -        =EffectiveNoOp  # VHSUB
| "       1    -     -        =EffectiveNoOp  # VQSUB
| 0011    0    -     -        =EffectiveNoOp  # VCGT(register)
| "       1    -     -        =EffectiveNoOp  # VCGE(register)
| 0100    0    -     -        =EffectiveNoOp  # VSHL(register)
| "       1    -     -        =EffectiveNoOp  # VQSHL(register)
| 0101    0    -     -        =EffectiveNoOp  # VRSHL(register)
| "       1    -     -        =EffectiveNoOp  # VQRSHL(register)
| 0110    -    -     -        =EffectiveNoOp  # VMAX, VMIN (integer)
| 0111    0    -     -        =EffectiveNoOp  # VABD, VABDL (integer)
| "       1    -     -        =EffectiveNoOp  # VABA, VABAL
| 1000    0    0     -        =EffectiveNoOp  # VADD(integer)
| "       "    1     -        =EffectiveNoOp  # VSUB(integer)
| "       1    0     -        =EffectiveNoOp  # VTST(integer)
| "       "    1     -        =EffectiveNoOp  # VCEQ(integer)
| 1001    0    -     -        =EffectiveNoOp  # VMLA, VMLAL, VMLS, VMLSL (integer)
| "       1    -     -        =EffectiveNoOp  # VMUL, VMULL(integer/poly)
| 1010    -    -     -        =EffectiveNoOp  # VPMAX, VPMIN(integer)
| 1011    0    0     -        =EffectiveNoOp  # VQDMULH
| "       "    1     -        =EffectiveNoOp  # VQRDMULH
| "       1    0     -        =EffectiveNoOp  # VPADD(integer)
| 1101    0    0     0x       =EffectiveNoOp  # VADD(float)
| "       "    "     1x       =EffectiveNoOp  # VSUB(float)
| "       "    1     0x       =EffectiveNoOp  # VPADD(float)
| "       "    "     1x       =EffectiveNoOp  # VABD(float)
| "       1    0     -        =EffectiveNoOp  # VMLA, VMLS(float)
| "       "    1     0x       =EffectiveNoOp  # VMUL(float)
| 1110    0    0     0x       =EffectiveNoOp  # VCEQ(register)
| "       "    1     0x       =EffectiveNoOp  # VCGE(register)
| "       "    "     1x       =EffectiveNoOp  # VCGT(register)
| "       1    1     -        =EffectiveNoOp  # VACGE, VACGT, VACLE, VACLT
| 1111    0    0     -        =EffectiveNoOp  # VMAX, VMIN(float)
| "       "    1     -        =EffectiveNoOp  # VPMAX, VPMIN(float)
| "       1    0     0x       =EffectiveNoOp  # VRECPS
| "       "    0     1x       =EffectiveNoOp  # VRSQRTS
| else:                       =Undefined  # Note on page A7-12
+--

+-- simd_dp_3diff (See Section A7.4.2)
| A(11:8) U(24)
| 000x    -     =EffectiveNoOp  # VADDL
| 001x    -     =EffectiveNoOp  # VSUBL
| 0100    0     =EffectiveNoOp  # VADDHN
| "       1     =EffectiveNoOp  # VRADDHN
| 0101    -     =EffectiveNoOp  # VABA, VABAL
| 0110    0     =EffectiveNoOp  # VSUBHN
| "       1     =EffectiveNoOp  # VRSUBHN
| 0111    -     =EffectiveNoOp  # VABD, VABDL(integer)
| 10x0    -     =EffectiveNoOp  # VMLA, VMLAL, VMLS, VMLSL (integer)
| 10x1    0     =EffectiveNoOp  # VQDMLAL, VQDMLSL
| 1100    -     =EffectiveNoOp  # VMUL, VMULL (integer)
| 1101    0     =EffectiveNoOp  # VQDMULL
| 1110    -     =EffectiveNoOp  # VMUL, VMULL (polynomial)
| else:         =Undefined  # Note on page A7-15
+--

+-- simd_dp_2scalar (See Section A7.4.3)
| A(11:8) U(24)
| 0x0x    -     =EffectiveNoOp  # VMLA, VMLS (scalar)
| 0x10    -     =EffectiveNoOp  # VMLAL, VMLSL (scalar)
| 0x11    0     =EffectiveNoOp  # VQDMLAL, VMQDLSL
| 100x    -     =EffectiveNoOp  # VMUL(scalar)
| 1010    -     =EffectiveNoOp  # VMULL(scalar)
| 1011    0     =EffectiveNoOp  # VQDMULL
| 1100    -     =EffectiveNoOp  # VQDMULH
| 1101    -     =EffectiveNoOp  # VQRDMULH
| else:         =Undefined  # Note on page A7-16
+--

+-- simd_dp_2shift (See Section A7.4.4)
| A(11:8) U(24) B(6) L(7)
| 0000    -     -    -    =EffectiveNoOp  # VSHR
| 0001    -     -    -    =EffectiveNoOp  # VSRA
| 0010    -     -    -    =EffectiveNoOp  # VRSHR
| 0011    -     -    -    =EffectiveNoOp  # VRSRA
| 0100    1     -    -    =EffectiveNoOp  # VSRI
| 0101    0     -    -    =EffectiveNoOp  # VSHL(immediate)
| 0101    1     -    -    =EffectiveNoOp  # VSLI
| 011x    -     -    -    =EffectiveNoOp  # VQSHL, VQSHLU(immediate)
| 1000    0     0    0    =EffectiveNoOp  # VSHRN
| "       "     1    -    =EffectiveNoOp  # VRSHRN
| "       1     0    -    =EffectiveNoOp  # VQSHRUN
| "       "     1    -    =EffectiveNoOp  # VQRSHRUN
| 1001    -     0    -    =EffectiveNoOp  # VQSHRN
| "       -     1    -    =EffectiveNoOp  # VQRSHRN
| 1010    -     0    -    =EffectiveNoOp  # VSHLL, VMOVL
| 111x    -     -    -    =EffectiveNoOp  # VCVT (floating- and fixed-point)
| else:                   =Undefined  # Note on page A7-17
+--

+-- simd_dp_2misc (See Section A7.4.5)
| A(17:16) B(10:6)
| 00       0000x   =EffectiveNoOp  # VREV64
| "        0001x   =EffectiveNoOp  # VREV32
| "        0010x   =EffectiveNoOp  # VREV16
| "        010xx   =EffectiveNoOp  # VPADDL
| "        1000x   =EffectiveNoOp  # VCLS
| "        1001x   =EffectiveNoOp  # VCLZ
| "        1010x   =EffectiveNoOp  # VCNT
| "        1011x   =EffectiveNoOp  # VMVN(register)
| "        110xx   =EffectiveNoOp  # VPADAL
| "        1110x   =EffectiveNoOp  # VQABS
| "        1111x   =EffectiveNoOp  # VQNEG
| 01       x000x   =EffectiveNoOp  # VCGT (immediate #0)
| "        x001x   =EffectiveNoOp  # VCGE (immediate #0)
| "        x010x   =EffectiveNoOp  # VCEQ (immediate #0)
| "        x011x   =EffectiveNoOp  # VCLE (immediate #0)
| "        x100x   =EffectiveNoOp  # VCLT (immediate #0)
| "        x110x   =EffectiveNoOp  # VABS
| "        x111x   =EffectiveNoOp  # VNEG
| 10       0000x   =EffectiveNoOp  # VSWP
| "        0001x   =EffectiveNoOp  # VTRN
| "        0010x   =EffectiveNoOp  # VUZP
| "        0011x   =EffectiveNoOp  # VZIP
| "        01000   =EffectiveNoOp  # VMOVN
| "        01001   =EffectiveNoOp  # VQMOVUN
| "        0101x   =EffectiveNoOp  # VQMOVN
| "        01100   =EffectiveNoOp  # VSHLL
| "        11x00   =EffectiveNoOp  # VCVT (half- and single-precision)
| 11       10x0x   =EffectiveNoOp  # VRECPE
| "        10x1x   =EffectiveNoOp  # VRSQRTE
| "        11xxx   =EffectiveNoOp  # VCVT (float and integer)
| else:            =Undefined  # Note on page A7-19
+--

+-- simd_dp_1imm (See Section A7.4.6)
| op(5) cmode(11:8)
| 0     0xx0        =EffectiveNoOp  # VMOV(immediate)
| "     0xx1        =EffectiveNoOp  # VORR(immediate)
| "     10x0        =EffectiveNoOp  # VMOV(immediate)
| "     10x1        =EffectiveNoOp  # VORR(immediate)
| "     11xx        =EffectiveNoOp  # VMOV(immediate)
| 1     0xx0        =EffectiveNoOp  # VMVN(immediate)
| "     0xx1        =EffectiveNoOp  # VBIC(immediate)
| "     10x0        =EffectiveNoOp  # VMVN(immediate)
| "     10x1        =EffectiveNoOp  # VBIC(immediate)
| "     110x        =EffectiveNoOp  # VMVN(immediate)
| "     1110        =EffectiveNoOp  # VMOV(immediate)
| "     1111        =Undefined
+--

+-- simd_load_store (See Section A7.7)
# This "table" is the first paragraph in A7.7.
| L(21)
| 0    ->simd_load_store_l0
| 1    ->simd_load_store_l1
+--

+-- simd_load_store_l0 (See Section A7.7, Table A7-20)
| A(23) B(11:8)
| 0     0010    =VectorStore  # VST1(multiple)
| "     011x    "
| "     1010    "
| "     0011    =VectorStore  # VST2(multiple)
| "     100x    "
| "     010x    =VectorStore  # VST3(multiple)
| "     000x    =VectorStore  # VST4(multiple)
| 1     0x00    =VectorStore  # VST1(single)
| "     1000    "
| "     0x01    =VectorStore  # VST2(single)
| "     1001    "
| "     0x10    =VectorStore  # VST3(single)
| "     1010    "
| "     0x11    =VectorStore  # VST4(single)
| "     1011    "
| else:         =Undefined    # Note on page A7-27
+--

+-- simd_load_store_l1 (See Section A7.7, Table A7-21)
| A(23) B(11:8)
| 0     0010    =VectorLoad  # VLD1(multiple)
| "     011x    "
| "     1010    "
| "     0011    =VectorLoad  # VLD2(multiple)
| "     100x    "
| "     010x    =VectorLoad  # VLD3(multiple)
| "     000x    =VectorLoad  # VLD4(multiple)
| 1     0x00    =VectorLoad  # VLD1(single)
| "     1000    "
| "     1100    =VectorLoad  # VLD1(single, all lanes)
| "     0x01    =VectorLoad  # VLD2(single)
| "     1001    "
| "     1101    =VectorLoad  # VLD2(single, all lanes)
| "     0x10    =VectorLoad  # VLD3(single)
| "     1010    "
| "     1110    =VectorLoad  # VLD3(single, all lanes)
| "     0x11    =VectorLoad  # VLD4(single)
| "     1011    "
| "     1111    =VectorLoad  # VLD4(single, all lanes)
| else:         =Undefined   # Note on page A7-27
+--
