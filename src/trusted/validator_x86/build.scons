# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


import os
import sys
Import('env')

#
# DO NOT MOVE
#
# A small piece of the code is shared, so we build that first
#
# TODO(robertm): consider adding this to the top level scons files
env.Append(CPPPATH=['${TARGET_ROOT}'])
env.ComponentLibrary('nchelper', ['ncfileutil.c'])


#
#
# Now build x86 only pieces
#
#
if not env.Bit('target_x86'): Return()


# Make a copy of debug CRT for now.
# TODO(bradnelson): there should be a better way to generalize this requirement.
# NOTE: debug builds on windows break without this
crt = []
if env.AllBits('windows', 'debug'):
  for i in ['.', '$STAGING_DIR']:
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/Debug_NonRedist/'
                         'x86/Microsoft.VC80.DebugCRT')
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/x86/Microsoft.VC80.CRT')

# TODO(bradchen): eliminate need for the following line
env.FilterOut(CCFLAGS=['-Wextra', '-Wswitch-enum', '-Wsign-compare'])



#
#
# ncopcode_desc_0
#
# This one source file is shared in two projects so we generate it first
# to prevent conflics in compile options.
#
ncopcode_desc_o = env.ComponentObject('ncopcode_desc.c')
force_cpp_o = env.ComponentObject('force_cpp.cc')

generate = False
if 'valgen' in COMMAND_LINE_TARGETS: generate = True
if 'valclean' in COMMAND_LINE_TARGETS: generate = True

#
# Only generate/clean these files if the alias is specified on the
# command line.  We conditionally add these pieces to scons to prevent
# a normal invocation from accidentally regenerating the files.
#
if generate:
  #
  # valgen - Table Generator
  #
  # We create an alias 'valgen' which we use to generate the various
  # headers used by the x86 validator.  This target will generate
  # *.h, *_impl.h from the *.enum files, as well as the executables
  # ncdecode_table and ncdecode_tablegen which are used to generate
  # the large opcode tables.
  #

  # Get the directory in which we will generate checking in files.
  val_src_dir = '$MAIN_DIR/src/trusted/validator_x86'

  #------------------------------------------------------
  # Generate the needed header files for enumerated types.
  # Note that we use the same directory for all platforms.

  # Define enumerate type files, and the options to process.
  enum_headers = []
  ncv_enum_pairs = {
      'nacl_disallows': '--name=NaClDisallowsFlag --add_size=1',
      'ncopcode_prefix': '--name=NaClInstPrefix --add_size=1',
      'ncopcode_insts':
        '--name=NaClMnemonic --add_size=1 --sort=1 --name_prefix=Inst',
      'ncopcode_opcode_flags': '--name=NaClIFlag --add_size=1',
      'ncopcode_operand_kind': '--name=NaClOpKind --add_size=1',
      'ncopcode_operand_flag': '--name=NaClOpFlag --add_size=1',
      'ncop_expr_node_flag': '--name=NaClExpFlag --add_size=1',
      'ncop_expr_node_kind': '--name=NaClExpKind --add_size=1',
  }

  # Now code generate the enumerated types.
  for ncv_enum in ncv_enum_pairs:
    ncv_options = ncv_enum_pairs[ncv_enum]
    ncv_enum_file = env.File(ncv_enum + '.enum')
    ncv_header_1 = env.File('%s/gen/%s.h' % (val_src_dir, ncv_enum))
    ncv_header_2 = env.File('%s/gen/%s_impl.h' % (val_src_dir, ncv_enum))

    cmd_line = (
        '${PYTHON} %s --header="%s" --source="%s" --path_prefix="%s" %s %s' %
        (env.File('enum_gen.py'), ncv_header_1, ncv_header_2, val_src_dir,
         ncv_options, ncv_enum_file))

    env.Command([ncv_header_1, ncv_header_2], ncv_enum_file, cmd_line)
    enum_headers.append(ncv_header_1)
    enum_headers.append(ncv_header_2)

  #
  # Switch to generator environment to turn on macro:
  #   NACL_TRUSTED_BUT_NOT_TCB
  #

  tables = []
  for bits in ['32', '64']:
    ncv_decodetab_h = '%s/gen/%s_%s.h' % (val_src_dir, 'ncdecodetab', bits)
    ncv_disasmtab_h = '%s/gen/%s_%s.h' % (val_src_dir, 'ncdisasmtab', bits)
    ncv_badprefixmask_h= '%s/gen/%s_%s.h' % (val_src_dir, 'ncbadprefixmask', bits)
    exe_path = '${STAGING_DIR}/${PROGPREFIX}ncdecode_table${PROGSUFFIX}'
    env.Command(
        [ncv_decodetab_h, ncv_disasmtab_h, ncv_badprefixmask_h],
        exe_path,
        ['%s -m%s %s %s %s' % (exe_path, bits, ncv_decodetab_h,
                               ncv_disasmtab_h, ncv_badprefixmask_h )]
    )
    tables.append(ncv_decodetab_h)
    tables.append(ncv_disasmtab_h)
    tables.append(ncv_badprefixmask_h)

#
# In the middle of generating, we unconditionally add ncdecode_tablegen
# so that the tests which depend on it, can run correctly.  This step
# sits in the middle because of dependency order, where the next
# generation step requires this executable.
#
# Add new x86 table generator.
#
#
gen_env = env.Clone();
gen_env.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])
ncdecode_tablegen = gen_env.ComponentProgram(
    'ncdecode_tablegen',
    ['ncdecode_tablegen.c',
     'ncdecode_forms.c',
     'zero_extends.c',
     'long_mode.c',
     'nc_rep_prefix.c',
     'defsize64.c',
     'nacl_illegal.c',
     'lock_insts.c',
     'ncdecode_st.c',
     'ncdecode_onebyte.c',
     'ncdecode_OF.c',
     'ncdecode_sse.c',
     'ncdecodeX87.c',
     'nacl_regsgen.c',
     ncopcode_desc_o,
     force_cpp_o,
    ],
    EXTRA_LIBS=['utils',
                'gio',
                'platform'])
gen_env.Requires(ncdecode_tablegen, crt)

#
# Now we are back to conditionally defining the large tables generated
# by ncdecode_tablegen.
#
if generate:
  #
  # Generate 32 and 64 bit versions of nc_opcode_table and nc_subregs
  #
  for filename in ['nc_opcode_table', 'nc_subregs']:
    for bits in ['32', '64']:
      fullname = '%s/gen/%s_%s.h' % (val_src_dir, filename, bits)
      exe_path = '${STAGING_DIR}/${PROGPREFIX}ncdecode_tablegen${PROGSUFFIX}'
      if filename == 'nc_subregs':
        cmd_line = '%s -m%s -nacl_subregs %s'% (exe_path, bits, fullname)
      else:
        cmd_line = '%s -m%s %s'% (exe_path, bits, fullname)
      out = gen_env.Command(env.File(fullname), exe_path, cmd_line)
  #    gen_env.Alias('valgen', source=[exe_path], action=[Action(cmd_line)])
      tables.append(fullname)

  gen_list = enum_headers + tables
  gen_env.AlwaysBuild(
      gen_env.Alias('valgen', gen_list))
  gen_env.AlwaysBuild(
      gen_env.Alias('valclean', action=[Delete(x) for x in gen_list]))


# Create environment for command-line tools and testing, rather than
# part of the TCB. Then define compile-time flag that communicates
# that we are compiling in the test environment (rather than for the TCB).
test_env = env.Clone();
test_env.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

# Define where generated code should be put.
ncv_gen_basedir = '${TARGET_ROOT}'
ncv_gen_dir = ncv_gen_basedir +'/gen/native_client/src/trusted/validator_x86'
# ======================================================================
# Helper functions for getting automated tests from the corresponding
# test directory.

TESTDATA_DIR = 'testdata/'
TESTDATA_SUBARCH_DIR = TESTDATA_DIR + env['TARGET_SUBARCH'] + '/'

# Generates the set of test files with the given extension.
def __GoldenFiles(ext):
  return Glob(TESTDATA_SUBARCH_DIR + '*.' + ext)

# Generates base names (i.e. minus path and extention (ext) suffix) of
# all test data input files.
def __FilterOutTestFileBaseGen(files, ext):
  for f in files:
    yield os.path.basename(f.path).replace('.' + ext, '')

# Generates the set of golden bases for the given extension.
def __GoldenBases(ext):
  return __FilterOutTestFileBaseGen(__GoldenFiles(ext), ext)

# Generates the corresponding test file from the given base.
def __BaseTestFile(base, ext):
  return test_env.File(TESTDATA_SUBARCH_DIR + base + '.' + ext)

# Generates the corresponding test name from the given base.
def __BaseTestName(test, base, ext):
  return test + '_' + base + '_' + ext

# Generates the corresponding output file from the given base.
def __OutTestFile(test, base, ext):
  return test + '_' + base + '.' + ext + '.out'

def __AddTest(test, test_env, base, ext, command, groups):
  test_env.AddNodeToTestSuite(command, groups, __BaseTestName(test, base, ext))


# Isolate the environment for ncdecode_table to prevent a cycle.
env_decode_table = test_env.Clone()
# TODO: This should be handled more cleanly, by just building
#   Testing type programs for coverage. But for the moment, we need sel_ldr
#   and others to have coverage, so it's easier to gate it off here.
env_decode_table['COVERAGE_LINKCOM_EXTRAS'] = None

ncdecode_table = env_decode_table.ComponentProgram('ncdecode_table',
                                                   ['ncdecode_table.c'],)
env.Requires(ncdecode_table, crt)



# Segment register validator library
NCVALIDATE_SOURCES = ['halt_trim.c',
                      'nacl_cpuid.c',
                      'ncdecode.c',
                      'ncinstbuffer.c',
                      'nc_segment.c',
                      'nc_inst_iter.c',
                      'nc_inst_state.c',
                      'nc_inst_trans.c',
                      'ncop_exps.c',
                      'ncvalidate.c',
                      'nccopycode.c',
                      'nccopycode_stores.S',
                      ncopcode_desc_o
                      ]

env.ComponentLibrary('ncvalidate', NCVALIDATE_SOURCES)

# SFI validator library.
# Note: When loading this library, follow it with ncvalidate, since
# it contains many routines and constants needed by this library.
env.ComponentLibrary('ncvalidate_sfi',
                     ['ncvalidate_iter.c',
                      'ncvalidator_registry.c',
                      'nc_opcode_histogram.c',
                      'nc_cpu_checks.c',
                      'nc_illegal.c',
                      'nc_protect_base.c',
                      'nc_memory_protect.c',
                      'ncvalidate_utils.c',
                      'nc_jumps.c'])

test_env.ComponentLibrary('ncdis_util',
                          ['ncdis_util.c',
                           'ncdis_segments.c',
                           'ncval_driver.c',
                           'nc_read_segment.c',
                           'ncenuminsts.c'])

#------------------------------------------------------------------
# Generate the header files containing the modeled x86 instructions.


def TestGeneratedInstructionTables(target_subarch, golden_filename, groups):
  test_name = 'ncdecode_tablegen_inst_tables_' + target_subarch + '.out'
  golden_output = env.File(TESTDATA_DIR + test_subarch + '/' + golden_filename)
  test = test_env.CommandTest(
      test_name,
      [ncdecode_tablegen, '-m%s' % (target_subarch,)],
      stdout_golden = golden_output)
  test_env.AddNodeToTestSuite(test, groups, test_name)


def TestGeneratedSubregisterTables(target_subarch, golden_filename, groups):
  test_name = 'ncdecode_tablegen_subreg_tables_' + target_subarch + '.out'
  golden_output = env.File(TESTDATA_DIR + test_subarch + '/' + golden_filename)
  test = test_env.CommandTest(
      test_name,
      [ncdecode_tablegen, '-m%s -nacl_subregs' % (target_subarch,)],
      stdout_golden = golden_output)
  test_env.AddNodeToTestSuite(test, groups, test_name)



# The following verifies that we generate the same source files, independent of
# whether the 32 bit or 64 bit table generator is used.
# Note: This is important in the 64-bit case on Windows, in that we want
# to make sure if the 32-bit generator is used, we still generate the
# same source files.
for test_subarch in ['32', '64']:
  TestGeneratedInstructionTables(test_subarch, 'nc_opcode_table.h',
                                 ['small_tests', 'validator_tests'])
  TestGeneratedSubregisterTables(test_subarch, 'nc_subregs.h',
                                 ['small_tests', 'validator_tests'])

# ======================================================================
# Decoder unittests
if test_env.Bit('target_x86_32'):
  # TODO(kschimpf): remove this when the validator builds as 64-bits.
  if test_env.Bit('build_x86_32'):
    ncdecode_tests = test_env.ComponentProgram(
        'ncdecode_tests',
        ['ncdecode_tests.c'],
        EXTRA_LIBS=['ncdis_util',
                    'ncvalidate'])

    node = test_env.CommandTest(
        'ncdecode_tests.out',
        [ncdecode_tests],
        )

    test_env.AddNodeToTestSuite(node, ['small_tests'])

# ======================================================================
ncdis = test_env.ComponentProgram(
  'ncdis', [
    'ncdis.c',
    force_cpp_o,
  ],
  EXTRA_LIBS=[
    'ncdis_util',
    'utils',
    'ncvalidate',
    'nchelper',
    'ncdis_util',
    'platform',
    'gio'
  ])

env.Requires(ncdis, crt)

# ======================================================================
# Valiator unittests
if test_env.Bit('target_x86_32'):
  ncval_tests = test_env.ComponentProgram('ncval_tests',
                                          ['ncval_tests.c'],
                                          EXTRA_LIBS=['ncvalidate', 'nchelper'])
  test_env.Requires(ncval_tests, crt)

  node = test_env.CommandTest(
      'ncval_tests.out',
      [ncval_tests],
      )

  test_env.AddNodeToTestSuite(node, ['small_tests', 'validator_tests'])

# ======================================================================
nacl_cpuid = test_env.ComponentProgram('nacl_cpuid',
                                       ['nacl_cpuid_test.c'],
                                       EXTRA_LIBS=['ncvalidate'])
test_env.Requires(nacl_cpuid, crt)
node = test_env.CommandTest(
    'nacl_cpuid_test.out',
    [nacl_cpuid])
test_env.AddNodeToTestSuite(node, ['large_tests'])

# ======================================================================
# Decoder vs objdump tests
# TODO: add tests using the toolchain binaries in the sdk
if test_env.Bit('linux') and test_env.Bit('target_x86_32'):
  test = 'discmp'
  ext = 'nexe'
  for base in __GoldenBases(ext):
    node = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        ["${PYTHON}", test_env.File('discmp.py'), test_env.File('ncdis'),
         __BaseTestFile(base, ext)],
        )
    __AddTest(test, test_env, base, ext, node, ['large_tests'])

# ======================================================================
# Decoder on sample instruction sequences.
TARGET_ARCH_NAME =  env['TARGET_ARCHITECTURE'] + '_' + env['TARGET_SUBARCH']

NCDIS_TEST_NAME = 'ncdis_' + TARGET_ARCH_NAME + '_test'

ncdis_input_golden = test_env.File(TESTDATA_SUBARCH_DIR + 'ncdis_test.input')

ncdis_test = test_env.CommandTest(
    NCDIS_TEST_NAME + '.out',
    [ncdis , '--use_iter=false', '--self_document', '--commands=-'],
    stdin=ncdis_input_golden,
    stdout_golden=ncdis_input_golden)

test_env.AddNodeToTestSuite(ncdis_test, ['small_tests'], NCDIS_TEST_NAME)

# ======================================================================
# Decoder on sample instruction sequences using new iterator model.

NCDIS_ITER_TEST_NAME = 'ncdis_iter_' + TARGET_ARCH_NAME + '_test'

ncdis_iter_input_golden = test_env.File(TESTDATA_SUBARCH_DIR + 'ncdis_iter_test.input')

ncdis_iter_test = test_env.CommandTest(
    NCDIS_ITER_TEST_NAME + '.out',
    [ncdis , '--use_iter', '--self_document', '--commands=-'],
    stdin=ncdis_iter_input_golden,
    stdout_golden=ncdis_iter_input_golden)

test_env.AddNodeToTestSuite(ncdis_iter_test,
                            ['small_tests'],
                            NCDIS_ITER_TEST_NAME)

# Same as above, but comparing internal representation against golde files.

ncdis_iter_internal_golden = test_env.File(TESTDATA_SUBARCH_DIR +
                                           'ncdis_iter_test.internal')

ncdis_internal_test = test_env.CommandTest(
    NCDIS_ITER_TEST_NAME + '_int.out',
    [ncdis, '--use_iter', '--internal', '--commands=-'],
    stdin=ncdis_iter_input_golden,
    stdout_golden=ncdis_iter_internal_golden)

test_env.AddNodeToTestSuite(ncdis_internal_test,
                            ['small_tests'],
                            NCDIS_ITER_TEST_NAME)

# ======================================================================
# Segment register validator.
ncval = test_env.ComponentProgram(
  'ncval', [
    'ncval.c',
    force_cpp_o,
  ],
  EXTRA_LIBS=[
    'ncdis_util',
    'ncvalidate_sfi',
    'ncvalidate',
    'nchelper',
    'platform',
    'gio',
    'utils'
  ])

test_env.Requires(ncval, crt)

# ======================================================================
# Validator tests against real nacl images
# TODO: add death tests
# TODO: add tests using binaries produced by nacl.scons files
# TODO: consider comparing the actual output (not just exit codes)
# Validate tests
if env.Bit('target_x86_32'):
  test = 'validate'
  ext = 'nexe'
  for base in __GoldenBases(ext):
    node = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncval, '-t', __BaseTestFile(base, ext)],
        )
    __AddTest(test, test_env, base, ext, node, ['large_tests'])

# Run tests using ncdis on test files. Assumes that extension
# dis implies to use the iterator model, while ndis does not.
def __AddNcDisTests(use_iter):
  test = 'ncdis_hex'
  if use_iter:
    ext = 'dis'
  else:
    ext = 'ndis'
  options = ['--hex_text=-']
  if use_iter:
    options.append('--use_iter');
  else:
    options.append('--use_iter=false');
  for base in __GoldenBases(ext):
    node_dis = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncdis] + options,
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_dis,
              ['small_tests', 'validator_tests'])

__AddNcDisTests(True)
__AddNcDisTests(False)

# Run tests using ncval --use_iter, on test files. Assume that write sandbox
# tests use extension 'val' while read/write sandbox tests use extension
# 'rval'. Assumes that a suffix of 0 on the extension implies no CPUID flags
# set. Otherwise, assume that test is run with all CPUID flags set.
def __AddNcvalSfiTests(test_readwrite, test_cpuid_all):
  if env.Bit('target_x86_64'):
    test = 'ncval64_hex'
    options = ['--use_iter', '--hex_text=-', '--max_errors=-1']
    if test_readwrite:
      ext = 'rval'
      options.append('--readwrite_sfi')
    else:
      ext = 'val'
      options.append('--write_sfi')
    if test_cpuid_all:
      options.append('--cpuid-all')
    else:
      ext = ext + '0'
      options.append('--cpuid-none')
    for base in __GoldenBases(ext):
      command = [ncval] + options
      node_val = test_env.CommandTest(
          __OutTestFile(test, base, ext),
          command,
          stdin = __BaseTestFile(base, 'hex'),
          stdout_golden = __BaseTestFile(base, ext))
      __AddTest(test, test_env, base, ext, node_val,
                ['small_tests', 'validator_tests'])

for read_write in [False, True]:
  for cpu_features_all in [False, True]:
   __AddNcvalSfiTests(read_write, cpu_features_all)

# Run tests using ncval --use_iter=false on test files.
def __AddNcvalSegmentTests(test_cpuid_all):
  if env.Bit('target_x86_32'):
    ext = 'nval'
    options = ['--use_iter=false',
               '--hex_text=-',
               '--max_errors=-1']
    if test_cpuid_all:
      options.append('--cpuid-all')
    else:
      ext += '0'
      options.append('--cpuid-none')
    test = 'ncval32_hex'
    for base in __GoldenBases(ext):
      command = [ncval] + options
      node_val = test_env.CommandTest(
          __OutTestFile(test, base, ext),
          command,
          stdin = __BaseTestFile(base, 'hex'),
          stdout_golden = __BaseTestFile(base, ext))
      __AddTest(test, test_env, base, ext, node_val,
                ['small_tests', 'validator_tests'])

for cpu_features_all in [False, True]:
  __AddNcvalSegmentTests(cpu_features_all)

# Run tests for stubout on test files. Assumes that the extension
# sval implies to use the SFI model, while snval implies use of the
# (32 bit) segment model. The input file uses extension hex.
def __AddNcValStuboutTests(use_sfi):
  if env.Bit('target_x86_32') or use_sfi:
    test = 'ncval_stubout'
    options = ['--hex_text=-', '--stubout']
    if use_sfi:
      ext = 'sval'
      options.append('--use_iter')
    else:
      ext = 'snval'
      options.append('--use_iter=false')
    for base in __GoldenBases(ext):
      command = [ncval] + options
      node_stubout = test_env.CommandTest(
          __OutTestFile(test, base, ext),
          command,
          stdin = __BaseTestFile(base, 'hex'),
          stdout_golden = __BaseTestFile(base, ext))
      __AddTest(test, test_env, base, ext, node_stubout,
                ['small_tests', 'validator_tests'])

__AddNcValStuboutTests(True)
__AddNcValStuboutTests(False)

# Run test to see if we have changed the set of modeled instructions.
def __AddModeledInstsTest():
  test = 'test'
  base = 'modeled_insts'
  ext = 'txt'
  command = [ncdecode_tablegen,
             '-m%s' % (env['TARGET_SUBARCH']),
             '-documentation']
  model = test_env.CommandTest(
      __OutTestFile(test, base, ext),
      command,
      stdout_golden = __BaseTestFile(base, ext))
  __AddTest(test, test_env, base, ext, model,
            ['small_tests',
             'validator_tests',
             'validator_modeling'])

__AddModeledInstsTest()


# Run test to show that --max_errors=-1 works in 32 bit mode.
def __AddNegMaxErrors():
  if env.Bit('target_x86_32'):
    test = 'neg_max_errs'
    base = 'ret'
    ext = 'nval'
    node_val = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncval, '--use_iter=false', '--max_errors=-1', '--hex_text=-'],
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_val,
              ['small_tests', 'validator_tests'])

__AddNegMaxErrors()

#---------- UNIT TESTS ---------------------------------

# Create an environment to run unit tests using Gtest.
gtest_env = test_env.Clone();

# gtest does not compile with our stringent settings.
gtest_env.FilterOut(
    CCFLAGS=['-pedantic'],
    CXXFLAGS=['-fno-rtti', '-Weffc++'])
gtest_env.Prepend(CPPPATH=['${SOURCE_ROOT}/testing/gtest/include'])

# List of (unit) test file prefixes to run unit tests on.
gtest_sources = ['halt_trim',
                 'nc_remaining_memory',
                 'nc_inst_bytes',
                 'nc_inst_state']

for source in gtest_sources:
  test_exe = gtest_env.ComponentProgram(
    'x86_validator_tests_' + source,
    [source+'_tests.cc'],
    EXTRA_LIBS=['gtest',
                'ncvalidate',
                'platform',
                'gio',
                ]);
  test_node = gtest_env.CommandTest(
      source+'Tests.out',
      command=[test_exe])
  gtest_env.AddNodeToTestSuite(test_node, ['small_tests'],
                               'run_x86_validator_tests')

