# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


import os
import sys
Import('env')

#
#
# Build x86 only pieces
#
#
if not env.Bit('target_x86'): Return()

# ------------------------------------------------------
# General adjustments to the environment for builds.

# Make a copy of debug CRT for now.
# TODO(bradnelson): there should be a better way to generalize this requirement.
# NOTE: debug builds on windows break without this
crt = []
if env.AllBits('windows', 'debug'):
  for i in ['.', '$STAGING_DIR']:
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/Debug_NonRedist/'
                         'x86/Microsoft.VC80.DebugCRT')
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/x86/Microsoft.VC80.CRT')

# Defines which test sets tests should be added to.
STANDARD_TESTS = ['small_tests', 'validator_tests']

# Define which test sets modeling test should be added to
MODELING_TESTS = STANDARD_TESTS + ['validator_modeling']

# TODO(bradchen): eliminate need for the following line
env.FilterOut(CCFLAGS=['-Wextra', '-Wswitch-enum', '-Wsign-compare'])

#
#
# force_cpp_o
#
# This object file is used to mark a library/executable as containing C++.
force_cpp_o = env.ComponentObject('force_cpp.cc')

# Defines the source directory where validator generated files should be added.
val_src_dir = '$MAIN_DIR/src/trusted/validator_x86'

# Create environment for command-line tools and testing, rather than
# part of the TCB. Then define compile-time flag that communicates
# that we are compiling in the test environment (rather than for the TCB).
test_env = env.Clone();
test_env.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

# ------------------------------------------------------
# Source generation:
#
# Source generation is done in three steps. The first generates
# enumerated types. The second generates decoder tables needed by
# the decoders. In between these two steps we generate the executables
# that build the decoder tables.
#
# Source generation is controlled by to command line directives, and can be
# built in either the x86-32 or the x86-64 platform. The two directives are:
#
#   valclean : Delete the existing versions of the generated files.
#       This step should be done whenever ANY change may effect
#       the generated sources.
#
#   valgen : Regenerate any deleted source files. Note: some generated
#       source files do understand dependencies and do not need to be
#       deleted before calling valgen. However, do not count on this,
#       as some dependencies are not caught. To be safe, if you have
#       modified a file that effects source generation, run "valclean"
#       followed by a "valgen" to guarantee that generated sources are
#       up to date.

gen_env = env.Clone();
gen_env.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

generate = False
if 'valgen' in COMMAND_LINE_TARGETS: generate = True
if 'valclean' in COMMAND_LINE_TARGETS: generate = True

# Set of generated (source) decoder tables.
tables = []

# Set of generated (source) enumeration files.
enum_headers = []

# ------------------------------------------------------
#  Source generation step 1: Generate enumerated types.
#
# Only generate/clean these files if the alias is specified on the
# command line.  We conditionally add these pieces to scons to prevent
# a normal invocation from accidentally regenerating the files.
#
if generate:
  #
  # valgen - Table Generator
  #
  # We create an alias 'valgen' which we use to generate the various
  # headers used by the x86 validator.  This target will generate
  # *.h, *_impl.h from the *.enum files, as well as the executables
  # ncdecode_table and ncdecode_tablegen which are used to generate
  # the large opcode tables.
  #

  # Get the directory in which we will generate checking in files.
  header_prefix = gen_env.subst('${MAIN_DIR}')
  if header_prefix.endswith('/native_client'):
    header_prefix = header_prefix[0:header_prefix.rfind('native_client')]
  elif header_prefix.endswith('/native_client/'):
    header_prefix = header_prefix[0:header_prefix.rfind('native_client/')]

  #------------------------------------------------------
  # Generate the needed header files for enumerated types.
  # Note that we use the same directory for all platforms.

  # Define enumerate type files, and the options to process.
  ncv_enum_pairs = {
      'nacl_disallows': '--name=NaClDisallowsFlag --add_size=1',
  }

  # Now code generate the enumerated types.
  for ncv_enum in ncv_enum_pairs:
    ncv_options = ncv_enum_pairs[ncv_enum]
    ncv_enum_file = gen_env.File(ncv_enum + '.enum')
    ncv_header_1 = gen_env.File('%s/gen/%s.h' % (val_src_dir, ncv_enum))
    ncv_header_2 = gen_env.File('%s/gen/%s_impl.h' % (val_src_dir, ncv_enum))

    cmd_line = (
        '${PYTHON} %s --header="%s" --source="%s" --path_prefix="%s" %s %s' %
        (gen_env.File('enum_gen.py'), ncv_header_1, ncv_header_2, header_prefix,
         ncv_options, ncv_enum_file))

    gen_env.Command([ncv_header_1, ncv_header_2], ncv_enum_file, cmd_line)
    enum_headers.append(ncv_header_1)
    enum_headers.append(ncv_header_2)

# ------------------------------------------------------
# Table generators:
#
# In the middle of generating, we unconditionally add ncdecode_table and
# ncdecode_tablegen so that the tests which depend on it, can run correctly.
# This step sits in the middle because of dependency order, where the next
# generation step requires this executable.

# Add old x86 table generator.
#
#
# Isolate the environment for ncdecode_table to prevent a cycle.
env_decode_table = test_env.Clone()
# TODO: This should be handled more cleanly, by just building
#   Testing type programs for coverage. But for the moment, we need sel_ldr
#   and others to have coverage, so it's easier to gate it off here.
env_decode_table['COVERAGE_LINKCOM_EXTRAS'] = None

ncdecode_table = env_decode_table.ComponentProgram(
    'ncdecode_table',
    ['ncdecode_table.c'],
    EXTRA_LIBS=[env_decode_table.NaClTargetArchSuffix('ncval_base_verbose')])

env.Requires(ncdecode_table, crt)

# Add new x86 table generator.
#
#
ncdecode_tablegen = gen_env.ComponentProgram(
    'ncdecode_tablegen',
    ['ncdecode_tablegen.c',
     'nc_compress.c',
     'ncval_simplify.c',
     'ncdecode_forms.c',
     'zero_extends.c',
     'nc_def_jumps.c',
     'long_mode.c',
     'nc_rep_prefix.c',
     'defsize64.c',
     'nacl_illegal.c',
     'lock_insts.c',
     'ncdecode_st.c',
     'ncdecode_onebyte.c',
     'ncdecode_OF.c',
     'ncdecode_sse.c',
     'ncdecodeX87.c',
     'nacl_regsgen.c',
     'modeled_nacl_inst.c',
     force_cpp_o,
    ],
    EXTRA_LIBS=[gen_env.NaClTargetArchSuffix('nc_opcode_modeling_verbose'),
                'utils'])

gen_env.Requires(ncdecode_tablegen, crt)

# ------------------------------------------------------
#  Source generation step 2: Generate decoder tables.
#
# Now we are back to conditionally defining the large tables generated
# by ncdecode_tablegen.
#
if generate:
  #
  # Generate 32 and 64 bit versions of ncdecodetab and ncdisasmtab.
  #
  for bits in ['32', '64']:
    ncv_decodetab_h = '%s/gen/%s_%s.h' % (val_src_dir, 'ncdecodetab', bits)
    ncv_disasmtab_h = '%s/gen/%s_%s.h' % (val_src_dir, 'ncdisasmtab', bits)
    ncv_badprefixmask_h= '%s/gen/%s_%s.h' % (val_src_dir, 'ncbadprefixmask', bits)
    exe_path = '${STAGING_DIR}/${PROGPREFIX}ncdecode_table${PROGSUFFIX}'
    gen_env.Command(
        [ncv_decodetab_h, ncv_disasmtab_h, ncv_badprefixmask_h],
        exe_path,
        ['%s -m%s %s %s %s' % (exe_path, bits, ncv_decodetab_h,
                               ncv_disasmtab_h, ncv_badprefixmask_h )]
    )
    tables.append(ncv_decodetab_h)
    tables.append(ncv_disasmtab_h)
    tables.append(ncv_badprefixmask_h)

  #
  # Generate 32 and 64 bit versions of nc_opcode_table and nc_subregs
  #
  for filename in ['nc_opcode_table', 'nc_subregs', 'ncval_reg_sfi_opcode_table']:
    for bits in ['32', '64']:
      fullname = '%s/gen/%s_%s.h' % (val_src_dir, filename, bits)
      exe_path = '${STAGING_DIR}/${PROGPREFIX}ncdecode_tablegen${PROGSUFFIX}'
      if filename == 'nc_subregs':
        cmd_line = '%s -m%s -nacl_subregs %s'% (exe_path, bits, fullname)
      elif filename == 'ncval_reg_sfi_opcode_table':
        cmd_line = '%s -m%s -validator_decoder %s'% (exe_path, bits, fullname)
      else:
        cmd_line = '%s -m%s %s'% (exe_path, bits, fullname)
      out = gen_env.Command(env.File(fullname), exe_path, cmd_line)
      tables.append(fullname)

  # Generate 32 and 64 bit versions of ncval_opcode_table (validator
  # decoder tables)
  gen_list = enum_headers + tables
  gen_env.AlwaysBuild(
      gen_env.Alias('valgen', gen_list))
  gen_env.AlwaysBuild(
      gen_env.Alias('valclean', action=[Delete(x) for x in gen_list]))

# ======================================================================
# Helper functions for getting automated tests from the corresponding
# test directory.

TESTDATA_DIR = 'testdata/'
TESTDATA_SUBARCH_DIR = TESTDATA_DIR + env['TARGET_SUBARCH'] + '/'

# Generates the set of test files with the given extension.
def __GoldenFiles(ext):
  return Glob(TESTDATA_SUBARCH_DIR + '*.' + ext)

# Generates base names (i.e. minus path and extention (ext) suffix) of
# all test data input files.
def __FilterOutTestFileBaseGen(files, ext):
  for f in files:
    yield os.path.basename(f.path).replace('.' + ext, '')

# Generates the set of golden bases for the given extension.
def __GoldenBases(ext):
  return __FilterOutTestFileBaseGen(__GoldenFiles(ext), ext)

# Generates the corresponding test file from the given base.
def __BaseTestFile(base, ext):
  return test_env.File(TESTDATA_SUBARCH_DIR + base + '.' + ext)

# Generates the corresponding test name from the given base.
def __BaseTestName(test, base, ext):
  return test + '_' + base + '_' + ext

# Generates the corresponding output file from the given base.
def __OutTestFile(test, base, ext):
  return test + '_' + base + '.' + ext + '.out'

def __AddTest(test, test_env, base, ext, command, groups):
  test_env.AddNodeToTestSuite(command, groups, __BaseTestName(test, base, ext))


# The following are common library components that use elements
# of both x86-32 and x86-64 validators.
test_env.ComponentLibrary(test_env.NaClTargetArchSuffix('ncdis_util'),
                          ['ncdis_segments.c',
                           'ncval_decode_tables.c',
                           'nc_read_segment.c',
                           'ncenuminsts.c'])

# The following are copycode routines for x86-32 and x86-64.
# TODO(karl): Break this up so that we don't need to load
# non-shared code in library.
env.ComponentLibrary(env.NaClTargetArchSuffix('nccopy'), [
    'nccopycode.c',
    'nccopycode_stores.S',
    ])

#------------------------------------------------------------------
# Generate the header files containing the modeled x86 instructions.

def TestGeneratedInstructionTables(target_subarch, golden_filename, groups):
  test_name = 'ncdecode_tablegen_inst_tables_' + target_subarch + '.out'
  golden_output = env.File('gen/' + golden_filename + '_' + target_subarch + '.h')
  test = test_env.CommandTest(
      test_name,
      [ncdecode_tablegen, '-m%s' % (target_subarch,)],
      stdout_golden = golden_output)
  test_env.AddNodeToTestSuite(test, groups, test_name)


def TestGeneratedSubregisterTables(target_subarch, golden_filename, groups):
  test_name = 'ncdecode_tablegen_subreg_tables_' + target_subarch + '.out'
  golden_output = env.File('gen/' + golden_filename + '_' + target_subarch + '.h')
  test = test_env.CommandTest(
      test_name,
      [ncdecode_tablegen, '-m%s -nacl_subregs' % (target_subarch,)],
      stdout_golden = golden_output)
  test_env.AddNodeToTestSuite(test, groups, test_name)



# The following verifies that we generate the same source files, independent of
# whether the 32 bit or 64 bit table generator is used.
# Note: This is important in the 64-bit case on Windows, in that we want
# to make sure if the 32-bit generator is used, we still generate the
# same source files.
for test_subarch in ['32', '64']:
  TestGeneratedInstructionTables(test_subarch, 'nc_opcode_table',
                                 STANDARD_TESTS)
  TestGeneratedSubregisterTables(test_subarch, 'nc_subregs',
                                 STANDARD_TESTS)

# ======================================================================
# Decoder unittests
if test_env.Bit('target_x86_32'):
  # TODO(kschimpf): remove this when the validator builds as 64-bits.
  if test_env.Bit('build_x86_32'):
    ncdecode_tests = test_env.ComponentProgram(
        'ncdecode_tests',
        ['ncdecode_tests.c'],
        EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_seg_sfi_verbose'),
                    ])

    node = test_env.CommandTest(
        'ncdecode_tests.out',
        [ncdecode_tests],
        )

    test_env.AddNodeToTestSuite(node, STANDARD_TESTS)

# ======================================================================
# Build command line decoder.
#
ncdis = test_env.ComponentProgram(
  'ncdis', [
    'ncdis.c',
    force_cpp_o,
  ],
  EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_util'),
              #test_env.NaClTargetArchSuffix('ncdis_seg_sfi_verbose'),
              test_env.NaClTargetArchSuffix('ncfileutils'),
              'utils',
              ])

env.Requires(ncdis, crt)

# ======================================================================
# Valiator unittests
if test_env.Bit('target_x86_32'):
  ncval_tests = test_env.ComponentProgram(
      'ncval_tests',
      ['ncval_tests.c'],
      EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_util'),
                  test_env.NaClTargetArchSuffix('ncval_seg_sfi'),
                  ])
  test_env.Requires(ncval_tests, crt)

  node = test_env.CommandTest(
      'ncval_tests.out',
      [ncval_tests],
      )

  test_env.AddNodeToTestSuite(node, STANDARD_TESTS)

# ======================================================================
# Define what decoder was historically being used for tests. This allows
# existing tests to continue to follow that historical assumption.

if test_env.Bit('target_x86_32'):
  _ncdis_historical_decoder = '--validator_decoder'
else:
  _ncdis_historical_decoder = '--full_decoder'


# ======================================================================
# Decoder vs objdump tests
# TODO: add tests using the toolchain binaries in the sdk
if test_env.Bit('linux') and test_env.Bit('target_x86_32'):
  test = 'discmp'
  ext = 'nexe'
  for base in __GoldenBases(ext):
    node = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        ["${PYTHON}", test_env.File('discmp.py'), test_env.File('ncdis'),
         __BaseTestFile(base, ext)],
        )
    __AddTest(test, test_env, base, ext, node, ['large_tests'])

# ======================================================================
# Run tests on ncdis, where the input is self documenting (i.e. the input
# file matches the generated resulit.
def __AddNcdisSelfDocTests(validator_decoder, internals_also):
  test = 'ncdis_test'
  options = ['--commands=-']
  input_ext = 'input'
  if internals_also:
    output_ext = 'internal'
    options.append('--internal')
  else:
    output_ext = input_ext
    options.append('--self_document')
  if validator_decoder:
    output_ext = 'v' + output_ext
    options.append('--validator_decoder')
  else:
    options.append('--full_decoder')
  for base in __GoldenBases(output_ext):
    command = [ncdis] + options
    ncdis_test = test_env.CommandTest(
        __OutTestFile(test, base, output_ext),
        command,
        stdin = __BaseTestFile(base, input_ext),
        stdout_golden = __BaseTestFile(base, output_ext))
    __AddTest(test, test_env, base, output_ext, ncdis_test,
              STANDARD_TESTS)

for validator_decoder in [False, True]:
  for internals_also in [False, True]:
    __AddNcdisSelfDocTests(validator_decoder, internals_also)

# ======================================================================
# Build command line validator.
ncval = test_env.ComponentProgram(
  'ncval', [
    'ncval.c',
    force_cpp_o,
  ],
  EXTRA_LIBS=[test_env.NaClTargetArchSuffix('ncdis_util'),
              test_env.NaClTargetArchSuffix('ncval_seg_sfi'),
              test_env.NaClTargetArchSuffix('ncfileutils'),
              'utils'
              ])

test_env.SDKInstallTrusted('ncval', ncval)

test_env.Requires(ncval, crt)

# ======================================================================
# Validator tests against real nacl images
# TODO: add death tests
# TODO: add tests using binaries produced by nacl.scons files
# TODO: consider comparing the actual output (not just exit codes)
# Validate tests
if env.Bit('target_x86_32'):
  test = 'validate'
  ext = 'nexe'
  for base in __GoldenBases(ext):
    node = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncval, '-t', __BaseTestFile(base, ext)],
        )
    __AddTest(test, test_env, base, ext, node, ['large_tests'])

# Run tests using ncdis on test files.
def __AddNcDisTests(validator_decoder):
  test = 'ncdis_hex'
  options = ['--hex_text=-']
  if validator_decoder:
    ext = 'vdis'
    options.append('--validator_decoder')
  else:
    ext = 'dis'
    options.append('--full_decoder')
  for base in __GoldenBases(ext):
    node_dis = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncdis] + options,
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_dis, STANDARD_TESTS)

for validator_decoder in [False, True]:
  __AddNcDisTests(validator_decoder)

# Run tests using ncval on test files. Assume that write sandbox
# tests use extension 'val' while read/write sandbox tests use extension
# 'rval'. Assumes that a suffix of 0 on the extension implies no CPUID flags
# set. Otherwise, assume that test is run with all CPUID flags set.
def __AddNcvalSfiTests(test_readwrite, test_cpuid_all, test_annotate):
  if env.Bit('target_x86_64'):
    test = 'ncval64_hex'
    options = ['--hex_text=-', '--max_errors=-1']
    if test_readwrite:
      ext = 'rval'
      options.append('--readwrite_sfi')
    else:
      ext = 'val'
      options.append('--write_sfi')
    if test_cpuid_all:
      options.append('--cpuid-all')
    else:
      ext = ext + '0'
      options.append('--cpuid-none')
    if test_annotate:
      ext += 'a'
      options.append('--annotate');
    else:
      options.append('--annotate=false');
    for base in __GoldenBases(ext):
      command = [ncval] + options
      node_val = test_env.CommandTest(
          __OutTestFile(test, base, ext),
          command,
          stdin = __BaseTestFile(base, 'hex'),
          stdout_golden = __BaseTestFile(base, ext))
      __AddTest(test, test_env, base, ext, node_val,
                STANDARD_TESTS)

for read_write in [False, True]:
  for cpu_features_all in [False, True]:
    for annotate in [False, True]:
      __AddNcvalSfiTests(read_write, cpu_features_all, annotate)

# Run segment sandboxing tests using ncval on test files.
def __AddNcvalSegmentTests(test_cpuid_all, test_stats, detailed, align_16):
  if env.Bit('target_x86_32'):
    options = ['--hex_text=-',
               '--max_errors=-1']
    ext = 'nval'
    if (detailed):
      ext += 'd'
      options.append('--detailed')
    else:
      options.append('--detailed=false')
    if (test_stats):
      ext += 's'
      options.append('--stats')
    if (align_16):
      ext += '16'
      options.append('--alignment=16')
    else:
      options.append('--alignment=32')
    if test_cpuid_all:
      options.append('--cpuid-all')
    else:
      ext += '0'
      options.append('--cpuid-none')
    test = 'ncval32_hex'
    for base in __GoldenBases(ext):
      command = [ncval] + options
      node_val = test_env.CommandTest(
          __OutTestFile(test, base, ext),
          command,
          stdin = __BaseTestFile(base, 'hex'),
          stdout_golden = __BaseTestFile(base, ext))
      __AddTest(test, test_env, base, ext, node_val,
                STANDARD_TESTS)

for cpu_features_all in [False, True]:
  for test_stats in [False, True]:
    for detailed in [False, True]:
      for align_16 in [False, True]:
        __AddNcvalSegmentTests(cpu_features_all, test_stats,
                               detailed, align_16)

# Run tests for stubout on test files. The input file uses extension hex.
def __AddNcValStuboutTests():
  test = 'ncval_stubout'
  options = ['--hex_text=-', '--stubout']
  ext = 'sval'
  for base in __GoldenBases(ext):
    command = [ncval] + options
    node_stubout = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        command,
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_stubout,
              STANDARD_TESTS)

__AddNcValStuboutTests()

# Run test to see if we have changed the set of modeled instructions.
def __AddModeledInstsTest():
  prefixes = ['']
  if test_env.Bit('build_x86_64'):
    prefixes.append('ncval_reg_sfi_')
  for prefix in prefixes:
    test = 'test'
    base = prefix + 'modeled_insts'
    ext = 'txt'
    command = [ncdecode_tablegen,
               '-m%s' % (env['TARGET_SUBARCH']),
               '-documentation']
    if prefix == 'ncval_reg_sfi_':
      command.append('-validator_decoder')
    model = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        command,
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, model,
              MODELING_TESTS)

__AddModeledInstsTest()


# Run test to show that --max_errors=-1 works in 32 bit mode.
def __AddNegMaxErrors():
  if env.Bit('target_x86_32'):
    test = 'neg_max_errs'
    base = 'ret'
    ext = 'nval'
    node_val = test_env.CommandTest(
        __OutTestFile(test, base, ext),
        [ncval, '--max_errors=-1', '--hex_text=-'],
        stdin = __BaseTestFile(base, 'hex'),
        stdout_golden = __BaseTestFile(base, ext))
    __AddTest(test, test_env, base, ext, node_val,
              ['small_tests', 'validator_tests'])

__AddNegMaxErrors()
