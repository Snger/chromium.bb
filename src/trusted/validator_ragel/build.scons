# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

Import('env')

#
#
# Build on x86 only.
#
#
if not env.Bit('target_x86'):
  Return()

# General adjustments to the environment for builds.

# TODO(khim): eliminate flag modification based on OS.
# See http://code.google.com/p/nativeclient/issues/detail?id=2718 for details.
if env.Bit('windows'):
  env.FilterOut(CCFLAGS=['/O1'])
# XCode 4.2 takes too long to compile with -Os, LLVM for MacOS times out.
if env.Bit('mac'):
  env.FilterOut(CCFLAGS=['-Os'])

# ASAN takes too long with optimizations enabled and is killed on buildbot.
# We don't really need to build with optimizations under ASAN (although it's
# nice thing to do).
# TODO(khim): Remove this when/if the following bug is fixed.
#   http://code.google.com/p/address-sanitizer/issues/detail?id=61
# NOTE: ASAN bot uses -O2 under Linux and -Os under mac.
if env.Bit('asan'):
  env.FilterOut(CCFLAGS=['-Os', '-O2'])

# Defines the source directory where validator generated files should be added.
rl_src_dir = '$OBJ_ROOT/src/trusted/validator_ragel'
val_src_dir = '$MAIN_DIR/src/trusted/validator_ragel/gen'

# Source generation:
#
#   valgen : Regenerate any autogenerated source files.

generate = False
if ('valgen' in COMMAND_LINE_TARGETS) or ('valclean' in COMMAND_LINE_TARGETS):
  generate = True

if generate:
  # Set of generated (source) decoder automatas.
  automatas = []

  # Source generation step 1: Build generator of ragel files.
  #
  # We have generator which reads .def files and produced automata definition.
  #
  # Ragel is included in most Linux distributions, but it's not standard tool
  # on MacOS/Windows thus we only support gneration of automata under Linux.
  # This also means that we don't need to make sure gen-dfa.cc is portable to
  # non-POSIX platforms (in particular it's not Windows compatible).

  env_gen_dfa = env.Clone()
  env_gen_dfa.Append(CCFLAGS=['-std=c++0x', '-DNACL_TRUSTED_BUT_NOT_TCB'])

  gen_dfa = env_gen_dfa.ComponentProgram(
      'gen-dfa',
      ['unreviewed/gen-dfa.cc'])

  # Source generation step 2: Generate decoder automatas.
  #
  # Now we are back to conditionally defining the large automatas generated
  # by gen-dfa.

  # Generate 32 and 64 bit versions of decoders and validators.
  for bits in ['32', '64']:
    for automata in ['decoder', 'validator']:
      # We are cheating here: there are two autogenerated files:
      #  .rl and -consts.c, but we only track .rl one.  This is safe because
      #  -consts.c file includes constants referenced by .rl file and if .rl
      #  file is not changed -consts.c is guaranteed to be the same (reverse
      #  is not true).
      rl_file = '%s-x86_%s-instruction.rl' % (automata, bits)
      const_file = '%s/%s-x86_%s-instruction-consts.c' % (
          val_src_dir, automata, bits)
      exe_path = '${STAGING_DIR}/${PROGPREFIX}gen-dfa${PROGSUFFIX}'
      env.Command(
          target=rl_file,
          source=[
            exe_path,
            'unreviewed/general-purpose-instructions.def',
            'unreviewed/system-instructions.def',
            'unreviewed/x87-instructions.def',
            'unreviewed/mmx-instructions.def',
            'unreviewed/xmm-instructions.def',
            'unreviewed/nops.def'],
          action=[('${SOURCES[0]} -o ${TARGET} -c %s -m %s -d %s ${SOURCES[1]} '
            '${SOURCES[2]} ${SOURCES[3]} ${SOURCES[4]} ${SOURCES[5]} '
            '${SOURCES[6]}') % (
            # Const file (-c): not tracked by SCONS (see above)
            const_file,
            # Argument for CPU type (-m): either "ia32" or "amd64".
            {'32': 'ia32', '64': 'amd64'}[bits],
            # Argument for actions selection (-d): selects only actions we need.
            {'decoder32':
              'check_access,opcode,parse_operands_states,mark_data_fields',
             'decoder64':
              'check_access,opcode,parse_operands_states,mark_data_fields',
             'validator32':
              ('check_access,opcode,parse_operands,parse_operands_states,'
               'instruction_name,mark_data_fields,nacl-forbidden,'
               'imm_operand_action,rel_operand_action'),
             'validator64':
              ('opcode,instruction_name,mark_data_fields,rel_operand_action,'
               'nacl-forbidden,parse_nonwrite_registers,parse_x87_operands,'
               'parse_mmx_operands,parse_xmm_operands,parse_ymm_operands,'
               'parse_relative_operands,parse_immediate_operands,'
               'parse_operands_states,parse_operand_positions')
            }[automata+bits])]
      )
      automatas.append(rl_file)
      c_file = '%s/%s-x86_%s.c' % (val_src_dir, automata, bits)
      env.Command(
          target=c_file,
          source=['unreviewed/%s-x86_%s.rl' % (automata, bits), rl_file],
          action=['ragel -G2 -I%s ${SOURCES[0]} -o ${TARGET}' % (rl_src_dir)]
      )
      automatas.append(c_file)

  # Generate 32 and 64 bit versions of decoders and validators
  env.AlwaysBuild(env.Alias('valgen', automatas))
  env.AlwaysBuild(env.Alias('valclean', action=[Delete(x) for x in automatas]))

# Generate 32 and 64 bit versions of decoders and validators.  Both libraries
# are used for command-line decoder and validator those detect specific
# architecture of the ELF file provided.
for bits in ['32', '64']:
  env.ComponentLibrary('dfa_validate_x86_%s' % bits,
                       ['gen/validator-x86_%s.c' % bits])
  env.ComponentLibrary('dfa_decode_x86_%s' % bits,
                       ['gen/decoder-x86_%s.c' % bits])

# Glue library called from service runtime. The source file depends on the
# target architecture.
caller_lib_bits = None
if env.Bit('target_x86_32'):
  caller_lib_bits = '32'
if env.Bit('target_x86_64'):
  caller_lib_bits = '64'
if caller_lib_bits:
  caller_lib = 'dfa_validate_caller_x86_%s' % caller_lib_bits
  env.ComponentLibrary(caller_lib,
                       ['unreviewed/dfa_validate_%s.c' % caller_lib_bits])

# Command-line decoder.
env.ComponentProgram(
    'decoder-test',
    ['unreviewed/decoder-test.c'],
    EXTRA_LIBS=['dfa_decode_x86_32', 'dfa_decode_x86_64'])

# Command-line validator.
env.ComponentProgram(
    'validator-test',
    ['unreviewed/validator-test.c'],
    EXTRA_LIBS=['dfa_validate_x86_32', 'dfa_validate_x86_64'])
