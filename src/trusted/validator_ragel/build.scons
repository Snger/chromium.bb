# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

from SCons.Errors import UserError

Import('env')

#
#
# Build on x86 only.
#
#
if not env.Bit('target_x86'):
  Return()

# Defines the source directory where validator generated files should be added.
rl_src_dir = '$OBJ_ROOT/src/trusted/validator_ragel'
val_src_dir = '$MAIN_DIR/src/trusted/validator_ragel/gen'
# Currently we only provide ragel pre-built for Linux.
ragel_binary = '$MAIN_DIR/../third_party/ragel/ragel.linux'

INST_DEFS = [
    'unreviewed/general_purpose_instructions.def',
    'unreviewed/system_instructions.def',
    'unreviewed/x87_instructions.def',
    'unreviewed/mmx_instructions.def',
    'unreviewed/xmm_instructions.def',
    'unreviewed/nops.def'
]

# Source generation:
#
#   dfagen : Regenerate any autogenerated source files.

generate = False
if 'dfagen' in COMMAND_LINE_TARGETS or 'dfaclean' in COMMAND_LINE_TARGETS:
  generate = True

if generate:
  if not env.Bit('host_linux'):
    raise UserError('Right now DFA generation is only supported on Linux')

  # Source generation step 1: Build generator of ragel files.
  #
  # We have generator which reads .def files and produced automaton definition.
  #
  # Ragel is included in most Linux distributions, but it's not standard tool
  # on MacOS/Windows thus we only support gneration of automata under Linux.
  # This also means that we don't need to make sure gen_dfa.cc is portable to
  # non-POSIX platforms (in particular it's not Windows compatible).

  env_gen_dfa = env.Clone()
  env_gen_dfa.Append(CCFLAGS=['-std=c++0x', '-DNACL_TRUSTED_BUT_NOT_TCB'])

  gen_dfa = env_gen_dfa.ComponentProgram(
      'gen_dfa',
      ['unreviewed/gen_dfa.cc'])

  # Source generation step 2: Generate decoder automatas.
  #
  # Now we are back to conditionally defining the large automata generated
  # by gen_dfa.

  def MakeAutomaton(bits, automaton, dfa_gen_actions, ragel_flags):
    rl_file = '%s_x86_%s_instruction.rl' % (automaton, bits)

    # We are cheating here: there are two autogenerated files:
    #  .rl and _consts.c, but we only track .rl one.  This is safe because
    #  _consts.c file includes constants referenced by .rl file and if .rl
    #  file is not changed _consts.c is guaranteed to be the same (reverse
    #  is not true).
    const_file = '%s/%s_x86_%s_instruction_consts.c' % (
        val_src_dir, automaton, bits)

    exe_path = '${STAGING_DIR}/${PROGPREFIX}gen_dfa${PROGSUFFIX}'
    env.Command(
        target=rl_file,
        source=[exe_path] + INST_DEFS,
        action=(
            '${SOURCES[0]} -o ${TARGET} -c %s -m %s -d %s %s') % (
                # Const file (-c): not tracked by SCONS (see above)
                const_file,
                # Argument for CPU type (-m): either "ia32" or "amd64".
                {'32': 'ia32', '64': 'amd64'}[bits],
                # (-d):
                dfa_gen_actions,
                # pass inst defs as remaining parameters
                ' '.join('${SOURCES[%d]}' % (i+1)
                         for i in range(len(INST_DEFS)))
        )
    )
    c_file = '%s_x86_%s.c' % (automaton, bits)
    c_full_filename = '%s/%s' % (val_src_dir, c_file)
    env.Command(
        target=c_file,
        source=['unreviewed/%s_x86_%s.rl' % (automaton, bits), rl_file],
        action=['%s %s -LL -I%s ${SOURCES[0]} -o ${TARGET}' % (
            ragel_binary, ragel_flags, rl_src_dir)]
    )

    def InjectGeneratedFileHeader(target, source, env):
      source_filename = source[0].get_abspath()
      target_filename = target[0].get_abspath()
      architecture = {'x86_32': 'ia32',
                      'x86_64': 'x86-64'}[target_filename[-8:-2]]
      with open(source_filename, 'r') as source_file:
        with open(target_filename, 'w') as target_file:
          target_file.write(
"""/* native_client/%s
 * THIS FILE IS AUTO-GENERATED. DO NOT EDIT.
 * Compiled for %s mode.
 */""" % (target_filename, architecture))

          comment, sep, rest = source_file.read().partition('*/')
          if sep == '':
            raise UserError('Generated file %s does not have '
                            'header comment block' % source_filename)
          target_file.write(rest)

    env.Command(
        target=c_full_filename,
        source=['%s/%s' % (rl_src_dir, c_file)],
        action=InjectGeneratedFileHeader
    )

    return rl_file, c_file, c_full_filename

  decoder32 = MakeAutomaton(
    '32', 'decoder',
    'check_access,opcode,parse_operands_states,mark_data_fields',
    '-T0')
  validator32 = MakeAutomaton(
    '32', 'validator',
    ('check_access,opcode,parse_operands,parse_operands_states,'
     'instruction_name,mark_data_fields,nacl-forbidden,'
     'imm_operand_action,rel_operand_action'),
    '-G2')
  decoder64 = MakeAutomaton(
    '64', 'decoder',
    'check_access,opcode,parse_operands_states,mark_data_fields',
    '-T0')
  validator64 = MakeAutomaton(
    '64', 'validator',
    ('opcode,instruction_name,mark_data_fields,imm_operand_action,'
     'rel_operand_action,nacl-forbidden,parse_nonwrite_registers,'
     'parse_x87_operands,parse_mmx_operands,parse_xmm_operands,'
     'parse_ymm_operands,parse_relative_operands,'
     'parse_immediate_operands,parse_operands_states,'
     'parse_operand_positions'),
    '-GT2')

  automata = list(decoder32 + validator32 + decoder64 + validator64)

  env.AlwaysBuild(env.Alias('dfagen', automata))
  env.AlwaysBuild(env.Alias('dfaclean', action=map(Delete, automata)))

# Generate 32 and 64 bit versions of decoders and validators.  Both libraries
# are used for command-line decoder and validator those detect specific
# architecture of the ELF file provided.
env.ComponentLibrary('dfa_validate_x86_32',
                     ['gen/validator_x86_32.c'])
env.ComponentLibrary('dfa_validate_x86_64',
                     ['gen/validator_x86_64.c'])
env.ComponentLibrary('dfa_decode_x86_32',
                     ['gen/decoder_x86_32.c'])
env.ComponentLibrary('dfa_decode_x86_64',
                     ['gen/decoder_x86_64.c'])

# Glue library called from service runtime. The source file depends on the
# target architecture.
caller_lib_bits = None
if env.Bit('target_x86_32'):
  caller_lib_bits = '32'
if env.Bit('target_x86_64'):
  caller_lib_bits = '64'
if caller_lib_bits:
  caller_lib = 'dfa_validate_caller_x86_%s' % caller_lib_bits
  env.ComponentLibrary(caller_lib,
                       ['unreviewed/dfa_validate_%s.c' % caller_lib_bits])

# Command-line decoder.
env.ComponentProgram(
    'decoder_test',
    ['unreviewed/decoder_test.c'],
    EXTRA_LIBS=['dfa_decode_x86_32', 'dfa_decode_x86_64'])

# Command-line validator.
validator_test_exe = env.ComponentProgram(
    'validator_test',
    ['unreviewed/validator_test.c'],
    EXTRA_LIBS=['dfa_validate_x86_32', 'dfa_validate_x86_64'])

# Python-based regression test. TODO(pasko): remove it when validator_tests are
# migrated to be able to run with the new validator.
if env.Bit('validator_ragel'):
  test_node = env.CommandTest('validator_test_py.out',
                              command=['${PYTHON}',
                                       env.File('unreviewed/validator_test.py'),
                                       validator_test_exe])
  env.AddNodeToTestSuite(test_node, ['small_tests'], 'run_validator_test_py')
