# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

from SCons.Errors import UserError

Import('env')

# Dir to place c files generated by 'dfagen' target (it's under source control).
gen_dir = '$MAIN_DIR/src/trusted/validator_ragel/gen'
# Currently we only provide ragel pre-built for Linux.
ragel_binary = '$MAIN_DIR/../third_party/ragel/ragel.linux'

INSTRUCTION_DEFINITIONS = map(env.File, [
    'unreviewed/instruction_definitions/general_purpose_instructions.def',
    'unreviewed/instruction_definitions/system_instructions.def',
    'unreviewed/instruction_definitions/x87_instructions.def',
    'unreviewed/instruction_definitions/mmx_instructions.def',
    'unreviewed/instruction_definitions/xmm_instructions.def',
    'unreviewed/instruction_definitions/nops.def'
])

# These objects are included in both dfa_validate_x86_xx and rdfa_validator
# libraries, so we have to introduce intermediate scons nodes.
validator32 = env.ComponentObject('gen/validator_x86_32.c')
validator64 = env.ComponentObject('gen/validator_x86_64.c')

features = [
    env.ComponentObject('unreviewed/validator_features_all.c'),
    env.ComponentObject('unreviewed/validator_features_validator.c')
]

# Glue library called from service runtime. The source file depends on the
# target architecture.  In library_deps.py this library is marked as
# dependant of dfa_validate_x86_xx.
if env.Bit('target_x86'):
  caller_lib = 'dfa_validate_caller_x86_%s' % env.get('TARGET_SUBARCH')
  env.ComponentLibrary(
      caller_lib,
      ['unreviewed/dfa_validate_%s.c' % env.get('TARGET_SUBARCH'),
       {'32': validator32, '64': validator64}[env.get('TARGET_SUBARCH')],
       'unreviewed/dfa_validate_common.c',
       features])

env.ComponentLibrary('dfa_decode_x86_32',
                     ['gen/decoder_x86_32.c'])
env.ComponentLibrary('dfa_decode_x86_64',
                     ['gen/decoder_x86_64.c'])

# Command-line decoder.
decoder_test = env.ComponentProgram(
    'decoder_test',
    ['unreviewed/decoder_test.c'],
    EXTRA_LIBS=['dfa_decode_x86_32', 'dfa_decode_x86_64'])

# Low-level platform-independent interface supporting both 32 and 64 bit,
# used in ncval and in validator_benchmark.
env.ComponentLibrary('rdfa_validator',
                     [validator32, validator64] + features)

validator_benchmark = env.ComponentProgram(
    'rdfa_validator_benchmark',
    ['validator_benchmark.cc'],
    EXTRA_LIBS=['rdfa_validator', 'platform', 'elf_load']
)

run_benchmark = env.AutoDepsCommand(
    'run_validator_ragel_benchmark.out',
    [validator_benchmark, env.GetIrtNexe(), '10000']
)

env.AlwaysBuild(env.Alias('dfavalidatorbenchmark', run_benchmark))

# TODO(shcherbina): Get rid of this check once
# http://code.google.com/p/nativeclient/issues/detail?id=3238 is fixed.
if not env.UsingEmulator():
  gen_dfa_test = env.CommandTest(
      'gen_dfa_test.out',
      ['${PYTHON}', env.File('gen_dfa_test.py')] + INSTRUCTION_DEFINITIONS)

  env.AddNodeToTestSuite(
      gen_dfa_test,
      ['small_tests', 'validator_tests'],
      'run_gen_dfa_test')

# Source generation:
#
#   dfagen : Regenerate any autogenerated source files.

ragel_targets = set(['dfagen', 'dfacheckdecoder'])
ragel_involved = ragel_targets.intersection(COMMAND_LINE_TARGETS)

if ragel_involved:
  if not env.Bit('host_linux'):
    raise UserError('Right now DFA generation is only supported on Linux')

  # Source generation step 1: Build generator of ragel files.
  #
  # We have generator which reads .def files and produced automaton definition.
  #
  # Ragel is included in most Linux distributions, but it's not standard tool
  # on MacOS/Windows thus we only support gneration of automata under Linux.
  # This also means that we don't need to make sure gen_dfa.cc is portable to
  # non-POSIX platforms (in particular it's not Windows compatible).

  env_gen_dfa = env.Clone()
  env_gen_dfa.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

  gen_dfa = env_gen_dfa.ComponentProgram(
      'gen_dfa',
      ['unreviewed/gen_dfa.cc'])

  # Generate byte_machines.rl from byte_machines.py
  (byte_machines,) = env.AutoDepsCommand(
      'byte_machines.rl',
      ['${PYTHON}',
       env.File('byte_machines.py'),
       '>${TARGET}'])

  # Source generation step 2: Generate decoder automata.
  #
  # Now we are back to conditionally defining the large automata generated
  # by gen_dfa.

  def MakeAutomaton(bits, automaton, dfa_gen_actions, ragel_flags):
    (rl_file,) = env.AutoDepsCommand(
        '%s_x86_%s_instruction.rl' % (automaton, bits),
        [gen_dfa,
         '-o', '${TARGET}',
         '-m', {'32': 'ia32', '64': 'amd64'}[bits],
         '-d', dfa_gen_actions
         ] + INSTRUCTION_DEFINITIONS)

    include_dir = rl_file.dir.get_abspath()
    assert include_dir == byte_machines.dir.get_abspath()

    (c_file,) = env.AutoDepsCommand(
        '%s_x86_%s.c' % (automaton, bits),
        [ragel_binary,
         ragel_flags,
         '-LL',
         '-I..',
         '-I%s' % include_dir,
         env.File('unreviewed/%s_x86_%s.rl' % (automaton, bits)),
         '-o', '${TARGET}'],
        extra_deps=[byte_machines, rl_file])

    def InjectGeneratedFileHeader(target, source, env):
      source_filename = source[0].get_abspath()
      target_filename = target[0].get_abspath()

      architecture = {'32': 'ia32', '64': 'x86-64'}[bits]

      with open(source_filename, 'r') as source_file:
        comment, sep, rest = source_file.read().partition('*/')
        if sep == '':
          raise UserError('Generated file %s does not have '
                          'header comment block' % source_filename)

      _, _, short_name = target_filename.rpartition('/native_client/')

      with open(target_filename, 'w') as target_file:
        target_file.write(
            ('/* native_client/%s\n'
             ' * THIS FILE IS AUTO-GENERATED. DO NOT EDIT.\n'
             ' * Compiled for %s mode.\n'
             ' */') % (short_name, architecture))

        target_file.write(rest)

    # inject comments and place files to appropriate dir
    return env.Command(
        target='%s/%s' % (gen_dir, c_file),
        source=c_file,
        action=InjectGeneratedFileHeader)

  decoder32 = MakeAutomaton(
      '32', 'decoder',
      'check_access,opcode,parse_operands_states',
      '-T0')
  validator32 = MakeAutomaton(
      '32', 'validator',
      ('check_access,opcode,parse_operands,parse_operands_states,'
       'instruction_name,nacl-forbidden'),
      '-G2')
  decoder64 = MakeAutomaton(
      '64', 'decoder',
      'check_access,opcode,parse_operands_states',
      '-T0')
  validator64 = MakeAutomaton(
      '64', 'validator',
      ('opcode,instruction_name,nacl-forbidden,parse_nonwrite_registers,'
       'parse_x87_operands,parse_mmx_operands,parse_xmm_operands,'
       'parse_ymm_operands,parse_relative_operands,parse_immediate_operands,'
       'parse_operands_states,parse_operand_positions'),
      '-GT2')

  automata = [decoder32, validator32, decoder64, validator64]

  # Prepair 'dfacheckdecoder' test.
  #
  # In this test, all acceptable instructions are enumerated
  # by DFA traversal, and for each one objdump output and
  # DFA-based decoder output are compared.
  # It takes few hours to run the test, so it's not included
  # into any suits and is supposed to be run manually when
  # changes are made to DFA definitions.
  # Also, since DFA generation is currently linux-only,
  # this test is somewhat platform-dependent as well.

  test_env = env.Clone()
  test_env.Append(
      CCFLAGS=['-g', '-Wno-unused-function'],
      LINKFLAGS='-g',
      CPPPATH='unreviewed')

  objdump, gas = env.Command(
      target=['objdump', 'gas'],
      source=['obtain_binutils.py'],
      action='${PYTHON} ${SOURCES[0]} ${TARGETS[0]} ${TARGETS[1]}')

  check_decoders = []

  for bits in ('32', '64'):
    (one_valid_instr_rl,) = env.AutoDepsCommand(
        'one_valid_instruction_x86_%s.rl' % bits,
        [gen_dfa, '-o', '${TARGET}'] + INSTRUCTION_DEFINITIONS +
        ['-d', 'check_access,vex_prefix,opcode,parse_operands_states',
         '-d', 'parse_operands,instruction_name',
         '-m', {'32': 'ia32', '64': 'amd64'}[bits]])

    include_dir = one_valid_instr_rl.dir.get_abspath()

    (one_instr_xml,) = env.AutoDepsCommand(
        'one_instruction_x86_%s.xml' % bits,
        [ragel_binary,
         '-x',
         '-I%s' % include_dir,
         '-I..',
         env.File('unreviewed/one_instruction_x86_%s.rl' % bits),
         '-o', '${TARGET}'],
        extra_deps=[
            one_valid_instr_rl,
            'unreviewed/parse_instruction.rl',
            byte_machines])

    check_decoder = env.AutoDepsCommand(
        'check_decoder_test_results_%s' % bits,
        ['${PYTHON}',
         env.File('check_decoder.py'),
         one_instr_xml,
         '--gas', gas,
         '--objdump', objdump,
         '--decoder', decoder_test,
         '--bits', bits])

    check_decoders.append(check_decoder)

  # Never run decoder tests in parallel because they can take all CPU.
  SideEffect('check_decoder', check_decoders)

  env.AlwaysBuild(env.Alias('dfagen', automata))
  env.AlwaysBuild(env.Alias('dfacheckdecoder', check_decoders))
