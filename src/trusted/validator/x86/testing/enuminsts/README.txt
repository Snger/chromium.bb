Copyright (c) 2012 The Native Client Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that be
found in the LICENSE file.

Exhaustive instruction enumeration test for x86 Native Client decoder.

This test performs an exhaustive enumeration of x86 instructions,
comparing the NaCl decoder to the xed decoder from Intel. It currently
compares:

   * instruction validity (still being worked on in x86-32).
   * instruction length
   * opcodes (64-bit only).

This projectd is currently built using make, as defined by Makefile.
It builds a 64-bit decoder checker by default.  To build a 32-bit
decoder checker it should be enough to provide BITS=32 command line
parameter when building with make.  You also need to build the correct
version of NaCl libraries. By default, it assumes that you have
downloaded a (Pin) version of xed. See variable PINV in Makefile to
see the version assumed.  You can specify the xed on the command line,
allowing use other versions of xed.

Constructing the enumerator
---------------------------

The standard build of the enumeration executable is to run the command
line:

   .> make BITS=XX

where XX in {32, 64}. This makefile creates the executable
"enuminsts-XX".

Running enuminsts-XX
--------------------

To see valid argument for enuminsts-XX, run:

   .> ./enuminsts-XX --help

This will list the command line arguments you may specify, as well as
the set of instruction decoders built into the executable.

Testing the numerator against the baseline
------------------------------------------

Included in this directory is (one or more) frozen versions of the
enumerator, named "enuminsts-XX-NNNNN" where XX in {32, 64}, and NNNNN
is the nacl revision number used to generate the executable.

The (shell) file "enuminsts-64-baseline" is a canned script that pipes
a run of "enuminsts-XX-NNNNN" into "enuminsts-64", using the input
decoder on the output generated by "enuminsts-XX-NNNNN". The command
line arguments to "enuminsts-64-baseline" are passed to the latter
executable "enuminsts-64".

To see possible (valid) arguments, run:

   .> ./enuminsts-64-baseline --help

The purpose of this run is that the baseline has been defined so that
it generates a large, valid set of x86-64 instructions, and then
(though enuminsts-64) allows you to run these instructions on any of
the valid decoders.

To run a decoder DDD on the set of (legal) baseline instructions, run:

  .> ./enuminsts-64-baseline --DDD

Note: you can add additional command line arguments. To see them, add
the "--Help" option to the command line.

Building enuminsts with a xed decoder
-------------------------------------

Before building enuminsts with a xed decoder, you must download
Intel's xed decoder, distributed as part of PIN. It is available for
free from

   http://www.pintool.org.

The default for the Makefile is PIN version 2.10-45467. However, any
version can be used if you specify "PINV=VVVVVVVVVVV" (where
VVVVVVVVVV is the PIN version you downloaded). To build enuminsts
with xed, run

   .> make BITS=XX PINV=VVVVVVVVVVV XED=1

where BITS in {32, 64} and VVVVVVVVVV is the PIN version you
downloaded. This will build the executable enuminsts-XX-xed.

Building a new baseline
-----------------------

To build a new baseline, you need to build a frozen executable
of the form enuminsts-XX-NNNNN by running the command:

   .> make BITS=64 NACLV=NNNNN

where NNNNN is the revision number of the corresponding generated NaCl
(scons) libraries. This will build executable
"enuminsts-64-NNNNN". You also need to build a copy of enuminsts with
a xed decoder (see "Building enuminsts with a xed decoder").

Once both executables have been built, edit shell file
enuminsts-64-legal to define the command line arguments you believe
will generate legal instructions, and pipe the corresponding opcode
sequences to the output (i.e. use options --opcode_bytes or
--opcode_bytes_plus_dec).

To test that you have generated the correct command line arguments,
then run:

   .> ./enuminsts-64-baseline-test

This shell file will perform two runs of enuminsts-64-legal. The first
will compare the set of generated instructions against the xed decoder
to find instructions that are legal in both. The second will then
compare the set of generated instructions against the xed decoder to
find instructions that are not understood by xed.  If you have your
arguments right, no error messages will be reported in either step.

If enuminsts-64-baseline-test doesn't generate any errors, you have
found an acceptable new baseline, and you can install it. If you get
errors, but are only generated in the first pass, you can still use
enuminsts-64-baseline for the baseline. However, any instruction for
which an error is reported in the first pass, will not be generated by
the baseline.

If you get errors in the second pass (which tests if the generated
instructions are invalid according to xed), you need to change your
parameters in enuminsts-64-legal.  These errors represent bad
instruction opcodes that will be generated by the baseline.

