# -*- python -*-
# Copyright 2010 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can
# be found in the LICENSE file.


Import('env')

# So far, all tests involve native assembler

HALT_SLED_SIZE=32

# Valgrind gets confused by these tests

if env.IsRunningUnderValgrind():
  Return()

# glibc linker script enforces gap; test needs to be updated to use
# custom linker script in this case.
if env.Bit('nacl_glibc'):
  Return()

# The PNaCl translators are not supposed to handle the special linkage
if env.Bit('use_sandboxed_translator'):
  Return()

# pic might introduce extra sections that we do not want
if env.Bit('nacl_pic'):
  Return()

# ----------------------------------------------------------
# Tests that require a NaCl module
# ----------------------------------------------------------
ALLOCATION_SIZE   = 0x10000
START_OF_TEXT     = 0x20000
TEXT_SIZE_BOUND   = 0x10000  # estimate of test code size
RODATA_SIZE_BOUND = 0x10000
RWDATA_SIZE       = 0x4  # if we have rwdata, we must use exactly one word!


def EndOfText(text_end_modulus):
  return START_OF_TEXT + text_end_modulus


def RoundUpToAllocSize(size):
  return (size + ALLOCATION_SIZE - 1) & ~(ALLOCATION_SIZE - 1)


def TextGap(text_end):
  end_of_text = EndOfText(text_end)
  rounded_end_of_text = RoundUpToAllocSize(end_of_text)
  text_gap = rounded_end_of_text - end_of_text
  return text_gap


def NaturalRodataStart(text_end):
  extra = 0
  text_gap = TextGap(text_end)
  if text_gap < HALT_SLED_SIZE:
    extra = ALLOCATION_SIZE
  return RoundUpToAllocSize(START_OF_TEXT + TEXT_SIZE_BOUND + extra)


def ExpectedBreak(text_end, rodata_addr, rwdata_addr, rwdata_size):
  if rwdata_addr is None:
    if rodata_addr is None:
      break_addr = NaturalRodataStart(text_end)
    else:
      break_addr = RoundUpToAllocSize(rodata_addr + RODATA_SIZE_BOUND)
  else:
    break_addr = rwdata_addr + rwdata_size
  return break_addr


def MakeSectionStartFlags(env, sec_name, sec_start):
    return ['-Wl,--section-start', '-Wl,%s=0x%x' % (sec_name, sec_start)]


def MakeEnv(env, code_pos, code_size, ro_pos, ro_size, rw_pos, rw_size):
  barebones_env = env.Clone()

  # NOTE: we are really trying to align segments but in this case
  #       sections and segments coincidence
  linker_flags = ['-nostdlib']
  if env.Bit('bitcode'):
    linker_flags += ['-Wl,-nobitcode-intrinsics']
  linker_flags += MakeSectionStartFlags(env, ".text", code_pos)
  if ro_pos:
    linker_flags += MakeSectionStartFlags(env, ".rodata", ro_pos)
  barebones_env.Replace(LIBS=[],
                        EXTRA_LIBS=[],
                        LINKFLAGS=linker_flags)

  # make gcc tolerate some gnu'ism such as array initialization tricks
  barebones_env.FilterOut(CFLAGS=['-pedantic'])
  barebones_env.FilterOut(CCFLAGS=['-pedantic'])

  if env.Bit('target_arm'):
    nop_word = 0xe1a00000
  else:
    nop_word =  0x90909090

  defines = [
      ('NOP_WORD', "0x%x" % nop_word),
      ('TEXT_SEGMENT_SIZE', "0x%x" % code_size),
      ('RODATA_SEGMENT_SIZE', "0x%x" % ro_size),
      ('RWDATA_SEGMENT_SIZE', "0x%x" % rw_size),
      ('EXPECTED_BREAK',
       "0x%x" % ExpectedBreak(code_pos + code_size, ro_pos, rw_pos, rw_size)),
      ]
  barebones_env.Append(CPPDEFINES=defines)
  return barebones_env


test_specs = [ (0x10000,       'no'),
               (0x10000 - 32, 'small'),
               ( 0x8000,      'large'),
               (0x10000 - 28, 'too_small') ]

def CreateSegmentPosAndSizeCheckingCommands(out,
                                            code_pos,
                                            code_size,
                                            ro_pos,
                                            ro_size,
                                            rw_pos,
                                            rw_size):
  '''
  The string magic below crafts command lines using tools/elf_checker.py
  for checking various program header properties of nexes
  d=0x70000000 is a big enough number so that addr % d == addr
  for all addresses we expect to encounter

  To see the actual segments including the "-f" value, run:
  readelf  -l <nexe>
  '''
  # note: LARGE_NUM was picked so that pos mod LARGE_NUM = pos
  #       for all pos we expect to deal with
  large_num = 0x70000000
  cmd_prefix = ('${PYTHON} ${SCONSTRUCT_DIR}/tools/elf_checker.py '
                '-s load -d 0x%x ' % large_num)
  cmd_suffix = ' ${SOURCES} >> %s' % out

  command_templates = [
      (cmd_prefix + '-a vaddr -f 5 -r 0x%x' + cmd_suffix, code_pos),
      (cmd_prefix + '-a memsz -f 5 -r 0x%x' + cmd_suffix, code_size),
      (cmd_prefix + '-a vaddr -f 4 -r 0x%x' + cmd_suffix, ro_pos),
      (cmd_prefix + '-a memsz -f 4 -r 0x%x' + cmd_suffix, ro_size),
      (cmd_prefix + '-a vaddr -f 6 -r 0x%x' + cmd_suffix, rw_pos),
      (cmd_prefix + '-a memsz -f 6 -r 0x%x' + cmd_suffix, rw_size),
      ]

  commands = []
  commands.append('echo "start pos/size checking" > %s' % out)
  for template, val in command_templates:
    if val is not None:
      commands.append(template % val)
  return commands

for text_end, variant in test_specs:
  for rodata_addr, rodata_size, name_modifier in [(None, 0, ''),
                                                  (0, 12, '_ro'),
                                                  (0x100000, 12, '_ro_dyn') ]:
    # rodata_address is None when no .rodata section should appear
    # in the generated nexe, and is 0 when it should appear in the
    # natural location (as defined by the linker script); when it
    # has a non-zero numeric value, then the .rodata section is
    # forced to start at that address.
    if rodata_addr == 0:
      rodata_addr = NaturalRodataStart(text_end)
    # rodata_address is None or a non-zero integer

    barebones_env = MakeEnv(env,
                            START_OF_TEXT, text_end,
                            rodata_addr, rodata_size,
                            None, 0);

    base_name = 'nacl_text_' + variant + '_pad' + name_modifier + '_test'
    main = barebones_env.ComponentObject(base_name + '_main.o',
                                         'segment_test_main.c')
    # NOTE: this hack strips out the .eh_section which for some reason is
    #       always generated by nacl-gcc64
    # http://code.google.com/p/nativeclient/issues/detail?id=1844
    if not barebones_env.Bit('bitcode'):
      rm_eh_sec = "${OBJCOPY} -R .eh_frame ${SOURCES} ${TARGET}"
      main = barebones_env.Command(base_name + '_main_hack.o',
                                   main,
                                   rm_eh_sec)

    rest = barebones_env.ComponentObject(base_name + '_rest.o',
                                         'segment_test_rest.c')
    nexe = barebones_env.ComponentProgram(base_name + '.nexe', [main, rest])

    node = env.CommandSelLdrTestNacl(base_name + '.out',
                                     command=[env.File(base_name + '.nexe')],
                                     exit_status='55')
    env.AddNodeToTestSuite(node,
                           ['small_tests', 'sel_ldr_sled_tests'],
                           'run_' + base_name)

    # Do not run the checks in the prebuilt case because they might
    # trigger a rebuild of the images without have a TC available
    if env.Bit('built_elsewhere') or env.Bit('prebuilt'):
      continue

    # NOTE: The linker no longer seems to allow us to generate the too_small
    #       gap of size 28, so these tests are a litte less useful
    #       than they used to be when we could test that the sel_ldr
    #       actually rejects images with a too_small gap.
    #   http://code.google.com/p/nativeclient/issues/detail?id=1839

    # Work around some automatic alignment in the nacl-gcc TC
    if text_end == 0x10000 - 28:
      if not env.Bit('bitcode'):
        text_end = 0x10000
    commands = CreateSegmentPosAndSizeCheckingCommands(base_name,
                                                       START_OF_TEXT,
                                                       text_end,
                                                       rodata_addr,
                                                       rodata_size,
                                                       None,
                                                       None)

    # Run the checks as part of the tes suite sel_ldr_sled_tests
    node = env.Command(base_name + '_info', nexe, commands)
    env.AddNodeToTestSuite(node, ['small_tests', 'sel_ldr_sled_tests'])
