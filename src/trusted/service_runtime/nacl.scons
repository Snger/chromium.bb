# -*- python -*-
# Copyright 2010 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can
# be found in the LICENSE file.


Import('env')

# So far, all tests involve native assembler

HALT_SLED_SIZE=32

# Valgrind gets confused by these tests

if env.IsRunningUnderValgrind():
  Return()

# glibc linker script enforces gap; test needs to be updated to use
# custom linker script in this case.
if env.Bit('nacl_glibc'):
  Return()

# The PNaCl translators are not supposed to handle incoming native code
if env.Bit('use_sandboxed_translator'):
  Return()

# ----------------------------------------------------------
# Tests that require a NaCl module
# ----------------------------------------------------------

if env.Bit('target_x86_32'):
  nacl_text_pad_asm = 'arch/x86_32/nacl_text_pad_test.S'
elif env.Bit('target_x86_64'):
  nacl_text_pad_asm = 'arch/x86_64/nacl_text_pad_test.S'
elif env.Bit('target_arm'):
  nacl_text_pad_asm = 'arch/arm/nacl_text_pad_test.S'
else:
  raise Exception('unknown architecture')

def NewAsmEnv(env, defines, rodata_address, rwdata_address):

  asm_env = env.Clone()
  # NOTE(robertm): convert this to pure C code so that most of this
  # special handling can be eliminated
  if asm_env.Bit('bitcode'):
    asm_env.Replace(OBJSUFFIX='.o')
    asm_env.Append(ASFLAGS=['-arch', '${TARGET_FULLARCH}'])
    # NOTE: MC_ASM has issues with skip directive
    asm_env.Append(ASFLAGS='--pnacl-driver-set-USE_MC_ASM=0')
  link_cmd = ('${LD} -e _start ${TEXT_START} ${RO_START} ${RW_START}' +
                ' -o ${TARGET} ${SOURCES}')

  if env.Bit('target_x86_32'):
    link_cmd += ' -melf_nacl'
  elif env.Bit('target_x86_64'):
    link_cmd += ' -melf64_nacl'
  elif env.Bit('target_arm'):
    link_cmd += ' -marmelf_nacl'
  else:
    raise Exception('unknown architecture')

  asm_env['LINKCOM'] = link_cmd

  asm_env.Append(CPPDEFINES = [
                     ['NACL_BLOCK_SHIFT', 5],
                     ['NACL_BLOCK_SIZE', 32],
                     ['NACL_BUILD_ARCH', '${BUILD_ARCHITECTURE}' ],
                     ['NACL_BUILD_SUBARCH', '${BUILD_SUBARCH}' ],
                     ['NACL_TARGET_ARCH', '${TARGET_ARCHITECTURE}' ],
                     ['NACL_TARGET_SUBARCH', '${TARGET_SUBARCH}' ],
                 ])

  asm_env.Append(CPPDEFINES=defines)

  asm_env['TEXT_START'] = '--section-start .text=0x%x' % 0x20000
  if rodata_address:
    asm_env['RO_START'] = '--section-start .rodata=0x%x' % rodata_address
  if rwdata_address:
    asm_env['RW_START'] = '--section-start .data=0x%x' % rwdata_address

  return asm_env


ALLOCATION_SIZE   = 0x10000
START_OF_TEXT     = 0x20000
TEXT_SIZE_BOUND   = 0x10000  # estimate of test code size
RODATA_SIZE_BOUND = 0x10000
RWDATA_SIZE       = 0x4  # if we have rwdata, we must use exactly one word!


def EndOfText(text_end_modulus):
  return START_OF_TEXT + text_end_modulus


def RoundUpToAllocSize(size):
  return (size + ALLOCATION_SIZE - 1) & ~(ALLOCATION_SIZE - 1)


def TextGap(text_end):
  end_of_text = EndOfText(text_end)
  rounded_end_of_text = RoundUpToAllocSize(end_of_text)
  text_gap = rounded_end_of_text - end_of_text
  return text_gap


def NaturalRodataStart(text_end):
  extra = 0
  text_gap = TextGap(text_end)
  if text_gap < HALT_SLED_SIZE:
    extra = ALLOCATION_SIZE
  return RoundUpToAllocSize(START_OF_TEXT + TEXT_SIZE_BOUND + extra)


def ExpectedBreak(text_end, rodata_addr, rwdata_addr, rwdata_size):
  if rwdata_addr is None:
    if rodata_addr is None:
      break_addr = NaturalRodataStart(text_end)
    else:
      break_addr = RoundUpToAllocSize(rodata_addr + RODATA_SIZE_BOUND)
  else:
    break_addr = rwdata_addr + rwdata_size
  return break_addr

test_specs = [ (0x10000,       'no'),
               (0x10000 - 32, 'small'),
               ( 0x8000,      'large'),
               (0x10000 - 28, 'too_small') ]

rwdata_addr = None  # none for now


def CreateSegmentPosAndSizeCheckingCommands(out,
                                            code_pos=None,
                                            code_size=None,
                                            ro_pos=None,
                                            ro_size=None,
                                            rw_pos=None):
  '''
  The string magic below crafts command lines using tools/elf_checker.py
  for checking various program header properties of nexes
  d=0x70000000 is a big enough number so that addr % d == addr
  for all addresses we expect to encounter

  To see the actual segments including the "-f" value, run:
  readelf  -l <nexe>
  '''
  # note: LARGE_NUM was picked so that pos mod LARGE_NUM = pos
  #       for all pos we expect to deal with
  large_num = 0x70000000
  cmd_prefix = ('${PYTHON} ${SCONSTRUCT_DIR}/tools/elf_checker.py '
                '-s load -d 0x%x ' % large_num)

  cmd_suffix = ' ${SOURCES} >> %s' % out

  cmd_code_pos = cmd_prefix + '-a vaddr -f 5 -r 0x%x' + cmd_suffix
  cmd_code_size= cmd_prefix + '-a memsz -f 5 -r 0x%x' + cmd_suffix
  cmd_ro_pos = cmd_prefix + '-a vaddr -f 4 -r 0x%x' + cmd_suffix
  cmd_ro_size = cmd_prefix + '-a memsz -f 4 -r 0x%x' + cmd_suffix
  cmd_rw_pos = cmd_prefix + '-a vaddr -f 6 -r 0x%x' + cmd_suffix

  commands = []
  commands.append('echo "start pos/size checking" > %s' % out)
  if code_pos is not None: commands.append(cmd_code_pos % code_pos)
  if code_size is not None: commands.append(cmd_code_size % code_size)
  if ro_pos is not None: commands.append(cmd_ro_pos % ro_pos)
  if ro_size is not None: commands.append(cmd_ro_size % ro_size)
  if rw_pos is not None: commands.append(cmd_rw_pos % rw_pos)
  return commands



for text_end, variant in test_specs:
  for rodata_addr, rodata_size, name_modifier in [(None, 0, ''),
                                                  (0, 12, '_ro'),
                                                  (0x100000, 12, '_ro_dyn') ]:
    # rodata_address is None when no .rodata section should appear
    # in the generated nexe, and is 0 when it should appear in the
    # natural location (as defined by the linker script); when it
    # has a non-zero numeric value, then the .rodata section is
    # forced to start at that address.
    if rodata_addr == 0:
      rodata_addr = NaturalRodataStart(text_end)
    # rodata_address is None or a non-zero integer

    break_addr = ExpectedBreak(text_end,
                               rodata_addr,
                               rwdata_addr,
                               RWDATA_SIZE)

    defines=[]
    for (symbol, value) in [('TEXT_EXTEND', text_end),
                            ('EXPECTED_BREAK', break_addr),
                            ('EXPECTED_RODATA', rodata_addr),
                            ('EXPECTED_RWDATA', rwdata_addr)]:
      if value is not None:
        defines += [[symbol, str(value)]]

    asm_env = NewAsmEnv(env, defines, rodata_addr, rwdata_addr)

    base_name = 'nacl_text_' + variant + '_pad' + name_modifier + '_test'
    obj = asm_env.ComponentObject(base_name + '.o', nacl_text_pad_asm)

    nexe = asm_env.ComponentProgram(base_name + '.nexe', [obj])

    node = env.CommandSelLdrTestNacl(base_name + '.out',
                                     command=[nexe])
    env.AddNodeToTestSuite(node,
                           ['small_tests', 'sel_ldr_sled_tests'],
                           'run_' + base_name)

    # NOTE: The linker no longer seems to allow us to generate the too_small
    #       gap of size 28, so these tests are a litte less useful
    #       than they used to be when we could test that the sel_ldr
    #       actually rejects images with a too_small gap.
    if text_end == 0x10000 - 28:
      if asm_env.Bit('target_arm'):
        text_end = 0xfff0
      else:
        text_end = 0x10000
    commands = CreateSegmentPosAndSizeCheckingCommands(base_name,
                                                       START_OF_TEXT,
                                                       text_end,
                                                       rodata_addr,
                                                       rodata_size,
                                                       None)

    # Run the checks as part of the tes suite sel_ldr_sled_tests
    node = env.Command(base_name + '_info', nexe, commands)
    env.AddNodeToTestSuite(node, ['small_tests', 'sel_ldr_sled_tests'])
