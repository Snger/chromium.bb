# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import platform
import os

Import('env')

# TODO(robertm): consider adding this to the top level scons files
env.Append(CPPPATH=['${TARGET_ROOT}'])
# this is needed for including gen/... files, see GENERATED below

# this is needed for including gdb_utils files
env.Append(CPPPATH=['${SOURCE_ROOT}/gdb_utils/src'])

DEBUG_LIBS = ['debug_stub_init', 'gdb_rsp', 'debug_stub']
if env.Bit('windows'):
  env.Append(CPPDEFINES=['WIN32'])
  if env.Bit('target_x86_64'):
    env.Append(CPPDEFINES=['WIN64'])

# normally comment out -- uncomment out to test the pedantic removal
# check below.
#if env.Bit('linux') or env.Bit('mac'):
#  env.FilterOut(CCFLAGS=['-pedantic'])
#  env.FilterOut(CCFLAGS=['-Wall'])

# Make a copy of debug CRT for now.
# TODO(bradnelson): there should be a better way to generalize this requirement.
crt = []
if env.AllBits('windows', 'debug'):
  for i in ['.', '${STAGING_DIR}']:
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/Debug_NonRedist/'
                         'x86/Microsoft.VC80.DebugCRT')
    crt += env.Replicate(i, '$VC80_DIR/vc/redist/x86/Microsoft.VC80.CRT')

if env.Bit('windows'):
  syscall_impl = 'win/nacl_syscall_impl.c'
else:
  syscall_impl = 'linux/nacl_syscall_impl.c'


# TODO GENERATED CODE
GENERATED='${TARGET_ROOT}/gen/native_client/src/trusted/service_runtime'
env.Command(target=env.File(GENERATED + '/nacl_syscall_handlers.c'),
            source=[syscall_impl, 'nacl_syscall_handlers_gen2.py'],
            action=[Action('${PYTHON} ${SOURCES[1]} ${SYSCALL_GEN_FLAGS}'
                           ' -i ${SOURCE} -o ${TARGET}'),
                    ],
            )


# ----------------------------------------------------------
# TODO(robertm): this library is too big and needs to be split up
#                for easier unit testing
ldr_inputs = [
    'dyn_array.c',
    'elf_util.c',
    'nacl_all_modules.c',
    'nacl_app_thread.c',
    'nacl_closure.c',
    'nacl_desc_effector_ldr.c',
    'nacl_globals.c',
    'nacl_kern_services.c',
    'nacl_memory_object.c',
    'nacl_signal_common.c',
    'nacl_stack_safety.c',
    'nacl_sync_queue.c',
    'nacl_syscall_common.c',
    GENERATED + '/nacl_syscall_handlers.c',
    'nacl_syscall_hook.c',
    'nacl_text.c',
    'nacl_valgrind_hooks.c',
    'name_service/default_name_service.c',
    'name_service/name_service.c',
    'sel_addrspace.c',
    'sel_ldr.c',
    'sel_ldr-inl.c',
    'sel_ldr_standard.c',
    'sel_ldr_thread_interface.c',
    # sel_main_chrome.c is compile-tested here but not otherwise used
    # in the Scons build.
    'sel_main_chrome.c',
    'sel_mem.c',
    'sel_qualify.c',
    'sel_util-inl.c',
    'sel_validate_image.c',
]

if env.Bit('build_x86_32'):
  ldr_inputs += [
      'arch/x86/nacl_ldt_x86.c',
      'arch/x86_32/nacl_app_32.c',
      'arch/x86_32/nacl_switch_32.S',
      'arch/x86_32/nacl_switch_to_app_32.c',
      'arch/x86_32/nacl_syscall_32.S',
      'arch/x86_32/nacl_tls_32.c',
      'arch/x86_32/sel_addrspace_x86_32.c',
      'arch/x86_32/sel_ldr_x86_32.c',
      'arch/x86_32/sel_rt_32.c',
      'arch/x86_32/springboard.S',
      'arch/x86_32/tramp_32.S',
      ]
elif env.Bit('build_x86_64'):
  ldr_inputs += [
      'arch/x86/nacl_ldt_x86.c',
      'arch/x86_64/nacl_app_64.c',
      'arch/x86_64/nacl_switch_64.S',
      'arch/x86_64/nacl_switch_to_app_64.c',
      'arch/x86_64/nacl_syscall_64.S',
      'arch/x86_64/nacl_tls_64.c',
      'arch/x86_64/sel_addrspace_x86_64.c',
      'arch/x86_64/sel_ldr_x86_64.c',
      'arch/x86_64/sel_rt_64.c',
      'arch/x86_64/tramp_64.S',
      ]
  if env.Bit('windows'):
    ldr_inputs += ['arch/x86_64/sel_addrspace_win_x86_64.c']
  else:
    ldr_inputs += ['arch/x86_64/sel_addrspace_posix_x86_64.c']
elif env.Bit('build_arm'):
  ldr_inputs += [
    'arch/arm/nacl_app.c',
    'arch/arm/nacl_switch_to_app_arm.c',
    'arch/arm/sel_rt.c',
    'arch/arm/nacl_tls.c',
    'arch/arm/sel_ldr_arm.c',
    'arch/arm/sel_addrspace_arm.c',
    'arch/arm/nacl_switch.S',
    'arch/arm/nacl_syscall.S',
    'arch/arm/springboard.S',
    'arch/arm/tramp_arm.S',
  ]

if env.Bit('windows'):
  ldr_inputs += [
    'win/nacl_ldt.c',
    'win/nacl_oop_debugger_hooks.c',
    'win/nacl_thread_nice.c',
    'win/sel_memory.c',
    'win/sel_segments.c',
  ]
elif env.Bit('mac'):
  ldr_inputs += [
    'osx/nacl_ldt.c',
    'osx/nacl_oop_debugger_hooks.c',
    'osx/nacl_thread_nice.c',
    'linux/sel_memory.c',
    'linux/x86/sel_segments.c',
    'osx/outer_sandbox.c',
  ]
elif env.Bit('linux'):
  ldr_inputs += [
    'linux/sel_memory.c',
    'linux/nacl_oop_debugger_hooks.c',
    'linux/nacl_thread_nice.c',
  ]
  if env.Bit('build_x86'):
    ldr_inputs += [
      'linux/x86/nacl_ldt.c',
      'linux/x86/sel_segments.c',
    ]
  elif env.Bit('build_arm'):
    ldr_inputs += [
      'linux/arm/sel_segments.c',
    ]


# -------------------------------------------------------------
# Add OS and architecture specific signal handling files.
#
if env.Bit('windows'):
  ldr_inputs += ['win/nacl_signal.c']
  if env.Bit('target_x86_32'):
    ldr_inputs += ['win/nacl_signal_32.c']
  elif env.Bit('target_x86_64'):
    ldr_inputs += [
      'win/exception_dispatcher_exit_fast.S',
      'win/nacl_signal_64.c',
      'win/patch_exception_dispatcher.c',
    ]
  else:
    raise Exception("Unsupported target")

if env.Bit('linux'):
  ldr_inputs += ['posix/nacl_signal.c']
  if env.Bit('target_arm'):
    ldr_inputs += ['linux/nacl_signal_arm.c']
  elif env.Bit('target_x86_32'):
    ldr_inputs += ['linux/nacl_signal_32.c']
  elif env.Bit('target_x86_64'):
    ldr_inputs += ['linux/nacl_signal_64.c']
  else:
    raise Exception("Unsupported target")

if env.Bit('mac'):
  ldr_inputs += ['posix/nacl_signal.c']
  if env.Bit('target_x86_32'):
    ldr_inputs += ['osx/nacl_signal_32.c']
  elif env.Bit('target_x86_64'):
    ldr_inputs += ['osx/nacl_signal_64.c']
  else:
    raise Exception("Unsupported target")


syscall_gen_flags = '-c -a ${TARGET_ARCHITECTURE} -s ${TARGET_SUBARCH}'

env.Append(SYSCALL_GEN_FLAGS=syscall_gen_flags)

env.DualLibrary('sel', ldr_inputs)

env.DualLibrary('env_cleanser', ['env_cleanser.c'])

env.DualLibrary('nacl_error_code',
                ['nacl_error_code.c',
                 ])

env.ComponentLibrary('container',
                     ['generic_container/container.c',
                      ])


env.ComponentLibrary('nacl_xdr',
                     ['fs/xdr.c',
                      'fs/obj_proxy.c',
                      ])

# NOTE(robertm): these extra libs were orignially only added to the
#                sel_ldr binary
# TODO(robertm): see who really needs them and remove
if env.Bit('windows'):
  env.Append(
      LIBS = [
          'ws2_32',
          'kernel32',
          'advapi32',
          'winmm',
# TODO(gregoryd): ntdll.lib is required for sem_get_value implementation but
# it is available in Windows DDK only. The DDK is not
# in third_party, but we might need to add it if we want to use it.
#          'ntdll',
      ],
  )

if env.Bit('target_x86'):
  VALIDATOR_LIB = env.NaClTargetArchSuffix('ncvalidate')
elif env.Bit('target_arm'):
  VALIDATOR_LIB = 'ncvalidate_arm_v2'
else:
  # Unknown architecture
  raise AssertionError('Unknown architecture')

if ((not env.Bit('coverage_enabled') or not env.Bit('windows')) and
    not env.CrossToolsBuild()):


  # TODO(ncbray) why do we need to link against Cocoa?
  # run_fake_browser_ppapi_test fails on mac, otherwise.
  # http://code.google.com/p/nativeclient/issues/detail?id=1242
  sel_ldr_env = env.Clone()
  if env.Bit('mac'):
    sel_ldr_env.Append(FRAMEWORKS=['Cocoa'])

  SEL_LDR_NODE = sel_ldr_env.ComponentProgram(
      'sel_ldr',
      'sel_main.c',
      EXTRA_LIBS=['sel',
                  'env_cleanser',
                  'nacl_error_code',
                  'manifest_proxy',
                  'simple_service',
                  'thread_interface',
                  'gio_wrapped_desc',
                  'nonnacl_srpc',
                  'nrd_xfer',
                  'nacl_perf_counter',
                  'nacl_base',
                  'imc',
                  'container',
                  'platform',
                  'platform_qual_lib',
                  VALIDATOR_LIB,
                  ] + DEBUG_LIBS)

  # NOTE: we do not have segments on ARM
  if env.Bit('build_x86'):
    env.ComponentProgram('nacl_ldt_unittest',
                         'nacl_ldt_unittest.c',
                         EXTRA_LIBS=['sel',
                                     'env_cleanser',
                                     'nacl_perf_counter',
                                     'gio_wrapped_desc',
                                     'platform',
                                     ])
  env.Requires(SEL_LDR_NODE, crt)

  env.SDKInstallTrusted('sel_ldr', SEL_LDR_NODE)

env.EnsureRequiredBuildWarnings()

# ----------------------------------------------------------
# Unit Tests
# ----------------------------------------------------------

# NOTE: uses validator
# TODO(robertm): break this test up in smaller pieces with more managable
#                dependencies
gtest_env = env.Clone()

# This is necessary for unittest_main.c which includes gtest/gtest.h
# The problem is that gtest.h includes other files expecting the
# include path to be set.  We do *not*, however, strip out the
# -pedantic compiler flag for building non-gtest-using source files.
gtest_env.Prepend(CPPPATH=['${SOURCE_ROOT}/testing/gtest/include'])

if gtest_env.Bit('linux') or gtest_env.Bit('mac'):
  # because of: gtest-typed-test.h:236:46: error:
  # anonymous variadic macros were introduced in C99
  gtest_env.FilterOut(CCFLAGS=['-pedantic'])

unittest_inputs = [
    'unittest_main.cc',
    'sel_memory_unittest.cc',
    # nacl_sync_unittest.cc was testing the wrong (i.e., too low level) API
    # re-enable it when it has been converted to the C API.
    #'nacl_sync_unittest.cc',
    'sel_mem_test.cc',
    'sel_ldr_test.cc',
]

if (not env.CrossToolsBuild() and
    (not env.Bit('coverage_enabled') or not env.Bit('windows'))):
  unit_tests_exe = gtest_env.ComponentProgram(
      'service_runtime_tests',
      unittest_inputs,
      EXTRA_LIBS=['gtest',
                  'sel',
                  'env_cleanser',
                  'manifest_proxy',
                  'simple_service',
                  'thread_interface',
                  'gio_wrapped_desc',
                  'nonnacl_srpc',
                  'nrd_xfer',
                  'nacl_perf_counter',
                  'nacl_base',
                  'imc',
                  'platform',
                  VALIDATOR_LIB,
                  ] + DEBUG_LIBS)
  gtest_env.Requires(unit_tests_exe, crt)

  node = gtest_env.CommandTest(
      'gtest_output.xml.out',
      command=[unit_tests_exe, '--gtest_output=xml:${TARGET}'])
  gtest_env.AddNodeToTestSuite(node, ['small_tests'],
      'run_service_runtime_tests')


if not env.Bit('coverage_enabled') or not env.Bit('windows'):
  format_string_test_exe = env.ComponentProgram(
      'format_string_test',
      ['format_string_test.c'],
      EXTRA_LIBS=['sel',
                  'env_cleanser',
                  'nacl_perf_counter'])
  env.Requires(format_string_test_exe, crt)

  node = env.CommandTest(
      'format_string_test.out',
      command=[format_string_test_exe])
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_format_string_test')


if env.Bit('target_x86_32'):
  arch_testdata_dir = 'testdata/x86_32'
elif env.Bit('target_x86_64'):
  arch_testdata_dir = 'testdata/x86_64'
else:
  arch_testdata_dir = 'testdata/' + env['TARGET_ARCHITECTURE']


# Doesn't work on windows under coverage.
# TODO(bradnelson): fix this to work on windows under coverage.
if ((not env.Bit('windows') or not env.Bit('coverage_enabled')) and
    not env.CrossToolsBuild()):
  # NOTE: uses validator
  mmap_test_exe = env.ComponentProgram(
      'mmap_test',
      ['mmap_test.c'],
      EXTRA_LIBS=['sel',
                  'env_cleanser',
                  'manifest_proxy',
                  'simple_service',
                  'thread_interface',
                  'gio_wrapped_desc',
                  'nonnacl_srpc',
                  'nrd_xfer',
                  'nacl_perf_counter',
                  'nacl_base',
                  'imc',
                  'platform',
                  VALIDATOR_LIB,
                  ] + DEBUG_LIBS)
  env.Requires(mmap_test_exe, crt)

  # TODO(robertm): This test emits lots of messages to stderr
  node = env.CommandTest (
      "mmap_test.out",
      command=[mmap_test_exe,
               env.File(arch_testdata_dir + '/hello_world.nexe')],
      # TODO(mseaborn): Extend this test to cover the case where the
      # dynamic code segment is present.
      osenv='NACL_DISABLE_DYNAMIC_LOADING=1')
  # This test fails for arm on 32-bit machines running qemu.
  # So don't run it there.
  env.AddNodeToTestSuite(node, ['medium_tests'], 'run_trusted_mmap_test',
                         is_broken=env.Bit('build_arm') and env.UsingEmulator())


# also seems to have issues with windows coverage or VMs
# NOTE: uses validator
is_broken = env.Bit('coverage_enabled') or env.Bit('running_on_vm')
nacl_sync_cond_test_exe = env.ComponentProgram(
    'nacl_sync_cond_test',
    ['nacl_sync_cond_test.c'],
    EXTRA_LIBS=['sel',
                'env_cleanser',
                'manifest_proxy',
                'simple_service',
                'thread_interface',
                'gio_wrapped_desc',
                'nonnacl_srpc',
                'nrd_xfer',
                'nacl_perf_counter',
                'nacl_base',
                'imc',
                'platform',
                VALIDATOR_LIB,
                ] + DEBUG_LIBS)
env.Requires(nacl_sync_cond_test_exe, crt)
node = env.CommandTest(
    'nacl_sync_cond_test.out',
    command=[nacl_sync_cond_test_exe])
env.AddNodeToTestSuite(node,
                       ['medium_tests'],
                       'run_nacl_sync_cond_test',
                       is_broken=is_broken)


env_cleanser_test_exe = env.ComponentProgram('env_cleanser_test',
                                             ['env_cleanser_test.c'],
                                             EXTRA_LIBS=['env_cleanser',
                                                         'gio_wrapped_desc',
                                                         ])
node = env.CommandTest(
    'env_cleanser_test.out',
    command=[env_cleanser_test_exe])
env.Requires(env_cleanser_test_exe, crt)
env.AddNodeToTestSuite(node, ['small_tests'])

# Test nacl_signal
if (not env.Bit('coverage_enabled') and
    not env.Bit('target_arm') and
    not env.IsRunningUnderValgrind()):
  nacl_signal_exe = env.ComponentProgram('nacl_signal_unittest',
                                         'nacl_signal_unittest.c',
                                         EXTRA_LIBS=['sel',
                                                     'env_cleanser',
                                                     'nacl_perf_counter',
                                                     'gio_wrapped_desc',
                                                     'platform',
                                                     ])
  node = env.CommandTest('nacl_signal_unittest.out',
                         command=[nacl_signal_exe],
                         exit_status='trusted_sigsegv_or_equivalent',
                         using_nacl_signal_handler='1')

  env.Requires(nacl_signal_exe, crt)
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_nacl_signal_test')

if env.Bit('posix'):
  test_prog = env.ComponentProgram('nacl_signal_frame_test',
                                   'nacl_signal_frame_test.c',
                                   EXTRA_LIBS=['sel',
                                               'env_cleanser',
                                               'nacl_perf_counter',
                                               'gio_wrapped_desc',
                                               'platform',
                                               ])
  node = env.CommandTest('nacl_signal_frame_test.out',
                         command=[test_prog],
                         exit_status='trusted_segfault',
                         using_nacl_signal_handler='1')
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_signal_frame_test')

if env.Bit('windows') and env.Bit('target_x86_64'):
  test_prog = env.ComponentProgram('patch_exception_dispatcher_test',
                                   'win/patch_exception_dispatcher_test.c',
                                   EXTRA_LIBS=['sel', 'platform'])
  node = env.CommandTest(
      'patch_exception_dispatcher_test.out',
      command=[test_prog],
      exit_status='trusted_segfault',
      stdout_golden=env.File('win/patch_exception_dispatcher_test.stdout'))
  env.AddNodeToTestSuite(node, ['small_tests'],
                         'run_patch_exception_dispatcher_test')


check_test_exe = env.ComponentProgram('nacl_check_test',
                                      ['nacl_check_test.c'],
                                      EXTRA_LIBS=['sel',
                                                  'env_cleanser',
                                                  'nacl_perf_counter',
                                                  'gio_wrapped_desc',
                                                  'platform',
                                                  ])
node = env.CommandTest(
    'check_test.out',
    command=[check_test_exe, '-C'])
env.Requires(check_test_exe, crt)
env.AddNodeToTestSuite(node, ['small_tests'])


ABORT_EXIT = '17'  # magic, see nacl_check_test.c


node = env.CommandTest(
    'check_test_death.out',
    command=[check_test_exe, '-c'],
    exit_status=ABORT_EXIT)  # abort()
env.AddNodeToTestSuite(node, ['small_tests'])


if env.Bit('debug'):
  node = env.CommandTest(
      'dcheck_test_death.out',
      command=[check_test_exe, '-d'],
      exit_status=ABORT_EXIT)  # abort()
else:
  node = env.CommandTest(
      'dcheck_test_death.out',
      command=[check_test_exe, '-d'])  # no abort()
env.AddNodeToTestSuite(node, ['small_tests'])


node = env.CommandTest(
    'check_test_always_death.out',
    command=[check_test_exe, '-s', '0', '-C'])  # no abort
env.AddNodeToTestSuite(node, ['small_tests'])


node = env.CommandTest(
    'check_test_always_death.out',
    command=[check_test_exe, '-s', '0', '-c'],
    exit_status=ABORT_EXIT)  # abort
env.AddNodeToTestSuite(node, ['small_tests'])


node = env.CommandTest(
    'dcheck_test_never_death.out',
    command=[check_test_exe, '-s', '0', '-d'])  # no abort
env.AddNodeToTestSuite(node, ['small_tests'])


node = env.CommandTest(
    'dcheck_test_always_death.out',
    command=[check_test_exe, '-s', '1', '-d'],
    exit_status=ABORT_EXIT)  # abort()
env.AddNodeToTestSuite(node, ['small_tests'])


# Mac does not support thread local storage via "__thread" so do not run this
# test on Mac.
# This test is thread-unsafe by design. Don't run it under Valgrind.
if not env.Bit('mac') and not env.IsRunningUnderValgrind():
  nacl_tls_unittest = env.ComponentProgram('nacl_tls_unittest',
                                           ['nacl_tls_unittest.c'],
                                           EXTRA_LIBS=['platform'])
  node = env.CommandTest('nacl_tls_unittest.out',
                         command=[nacl_tls_unittest])

  # Note that this test hangs in pthread_join() on ARM QEMU.
  is_broken = env.Bit('target_arm') and env.UsingEmulator()
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_nacl_tls_unittest',
                         is_broken=is_broken)

# Test that sel_ldr does not crash if the executable file cannot be opened.
node = env.CommandSelLdrTestNacl(
    'sel_ldr_exe_not_found.out',
    'name_of_file_that_does_not_exist.nexe',
    exit_status='1')
env.AddNodeToTestSuite(node, ['small_tests'], 'run_sel_ldr_exe_not_found_test')

# ----------------------------------------------------------
# Small tests with canned binaries
# ----------------------------------------------------------

# Do not run when building tools to run on x86-32 but to analyze the
# arm instruction set
if not env.CrossToolsBuild():
  node = env.CommandSelLdrTestNacl(
      'fuzz_nullptr_test.out',
      env.File(arch_testdata_dir + '/nullptr.nexe'),
      sel_ldr_flags=['-F'],
      exit_status = '0')
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_fuzz_nullptr_test')

# ----------------------------------------------------------
# Integration Tests
# ----------------------------------------------------------

# Doesn't work on windows under coverage.
# TODO(bradnelson): fix this to work on windows under coverage.
# NOTE: uses validator
if ((not env.Bit('windows') or not env.Bit('coverage_enabled')) and
    not env.CrossToolsBuild()):
  obj_proxy_test_inputs = [ 'fs/obj_proxy_test.c', ]
  obj_proxy_test = env.ComponentProgram(
      'obj_proxy_test',
      obj_proxy_test_inputs,
      EXTRA_LIBS=['sel',
                  'env_cleanser',
                  'manifest_proxy',
                  'simple_service',
                  'thread_interface',
                  'gio_wrapped_desc',
                  'nonnacl_srpc',
                  'nrd_xfer',
                  'nacl_perf_counter',
                  'nacl_base',
                  'imc',
                  'platform',
                  'nacl_xdr',
                  'container',
                  VALIDATOR_LIB,
                  ] + DEBUG_LIBS)

  node = env.CommandTest(
      'obj_proxy_test.out',
      # NOTE: this is run out of obj/ rather than staging/
      [obj_proxy_test, '-n', '2048'],
      size='huge')
  # TODO(bsy): change this test to use less time -- most of it (on windows)
  # is in the RNG, so with this will inherently speed up when the RNG is
  # updated.

  env.AddNodeToTestSuite(node, ['small_tests'], 'obj_proxy_tests')

# ----------------------------------------------------------
# Integration Tests With Canned x86 Binaries
# ----------------------------------------------------------
# To update the canned tests run:
# ./scons platform=x86-64
# cp scons-out/nacl-x86-64/staging/{mandel.nexe,fib_*} \
#     src/trusted/service_runtime/testdata/x86_64/
# ./scons platform=x86-32
# cp scons-out/nacl-x86-32/staging/{mandel.nexe,fib_*} \
#     src/trusted/service_runtime/testdata/x86_32/

# TODO: Create integration test nexes for arm.
INTEGRATION_TESTS_X86 = [ 'mandel',
                          'fib_scalar',
                          'fib_array' ]
INTEGRATION_TESTS_X86_STDIN_OUT = ['$SCONSTRUCT_DIR/tests/mandel/test',
                                   '$SCONSTRUCT_DIR/tests/fib/fib_scalar_test',
                                   '$SCONSTRUCT_DIR/tests/fib/fib_array_test' ]

def AddIntegrationTest(test, location):
  if not test or not location:
    return;

  node = env.SelUniversalTest(
      test + '_canned.out',
      env.File(arch_testdata_dir + '/' + test + '.nexe'),
      stdin = location + '.stdin',
      stdout_golden = location + '.stdout',
      )
  env.AddNodeToTestSuite(node,
                         ['medium_tests'],
                         'run_%s_integration_test' % test)

if env.Bit('target_x86'):
  RE_HELLO = '^(Hello, World!)$'
  RE_IDENT = '^\[[0-9,:.]*\] (e_ident\+1 = ELF)$'

  node = env.CommandSelLdrTestNacl(
      'nacl_log.out',
      env.File(arch_testdata_dir + '/hello_world.nexe'),
      log_golden = env.File('testdata/hello_world.log'),
      stdout_golden = env.File('testdata/hello_world.stdout'),
      filter_regex = '"' + RE_HELLO + '|' + RE_IDENT + '"',
      filter_group_only = 'true',
      )
  env.AddNodeToTestSuite(node, ['medium_tests'])

  assert len(INTEGRATION_TESTS_X86) == len(INTEGRATION_TESTS_X86_STDIN_OUT)
  map(AddIntegrationTest,
      INTEGRATION_TESTS_X86,
      INTEGRATION_TESTS_X86_STDIN_OUT)

# ----------------------------------------------------------
# Death Tests With Canned x86 Binaries
# ----------------------------------------------------------
ERROR_WHILE_LOADING = '"^(Error while loading).*' + '(:[^:]*)"'

# TODO: Create death test nexes for arm.
DEATH_TESTS_X86 = [ 'old_abi',  # hello_world.nexe with an old ABI version
                    'integer_overflow_while_madvising',
                    'negative_hole',
                    'rodata_data_overlap',
                    'data_not_last',
                    'text_overlaps_rodata',
                    'text_overlaps_data',
                    'text_too_big' ]

NOT_AVAIL_X86_32 = [ ]

NOT_AVAIL_X86_64 = [ 'text_overlaps_rodata',
                     'text_overlaps_data' ]

def AddDeathTest(test, skip):
  if not test:
    return;

  if test in skip:
    print 'SKIPPING test ', test
    return;

  # Use an arch-specific golden file if there is one.
  # We can't use the SCons File .exists() method because that will
  # look for the file in a scons-out directory.
  stderr_file = env.File(os.path.join(arch_testdata_dir, test + '.stderr'))
  if not os.path.exists(str(stderr_file)):
    stderr_file = env.File(os.path.join('testdata', test + '.stderr'))

  node = env.CommandSelLdrTestNacl(
      test  + '.out',
      env.File(arch_testdata_dir + '/' + test + '.nexe'),
      stderr_golden = stderr_file,
      filter_regex = ERROR_WHILE_LOADING,
      filter_group_only = 'true',
      exit_status = '1')
  env.AddNodeToTestSuite(node, ['medium_tests'],
                         'run_' + test + '_death_test')


if env.Bit('target_x86'):
  # built in tests/nullptr/
  node = env.CommandSelLdrTestNacl(
      'nullptr.out',
      env.File(arch_testdata_dir + '/nullptr.nexe'),
      exit_status='untrusted_segfault')
  env.AddNodeToTestSuite(node, ['medium_tests'])

  if env.Bit('build_x86_32'):
    skip = NOT_AVAIL_X86_32
  else:
    skip = NOT_AVAIL_X86_64

  for death_test in DEATH_TESTS_X86:
    AddDeathTest(death_test, skip)

# ----------------------------------------------------------
# More Death Tests
# ----------------------------------------------------------
if (not env.CrossToolsBuild() and
    (not env.Bit('coverage_enabled') or not env.Bit('windows'))):
  # NOTE: uses validator
  sel_ldr_thread_death_test_exe = env.ComponentProgram(
      'sel_ldr_thread_death_test',
      ['sel_ldr_thread_death_test.c'],
      EXTRA_LIBS=['sel',
                  'env_cleanser',
                  'manifest_proxy',
                  'simple_service',
                  'thread_interface',
                  'gio_wrapped_desc',
                  'nonnacl_srpc',
                  'nrd_xfer',
                  'nacl_perf_counter',
                  'nacl_base',
                  'imc',
                  'platform',
                  VALIDATOR_LIB,
                  ] + DEBUG_LIBS)

  # NaClAbort() behaves differently when code coverage is enabled: it
  # calls exit() rather than abort().
  if env.Bit('coverage_enabled'):
    expected_exit_status = 'naclabort_coverage'
  else:
    expected_exit_status = 'sigabrt'
  node = env.CommandTest(
      'sel_ldr_thread_death_test.out',
      command=[sel_ldr_thread_death_test_exe],
      exit_status=expected_exit_status)

  # TODO(tuduce): Make it work on windows.
  env.AddNodeToTestSuite(node, ['medium_tests'],
                         'run_sel_ldr_thread_death_test',
                         is_broken=env.Bit('windows'))
