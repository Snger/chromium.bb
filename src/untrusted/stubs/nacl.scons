# -*- python -*-
# Copyright 2008 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can
# be found in the LICENSE file.

Import('env')

if ARGUMENTS.get('bitcode'):
  assert env.get('CC_NATIVE')
  # NOTE: we make sure everything in this directory gets compiled
  #       all the way down into native code.
  #       This is tricky when run in a pnacl where tls.c would
  #       normally only compiled into a bitcode file.
  #       As a solution we have a second compiler in the env
  #       that always compiles to native.
  env.Replace(CC='${CC_NATIVE}')

  if env.get('TARGET_PLATFORM') == 'x86-64':
    # the pnacl toolchain does not export this define and
    # this is probably a good thing.
    # We only need it because the crt?_x86.S files have #ifdefs
    # in them.
    env.Append(ASFLAGS='-D__x86_64__=1')
    # sadly tls also had #ifdefs
    # TODO(robertm): break this up in mulitple files
    env.Append(CPPDEFINES=['__x86_64__=1'])
  elif env.get('TARGET_PLATFORM') == 'x86-32':
    env.Append(CPPDEFINES=['__x86_32__=1'])
# This directory contains untrusted C and ASM source for low-level
# CPU-specific libraries implicitly supplied by the compiler driver.
# Unlike most untrusted SDK code, conditional compilation may be
# freely used, as the target will never be PNaCl.

if env.get('TARGET_ARCHITECTURE') == 'x86':
  objects = [env.ComponentObject('crt1', ['crt1_x86.S' ]),
             env.ComponentObject('crti', ['crti_x86.S' ]),
             env.ComponentObject('crtn', ['crtn_x86.S' ]),
             env.ComponentObject('intrinsics', ['intrinsics_x86.S' ]),
             ]
elif env.get('TARGET_ARCHITECTURE') == 'arm':
  objects = [env.ComponentObject('crt1', ['crt1_arm.S']),
             env.ComponentObject('crti', ['crti_arm.S']),
             env.ComponentObject('crtn', ['crtn_arm.S']),
             env.ComponentObject('intrinsics', ['intrinsics_arm.S']),
             ]
else:
  raise Exception, (
    'Unexpected TARGET_ARCHITECTURE: %s' % env.get('TARGET_ARCHITECTURE'))

# Archive library of modules written in C.
crt_platform = env.StaticLibrary('crt_platform',
                                 [env.StaticObject('tls.o', ['tls.c'])])

env.AddObjectToSdk(objects + [crt_platform], is_platform=True)
