# -*- python -*-
# Copyright 2008 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can
# be found in the LICENSE file.

Import('env')

if env['TARGET_ARCHITECTURE'] == 'arm':
  assert env.get('CC_NATIVE')
  # NOTE: we make sure everything in this directory gets compiled
  #       all the way down into native code.
  #       This is tricky when run in a pnacl where tls.c would
  #       normally only compiled into a bitcode file.
  #       As a solution we have a second compiler in the env
  #       that always compiles to native.
  env.Replace(CC='${CC_NATIVE}')

# This directory contains untrusted C and ASM source for low-level
# CPU-specific libraries implicitly supplied by the compiler driver.
# Unlike most untrusted SDK code, conditional compilation may be
# freely used, as the target will never be PNaCl.

if env.get('TARGET_ARCHITECTURE') == 'x86':
  objects = [env.ComponentObject('crt1', ['crt1_x86.S' ]),
             env.ComponentObject('crti', ['crti_x86.S' ]),
             env.ComponentObject('crtn', ['crtn_x86.S' ]),
             env.ComponentObject('intrinsics', ['intrinsics_x86.S' ]),
             ]
elif env.get('TARGET_ARCHITECTURE') == 'arm':
  objects = [env.ComponentObject('crt1', ['crt1_arm.S']),
             env.ComponentObject('crti', ['crti_arm.S']),
             env.ComponentObject('crtn', ['crtn_arm.S']),
             env.ComponentObject('intrinsics', ['intrinsics_arm.S']),
             ]
else:
  raise Exception, (
    'Unexpected TARGET_ARCHITECTURE: %s' % env.get('TARGET_ARCHITECTURE'))

# Archive library of modules written in C.
crt_platform = env.StaticLibrary('crt_platform',
                                 [env.StaticObject('tls.o', ['tls.c'])])

env.AddObjectToSdk(objects + [crt_platform], is_platform=True)
