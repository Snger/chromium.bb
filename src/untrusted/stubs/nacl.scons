# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

Import('env')
import os

# This directory contains untrusted C and ASM source for low-level
# CPU-specific libraries implicitly supplied by the compiler driver.
# Unlike most untrusted SDK code, conditional compilation may be
# freely used, as the target will never be PNaCl.

def GetPlatformSuffix(env):
  platform = env.get('TARGET_FULLARCH')
  assert platform in ['x86-32',  'x86-64', 'arm']
  # we do not like hyphens in file names
  return platform.replace('-', '_')

platform = GetPlatformSuffix(env)

native_env = env.Clone()
if native_env.Bit('bitcode'):
  native_env.PNaClForceNative()

# This is a dummy linker script (a source file), not an actual object file.
# Note that even for the bitcode case we call it crt1.o rather than crt1.bc,
# just because of the tradition of using that exact name in linking rules.
crt1 = env.InstallAs('crt1.o', 'crt1.x')
env.AddObjectToSdk([crt1])

# TODO(mcgrathr): The multilib in the gcc driver logic defeats -Bx/ under -m32.
# Figure out a way to make -B really override everything else.
if platform == 'x86_32':
  env.Install(os.path.join('${LIB_DIR}', '32'), crt1)

# NOTE: we only provide setjmp/longjmp for pnacl, nacl-gcc obtains
# them from newlib, while pnacl's newlib is arch neutral
platform_objs = []

if env.Bit('bitcode'):
  bookends = []
  platform_objs.append(native_env.StaticObject('setjmp.o',
                                               ['setjmp_%s.S' % platform]))
else:
  bookends = [native_env.ComponentObject('crti', ['crti_%s.S' % platform]),
              native_env.ComponentObject('crtn', ['crtn_%s.S' % platform])]

if env.Bit('target_arm'):
  platform_objs.append('aeabi_read_tp.S')

crt_platform = native_env.StaticLibrary('crt_platform', platform_objs)

native_env.AddObjectToSdk([crt_platform] + bookends, is_platform=True)
