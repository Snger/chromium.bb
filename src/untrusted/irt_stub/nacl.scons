# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

Import('env')

env.ComponentLibrary('libppapi_stub', [
    'ppapi_plugin_main.c',
    'ppapi_plugin_start.c',
    'plugin_main_irt.c',
    'thread_creator.c'
    ])
lib = env.AddLibraryToSdk(['libppapi_stub'])

gap_env = env.Clone()
gap_env.Append(CPPDEFINES=[
    ['IRT_DATA_REGION_START', '${IRT_DATA_REGION_START}']
    ])
if gap_env.Bit('bitcode'):
  # This is not actually a platform-specific, it's generic to any assembler
  # for an ELF target.  But it can't be compiled to LLVM bitcode.
  gap_env.Replace(OBJSUFFIX='.o')
  gap_env.Append(ASFLAGS=['-arch', '${TARGET_FULLARCH}'])

link_segment_gap = gap_env.ComponentObject(
    'link_segment_gap',
    '${SCONSTRUCT_DIR}/src/untrusted/irt/link_segment_gap.S'
    )
gap_obj = gap_env.AddObjectToSdk(link_segment_gap, is_platform=True)

static_script = env.AddObjectToSdk(['libppapi.a'])

# Anything that links with -lppapi (i.e. ${PPAPI_LIBS}) needs not just the
# libppapi.a or libppapi.so linker script file, but also the object and
# library it refers to.  By telling scons that libppapi.a depends on these
# objects, we ensure that it builds them before something using ${PPAPI_LIBS}.
script_deps = [gap_obj, lib]
env.Depends(static_script, script_deps)

# The static libppapi.a refers to libpthread.a, and in the non-glibc
# build, we are the one providing that too.
if not env.Bit('nacl_glibc'):
  env.Depends(static_script, env.File('${LIB_DIR}/libpthread.a'))

if not env.Bit('nacl_disable_shared'):
  dyn_script = env.AddObjectToSdk(['libppapi.so'])
  env.Depends(dyn_script, script_deps)
