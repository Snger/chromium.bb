# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


Import('env')

# Since the integrated runtime will be built with newlib,
# there's no need to build this module against glibc.
if env.Bit('nacl_glibc'):
  Return()
# Although the regular PNaCl frontend is able to link object files
# generated from assembly code, the sandboxed version cannot.
if env.Bit('use_sandboxed_translator'):
  Return()

env.ComponentLibrary('libirt', ['irt.c'])


blob_env = env.Clone()
blob_env.Append(CPPDEFINES=[
    ['NACL_BLOCK_SHIFT', '5'],
    ['NACL_BUILD_ARCH', '${BUILD_ARCHITECTURE}'],
    ['NACL_BUILD_SUBARCH', '${BUILD_SUBARCH}'],
    ['NACL_TARGET_ARCH', '${TARGET_ARCHITECTURE}' ],
    ['NACL_TARGET_SUBARCH', '${TARGET_SUBARCH}' ],
    ])

blob_env.Append(LINKFLAGS='-Wl,--section-start,.rodata=${IRT_BLOB_DATA_START}')
# The PNaCl linker (gold) does not implement the "-Ttext-segment"
# option.  However, with the linker for x86, the "-Ttext" option does
# not affect the executable's base address.
if blob_env.Bit('bitcode'):
  blob_env.Append(LINKFLAGS='-Wl,-Ttext=${IRT_BLOB_CODE_START}')
else:
  blob_env.Append(LINKFLAGS='-Wl,-Ttext-segment=${IRT_BLOB_CODE_START}')

asm_env = blob_env.Clone()
if asm_env.Bit('bitcode'):
  asm_env.Replace(OBJSUFFIX='.o')
  asm_env.Append(ASFLAGS=['-arch', '${TARGET_FULLARCH}'])

asm_helper = asm_env.ComponentObject(
    'elf_restart_%s.S' % env['TARGET_FULLARCH'].replace('-', '_'))

files = ['irt_entry.c',
         'irt_sbrk.c',
         'irt_elf_utils.c',
         asm_helper]

# The bitcode build does not yet use -mtls-use-call and so it improperly
# pollutes user TLS with IRT-private TLS.  But until that's fixed,
# overriding the entry points with the irt_tls.c versions would cause a
# mismatch where library code using (what should be reserved for) user TLS
# will crash because it hasn't been initialized.
if not env.Bit('bitcode'):
  files.append('irt_tls.c')

irt_library = blob_env.ComponentProgram(
    'irt.nexe', files,
    EXTRA_LIBS=['ppruntime',
                'srpc',
                'imc',
                'platform',
                'gio',
                'pthread',
                'm'])

if env.Bit('build_x86_32') and not env.Bit('bitcode'):
  # Make sure that the linked IRT nexe never uses TLS via %gs access.
  # All IRT code must avoid direct use of the TLS ABI register, which
  # is reserved for user TLS.  Instead, ensure all TLS accesses use a
  # call to __nacl_read_tp, which the IRT code overrides to segregate
  # IRT-private TLS from user TLS.
  node = env.CommandTest('irt_tls_test.out',
                         ['${PYTHON}', env.File('check_tls.py'),
                          '${OBJDUMP}', irt_library])
# TODO(mcgrathr) : Enable test once fixed for mac
#  env.AddNodeToTestSuite(node, ['small_tests'], 'run_irt_tls_test')
