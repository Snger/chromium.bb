# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


Import('env')

# This module shouldn't be built in an environment that uses glibc.
if env.Bit('nacl_glibc'):
  raise UserError('src/untrusted/irt/nacl.scons in the wrong environment?')

blob_env = env.Clone()
blob_env.Append(LINKFLAGS='-Wl,--section-start,.rodata=${IRT_BLOB_DATA_START}')
# The PNaCl linker (gold) does not implement the "-Ttext-segment"
# option.  However, with the linker for x86, the "-Ttext" option does
# not affect the executable's base address.
if blob_env.Bit('bitcode'):
  blob_env.Append(LINKFLAGS='-Wl,-Ttext=${IRT_BLOB_CODE_START}')
else:
  blob_env.Append(LINKFLAGS='-Wl,-Ttext-segment=${IRT_BLOB_CODE_START}')

irt_support_sources = [
    'irt_entry.c',
    'irt_malloc.c',
    'irt_private_pthread.c',
    'irt_private_tls.c',
    ]

# The bitcode build must use -mtls-use-call to separate user TLS
# from IRT-private TLS.
if env.Bit('bitcode'):
  blob_env.Append(LINKFLAGS='-Wl,--add-translate-option=-mtls-use-call')

# NACL_GC_WRAP_SYSCALL uses ({...}) syntax.
blob_env.FilterOut(CCFLAGS=['-pedantic'])

irt_common_interfaces = [
    'irt_basic.c',
    'irt_fdio.c',
    'irt_filename.c',
    'irt_memory.c',
    'irt_dyncode.c',
    'irt_thread.c',
    'irt_mutex.c',
    'irt_cond.c',
    'irt_sem.c',
    'irt_tls.c',
    'irt_blockhook.c',
    ]

# These are the objects and libraries that go into every IRT image.
irt_support_objs = [blob_env.ComponentObject(x) for x in
                    (irt_support_sources + irt_common_interfaces)]

# The IRT code doesn't actually use most of pthreads, only mutex and cond calls.
irt_support_objs += [
    blob_env.ComponentObject(module,
                             '${MAIN_DIR}/src/untrusted/pthread/%s.c' % module)
    for module in ['nc_mutex', 'nc_condvar', 'nc_token']
    ]

irt_support_objs += [
    blob_env.ComponentObject('sys_private',
                             '${MAIN_DIR}/src/untrusted/nacl/sys_private.c'),
    ]

if env.Bit('target_arm'):
  blob_env.Append(LINKFLAGS='--pnacl-allow-native')
  native_env = blob_env.Clone()
  native_env.PNaClForceNative()
  irt_support_objs.append(native_env.ComponentObject('aeabi_read_tp.o',
                                                     'aeabi_read_tp.S'))

# These go into only one image or the other.
irt_nonbrowser = ['irt_interfaces.c',
                  'irt_core_resource.c',
                  ]

irt_browser = ['irt_interfaces_ppapi.c',
               'irt_entry_ppapi.c',
               'irt_ppapi.c',
               'irt_manifest.c',
               ]

def LinkIrt(output, files, libs):
  return blob_env.ComponentProgram(output, irt_support_objs + files,
                                   EXTRA_LIBS=libs)

irt_core_library = LinkIrt('irt_core', irt_nonbrowser, [])
irt_library = LinkIrt('irt', irt_browser, ['ppruntime',
                                           'srpc',
                                           'imc_syscalls',
                                           'platform',
                                           'gio',
                                           'm'])

# TODO(mcgrathr): these should be installed, but scons is a mystery
#env.AddHeaderToSdk(['irt.h'])
#env.AddHeaderToSdk(['irt_ppapi.h'])

if env.Bit('build_x86_32') and not env.Bit('bitcode'):
  # Make sure that the linked IRT nexe never uses TLS via %gs access.
  # All IRT code must avoid direct use of the TLS ABI register, which
  # is reserved for user TLS.  Instead, ensure all TLS accesses use a
  # call to __nacl_read_tp, which the IRT code overrides to segregate
  # IRT-private TLS from user TLS.
  node = env.CommandTest('irt_tls_test.out',
                         ['${PYTHON}', env.File('check_tls.py'),
                          '${OBJDUMP}', irt_library])
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_irt_tls_test')
  node = env.CommandTest('irt_core_tls_test.out',
                         ['${PYTHON}', env.File('check_tls.py'),
                          '${OBJDUMP}', irt_core_library])
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_irt_core_tls_test')
