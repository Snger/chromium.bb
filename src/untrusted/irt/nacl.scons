# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


Import('env')

# Since the integrated runtime will be built with newlib,
# there's no need to build this module against glibc.
if env.Bit('nacl_glibc'):
  Return()
# Although the regular PNaCl frontend is able to link object files
# generated from assembly code, the sandboxed version cannot.
if env.Bit('use_sandboxed_translator'):
  Return()

blob_env = env.Clone()
blob_env.Append(CPPDEFINES=[
    ['NACL_BLOCK_SHIFT', '5'],
    ['NACL_BUILD_ARCH', '${BUILD_ARCHITECTURE}'],
    ['NACL_BUILD_SUBARCH', '${BUILD_SUBARCH}'],
    ['NACL_TARGET_ARCH', '${TARGET_ARCHITECTURE}' ],
    ['NACL_TARGET_SUBARCH', '${TARGET_SUBARCH}' ],
    ])

blob_env.Append(LINKFLAGS='-Wl,--section-start,.rodata=${IRT_BLOB_DATA_START}')
# The PNaCl linker (gold) does not implement the "-Ttext-segment"
# option.  However, with the linker for x86, the "-Ttext" option does
# not affect the executable's base address.
if blob_env.Bit('bitcode'):
  blob_env.Append(LINKFLAGS='-Wl,-Ttext=${IRT_BLOB_CODE_START}')
  # To allow elf_restart_*.o in the link line
  blob_env.Append(LINKFLAGS='--pnacl-allow-native')
  # Without this llc asserts
  # c.f. http://code.google.com/p/nativeclient/issues/detail?id=1225
#  blob_env.Append(LINKFLAGS=['-O0'])
else:
  blob_env.Append(LINKFLAGS='-Wl,-Ttext-segment=${IRT_BLOB_CODE_START}')

asm_env = blob_env.Clone()
if asm_env.Bit('bitcode'):
  asm_env.Replace(OBJSUFFIX='.o')
  asm_env.Append(ASFLAGS=['-arch', '${TARGET_FULLARCH}'])

asm_helper = asm_env.ComponentObject(
    'elf_restart_%s.S' % env['TARGET_FULLARCH'].replace('-', '_'))

irt_support_sources = [
    'irt_entry.c',
    'irt_malloc.c',
    'irt_sbrk.c',
    'irt_elf_utils.c',
    ]

# The bitcode build does not yet use -mtls-use-call and so it improperly
# pollutes user TLS with IRT-private TLS.  But until that's fixed,
# overriding the entry points with the irt_tls.c versions would cause a
# mismatch where library code using (what should be reserved for) user TLS
# will crash because it hasn't been initialized.
if not env.Bit('bitcode'):
  irt_support_sources.append('irt_tls.c')

# TODO(mcgrathr): most of these live in ../nacl/irt_*.c now because
# of the dismal kludge state of building everything.  Eventually
# all that should move here.
irt_common_interfaces = []

# These are the objects and libraries that go into every IRT image.
irt_support_objs = asm_helper + [blob_env.ComponentObject(x) for x in
                                 (irt_support_sources + irt_common_interfaces)]
irt_support_libs = ['pthread']

# These go into only one image or the other.
irt_nonbrowser = ['irt_interfaces.c',
                  ]

irt_browser = ['irt_interfaces_ppapi.c',
               'irt_ppapi.c',
               ]

def LinkIrt(output, files, libs):
  return blob_env.ComponentProgram(output, irt_support_objs + files,
                                   EXTRA_LIBS=libs + irt_support_libs)

irt_core_library = LinkIrt('irt_core.nexe', irt_nonbrowser, [])
irt_library = LinkIrt('irt.nexe', irt_browser, ['ppruntime',
                                                'srpc',
                                                'imc_syscalls',
                                                'platform',
                                                'gio',
                                                'm'])

# TODO(mcgrathr): these should be installed, but scons is a mystery
#env.AddHeaderToSdk(['irt.h'])
#env.AddHeaderToSdk(['irt_ppapi.h'])

if env.Bit('build_x86_32') and not env.Bit('bitcode'):
  # Make sure that the linked IRT nexe never uses TLS via %gs access.
  # All IRT code must avoid direct use of the TLS ABI register, which
  # is reserved for user TLS.  Instead, ensure all TLS accesses use a
  # call to __nacl_read_tp, which the IRT code overrides to segregate
  # IRT-private TLS from user TLS.
  node = env.CommandTest('irt_tls_test.out',
                         ['${PYTHON}', env.File('check_tls.py'),
                          '${OBJDUMP}', irt_library])
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_irt_tls_test')
  node = env.CommandTest('irt_core_tls_test.out',
                         ['${PYTHON}', env.File('check_tls.py'),
                          '${OBJDUMP}', irt_core_library])
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_irt_core_tls_test')
