# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


Import('env')

# This module shouldn't be built in an environment that uses glibc.
if env.Bit('nacl_glibc'):
  raise UserError('src/untrusted/irt/nacl.scons in the wrong environment?')

blob_env = env.Clone()
blob_env.Append(LINKFLAGS='-Wl,--section-start,.rodata=${IRT_BLOB_DATA_START}')
# The PNaCl linker (gold) does not implement the "-Ttext-segment"
# option.  However, with the linker for x86, the "-Ttext" option does
# not affect the executable's base address.
if blob_env.Bit('bitcode'):
  blob_env.Append(LINKFLAGS='-Wl,-Ttext=${IRT_BLOB_CODE_START}')
else:
  blob_env.Append(LINKFLAGS='-Wl,-Ttext-segment=${IRT_BLOB_CODE_START}')

irt_support_sources = [
    'irt_entry.c',
    'irt_malloc.c',
    'irt_sbrk.c',
    'irt_elf_utils.c',
    ]

# The bitcode build does not yet use -mtls-use-call and so it improperly
# pollutes user TLS with IRT-private TLS.  But until that's fixed,
# overriding the entry points with the irt_tls.c versions would cause a
# mismatch where library code using (what should be reserved for) user TLS
# will crash because it hasn't been initialized.
if not env.Bit('bitcode'):
  irt_support_sources.append('irt_tls.c')

# TODO(mcgrathr): most of these live in ../nacl/irt_*.c now because
# of the dismal kludge state of building everything.  Eventually
# all that should move here.
irt_common_interfaces = []

# These are the objects and libraries that go into every IRT image.
irt_support_objs = [blob_env.ComponentObject(x) for x in
                    (irt_support_sources + irt_common_interfaces)]
irt_support_libs = ['pthread']

# These go into only one image or the other.
irt_nonbrowser = ['irt_interfaces.c',
                  ]

irt_browser = ['irt_interfaces_ppapi.c',
               'irt_ppapi.c',
               ]

def LinkIrt(output, files, libs):
  return blob_env.ComponentProgram(output, irt_support_objs + files,
                                   EXTRA_LIBS=libs + irt_support_libs)

irt_core_library = LinkIrt('irt_core', irt_nonbrowser, [])
irt_library = LinkIrt('irt', irt_browser, ['ppruntime',
                                           'srpc',
                                           'imc_syscalls',
                                           'platform',
                                           'gio',
                                           'm'])

# TODO(mcgrathr): these should be installed, but scons is a mystery
#env.AddHeaderToSdk(['irt.h'])
#env.AddHeaderToSdk(['irt_ppapi.h'])

if env.Bit('build_x86_32') and not env.Bit('bitcode'):
  # Make sure that the linked IRT nexe never uses TLS via %gs access.
  # All IRT code must avoid direct use of the TLS ABI register, which
  # is reserved for user TLS.  Instead, ensure all TLS accesses use a
  # call to __nacl_read_tp, which the IRT code overrides to segregate
  # IRT-private TLS from user TLS.
  node = env.CommandTest('irt_tls_test.out',
                         ['${PYTHON}', env.File('check_tls.py'),
                          '${OBJDUMP}', irt_library])
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_irt_tls_test')
  node = env.CommandTest('irt_core_tls_test.out',
                         ['${PYTHON}', env.File('check_tls.py'),
                          '${OBJDUMP}', irt_core_library])
  env.AddNodeToTestSuite(node, ['small_tests'], 'run_irt_core_tls_test')
