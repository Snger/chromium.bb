<!DOCTYPE html>
<!--
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/base/interval_tree.html">
<script>
'use strict';

tv.b.unittest.testSuite(function() {
  function SimpleIntervalTree() {
    tv.b.IntervalTree.call(this,
        function(s) { return s.start; },
        function(s) { return s.end; });
    return this;
  }
  SimpleIntervalTree.prototype = {
    __proto__: tv.b.IntervalTree.prototype
  };

  function buildSimpleTree() {
    var tree = new SimpleIntervalTree();
    tree.v0 = tree.insert({start: 2, end: 6});
    tree.v1 = tree.insert({start: 1, end: 3});
    tree.v2 = tree.insert({start: 5, end: 7});
    tree.v3 = tree.insert({start: 1, end: 5});
    tree.v4 = tree.insert({start: 3, end: 5});
    tree.v5 = tree.insert({start: 3, end: 5});
    tree.v6 = tree.insert({start: 3, end: 6});
    tree.v7 = tree.insert({start: 1, end: 1});
    tree.v8 = tree.insert({start: 4, end: 8});
    tree.v9 = tree.insert({start: 0, end: 2});

    tree.updateHighValues();

    return tree;
  }

  function sortSimpleResults(intersection) {
    intersection.sort(function(a, b) {
      if (a.start === b.start)
        return a.end - b.end;
      return a.start - b.start;
    });
  }

  test('findIntersection', function() {
    var tree = buildSimpleTree();
    var intersection = tree.findIntersection(2, 4);
    sortSimpleResults(intersection);

    var expected = [tree.v1, tree.v3, tree.v0, tree.v4, tree.v5, tree.v6];
    assert.equal(6, intersection.length);
    assert.deepEqual(expected, intersection);
  });

  test('findIntersection_zeroDuration', function() {
    var tree = buildSimpleTree();
    var intersection = tree.findIntersection(2, 2);
    sortSimpleResults(intersection);

    var expected = [tree.v1, tree.v3];
    assert.equal(2, intersection.length);
    assert.deepEqual(expected, intersection);
  });

  test('findIntersection_noMatching', function() {
    var tree = buildSimpleTree();
    var intersection = tree.findIntersection(9, 10);
    assert.deepEqual([], intersection);
  });

  test('findIntersection_emptyTree', function() {
    var tree = new tv.b.IntervalTree();
    tree.updateHighValues();

    var intersection = tree.findIntersection(2, 4);
    assert.deepEqual([], intersection);
  });

  test('findIntersection_emptyInterval', function() {
    var tree = new tv.b.IntervalTree();
    tree.updateHighValues();

    assert.throws(function() {
      tree.findIntersection();
    });
    assert.throws(function() {
      tree.findIntersection(1);
    });
    assert.throws(function() {
      tree.findIntersection('a', 'b');
    });
  });

  test('insert', function() {
    var tree = new tv.b.IntervalTree(
        function(s) { return s.start; },
        function(s) { return s.end; });

    assert.equal(0, tree.size);

    tree.insert({start: 1, end: 4});
    tree.insert({start: 3, end: 5});
    tree.updateHighValues();

    var outTree = {
      'left': {
        'node': [1, 4]
      },
      'node': [3, 5]
    };

    assert.equal(2, tree.size);
    assert.deepEqual(outTree, tree.dump_());
  });

  test('insert_withoutEnd', function() {
    var tree = new tv.b.IntervalTree(
        function(s) { return s.start; },
        function(s) { return s.end; });

    assert.equal(0, tree.size);

    tree.insert({start: 3, end: 5});
    tree.insert({start: 1, end: 4});
    tree.updateHighValues();

    var outTree = {
      'left': {
        'node': [1, 4]
      },
      'node': [3, 5]
    };

    assert.equal(2, tree.size);
    assert.deepEqual(outTree, tree.dump_());
  });

  test('insert_balancesTree', function() {
    var tree = new tv.b.IntervalTree(
        function(s) { return s.start; },
        function(s) { return s.end; });

    assert.equal(0, tree.size);

    for (var i = 0; i < 10; ++i)
      tree.insert({start: i, end: 5});
    tree.updateHighValues();

    var outTree = {
      'left': {
        'left': {
          'node': [0, 5]
        },
        'node': [1, 5],
        'right': {
          'node': [2, 5]
        }
      },
      'node': [3, 5],
      'right': {
        'left': {
          'left': {
            'node': [4, 5]
          },
          'node': [5, 5],
          'right': {
            'node': [6, 5]
          }
        },
        'node': [7, 5],
        'right': {
          'left': {
            'node': [8, 5]
          },
          'node': [9, 5]
        }
      }
    };

    assert.deepEqual(outTree, tree.dump_());
  });

  test('insert_withDuplicateIntervals', function() {
    var tree = new tv.b.IntervalTree(
        function(s) { return s.start; },
        function(s) { return s.end; });

    assert.equal(0, tree.size);

    tree.insert({start: 1, end: 4});
    tree.insert({start: 3, end: 5});
    tree.insert({start: 3, end: 5});
    tree.insert({start: 3, end: 6});
    tree.updateHighValues();

    var outTree = {
      'left': {
        'node': [1, 4]
      },
      'node': [[3, 5], [3, 5], [3, 6]]
    };

    assert.equal(4, tree.size);
    assert.deepEqual(outTree, tree.dump_());
  });

  test('insert_updatesHighValues', function() {
    var tree = buildSimpleTree();

    var expected = [
      [undefined, undefined],
      [2, undefined],
      [5, 8],
      [undefined, undefined],
      [6, 7],
      [undefined, undefined]
    ];

    var result = [];
    function walk(node) {
      if (node === undefined)
        return;

      walk(node.leftNode);
      result.push([node.maxHighLeft, node.maxHighRight]);
      walk(node.rightNode);
    }
    walk(tree.root);

    assert.deepEqual(expected, result);
  });
});
</script>
