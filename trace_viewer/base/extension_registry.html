<!DOCTYPE html>
<!--
gCopyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/base.html">
<script>
'use strict';

/**
 * @fileoverview Helper code for defining extension registries, which can be
 * used to make a part of trace-viewer extensible.
 *
 * This file provides two basic types of extension registries:
 * - Generic: register a type with metadata, query for those types based on
 *            a predicate
 *
 * - TypeName-based: register a type that handles some combination
 *                   of tracing categories or typeNames, then query
 *                   for it based on a category, typeName or both.
 *
 * When you register subtypes, you pass the constructor for the
 * subtype, and any metadata you want associated with the subtype. Use metadata
 * instead of stuffing fields onto the constructor. E.g.:
 *     registry.register(MySubclass, {titleWhenShownInTabStrip: 'MySub'})
 *
 * Some registries want a default object that is returned when a more precise
 * subtype has been registered. To provide one, set the defaultConstructor
 * option on the registry options.
 *
 * If you want to enforce that a registry only manages types of a given subtype,
 * then set mandatoryBaseType field on the registry.
 *
 */
tv.exportTo('tv', function() {
  function RegisteredTypeInfo(constructor, metadata) {
    this.constructor = constructor;
    this.metadata = metadata;
  };

  var BASIC_REGISTRY_MODE = 'BASIC_REGISTRY_MODE';
  var TYPE_BASED_REGISTRY_MODE = 'TYPE_BASED_REGISTRY_MODE';
  var ALL_MODES = {BASIC_REGISTRY_MODE: true, TYPE_BASED_REGISTRY_MODE: true};

  function ExtensionRegistryOptions(mode) {
    if (mode === undefined)
      throw new Error('Mode is required');
    if (!ALL_MODES[mode])
      throw new Error('Not a mode.');

    this.mode_ = mode;
    this.defaultMetadata_ = {};
    this.defaultConstructor_ = undefined;
    this.mandatoryBaseClass_ = undefined;
    this.defaultTypeInfo_ = undefined;
    this.frozen_ = false;
  }
  ExtensionRegistryOptions.prototype = {
    freeze: function() {
      if (this.frozen_)
        throw new Error('Frozen');
      this.frozen_ = true;
    },

    get mode() {
      return this.mode_;
    },

    get defaultMetadata() {
      return this.defaultMetadata_;
    },

    set defaultMetadata(defaultMetadata) {
      if (this.frozen_)
        throw new Error('Frozen');
      this.defaultMetadata_ = defaultMetadata;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultConstructor() {
      return this.defaultConstructor_;
    },

    set defaultConstructor(defaultConstructor) {
      if (this.frozen_)
        throw new Error('Frozen');
      this.defaultConstructor_ = defaultConstructor;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultTypeInfo() {
      if (this.defaultTypeInfo_ === undefined && this.defaultConstructor_) {
        this.defaultTypeInfo_ = new RegisteredTypeInfo(
            this.defaultConstructor,
            this.defaultMetadata);
      }
      return this.defaultTypeInfo_;
    },

    validateConstructor: function(constructor) {
      if (!this.mandatoryBaseClass)
        return;
      var curProto = constructor.prototype.__proto__;
      var ok = false;
      while (curProto) {
        if (curProto === this.mandatoryBaseClass.prototype) {
          ok = true;
          break;
        }
        curProto = curProto.__proto__;
      }
      if (!ok)
        throw new Error(constructor + 'must be subclass of ' + registry);
    }
  }

  function decorateExtensionRegistry(registry, registryOptions) {
    if (registry.register)
      throw new Error('Already has registry');

    registryOptions.freeze();
    if (registryOptions.mode == BASIC_REGISTRY_MODE) {
      decorateBasicExtensionRegistry(registry, registryOptions);
    } else if (registryOptions.mode == TYPE_BASED_REGISTRY_MODE) {
      decorateTypeBasedExtensionRegistry(registry, registryOptions);
    } else {
      throw new Error('Unrecognized mode');
    }
  }

  function decorateBasicExtensionRegistry(registry, extensionRegistryOptions) {
    registry.registeredTypeInfos_ = [];

    registry.register = function(constructor,
                                 opt_metadata) {
      if (registry.findIndexOfRegisteredConstructor(
          constructor) !== undefined)
        throw new Error('Handler already registered for ' + constructor);

      extensionRegistryOptions.validateConstructor(constructor);

      var metadata = {};
      for (var k in extensionRegistryOptions.defaultMetadata)
        metadata[k] = extensionRegistryOptions.defaultMetadata[k];
      if (opt_metadata) {
        for (var k in opt_metadata)
          metadata[k] = opt_metadata[k];
      }

      registry.registeredTypeInfos_.push(new RegisteredTypeInfo(
        constructor,
        metadata));
    };

    registry.findIndexOfRegisteredConstructor = function(constructor) {
      for (var i = 0; i < registry.registeredTypeInfos_.length; i++)
        if (registry.registeredTypeInfos_[i].constructor == constructor)
          return i;
      return undefined;
    };

    registry.unregister = function(constructor) {
      var foundIndex = registry.findIndexOfRegisteredConstructor(constructor);
      if (foundIndex === undefined)
        throw new Error(constructor + ' not registered');
      registry.registeredTypeInfos_.splice(foundIndex, 1);
    };

    registry.getAllRegisteredTypeInfos = function() {
      return registry.registeredTypeInfos_;
    };

    registry.findTypeInfoMatching = function(predicate, opt_this) {
      opt_this = opt_this ? opt_this : undefined;
      for (var i = 0; i < registry.registeredTypeInfos_.length; ++i) {
        var typeInfo = registry.registeredTypeInfos_[i];
        if (predicate.call(opt_this, typeInfo))
          return typeInfo;
      }
      return extensionRegistryOptions.defaultTypeInfo;
    };
  }

  // Cached values for getCategoryParts.
  var categoryPartsFor = {};

  /**
   * Categories are stored in comma-separated form, e.g: 'a,b' meaning
   * that the event is part of the a and b category.
   *
   * This function returns the category split by string, caching the
   * array for performance.
   *
   * Do not mutate the returned array!!!!
   */
  function getCategoryParts(category) {
    var parts = categoryPartsFor[category];
    if (parts !== undefined)
      return parts;
    parts = category.split(',');
    categoryPartsFor[category] = parts;
    return parts;
  }

  function decorateTypeBasedExtensionRegistry(registry,
                                              extensionRegistryOptions) {
    registry.registeredTypeInfos_ = [];

    registry.categoryPartToTypeInfoMap_ = {};
    registry.typeNameToTypeInfoMap_ = {};

    registry.register = function(constructor,
                                 metadata) {

      extensionRegistryOptions.validateConstructor(constructor);

      var typeInfo = new RegisteredTypeInfo(
          constructor,
          metadata || extensionRegistryOptions.defaultMetadata);

      typeInfo.typeNames = [];
      typeInfo.categoryParts = [];
      if (metadata && metadata.typeName)
        typeInfo.typeNames.push(metadata.typeName);
      if (metadata && metadata.typeNames) {
        typeInfo.typeNames.push.apply(
          typeInfo.typeNames, metadata.typeNames);
      }
      if (metadata && metadata.categoryParts) {
        typeInfo.categoryParts.push.apply(
          typeInfo.categoryParts, metadata.categoryParts);
      }

      if (typeInfo.typeNames.length === 0 &&
          typeInfo.categoryParts.length === 0)
        throw new Error('typeName or typeNames must be provided');

      // Sanity checks...
      typeInfo.typeNames.forEach(function(typeName) {
        if (registry.typeNameToTypeInfoMap_[typeName])
          throw new Error('typeName ' + typeName + ' already registered');
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        if (registry.categoryPartToTypeInfoMap_[categoryPart])
          throw new Error('categoryPart ' + categoryPart + ' already registered');
      });

      // Actual registration.
      typeInfo.typeNames.forEach(function(typeName) {
        registry.typeNameToTypeInfoMap_[typeName] = typeInfo;
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        registry.categoryPartToTypeInfoMap_[categoryPart] = typeInfo;
      });
      registry.registeredTypeInfos_.push(typeInfo);
    };

    registry.unregister = function(constructor) {
      var typeInfoIndex = -1;
      for (var i = 0; i < registry.registeredTypeInfos_.length; i++) {
        if (registry.registeredTypeInfos_[i].constructor == constructor) {
          typeInfoIndex = i;
          break;
        }
      }
      if (typeInfoIndex === -1)
        throw new Error(constructor + ' not registered');

      var typeInfo = registry.registeredTypeInfos_[typeInfoIndex];
      registry.registeredTypeInfos_.splice(typeInfoIndex, 1);
      typeInfo.typeNames.forEach(function(typeName) {
        delete registry.typeNameToTypeInfoMap_[typeName];
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        delete registry.categoryPartToTypeInfoMap_[categoryPart];
      });
    };

    registry.getTypeInfo = function(category, typeName) {
      if (category) {
        var categoryParts = getCategoryParts(category);
        for (var i = 0; i < categoryParts.length; i++) {
          var categoryPart = categoryParts[i];
          if (registry.categoryPartToTypeInfoMap_[categoryPart])
            return registry.categoryPartToTypeInfoMap_[categoryPart];
        }
      }
      if (registry.typeNameToTypeInfoMap_[typeName])
        return registry.typeNameToTypeInfoMap_[typeName];

      return extensionRegistryOptions.defaultTypeInfo;
    };

    // TODO(nduca): Remove or rename.
    registry.getConstructor = function(category, typeName) {
      var typeInfo = registry.getTypeInfo(category, typeName);
      if (typeInfo)
        return typeInfo.constructor;
      return undefined;
    };
  }

  return {
    BASIC_REGISTRY_MODE: BASIC_REGISTRY_MODE,
    TYPE_BASED_REGISTRY_MODE: TYPE_BASED_REGISTRY_MODE,

    ExtensionRegistryOptions: ExtensionRegistryOptions,
    RegisteredTypeInfo: RegisteredTypeInfo,

    decorateExtensionRegistry: decorateExtensionRegistry
  };
});
</script>
