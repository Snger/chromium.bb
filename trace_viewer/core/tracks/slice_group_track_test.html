<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/test_utils.html">
<link rel="import" href="/core/timeline_track_view.html">
<link rel="import" href="/core/trace_model/slice_group.html">

<script>
'use strict';

tv.b.unittest.testSuite(function() {
  var ProcessTrack = tv.c.tracks.ProcessTrack;
  var ThreadTrack = tv.c.tracks.ThreadTrack;
  var SliceGroup = tv.c.trace_model.SliceGroup;
  var SliceGroupTrack = tv.c.tracks.SliceGroupTrack;
  var newSliceNamed = tv.c.test_utils.newSliceNamed;

  test('subRowBuilderBasic', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;
    var sA = group.pushSlice(newSliceNamed('a', 1, 2));
    var sB = group.pushSlice(newSliceNamed('a', 3, 1));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(1, subRows.length);
    assert.equal(2, subRows[0].length);
    assert.deepEqual([sA, sB], subRows[0]);
  });

  test('subRowBuilderBasic2', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;
    var sA = group.pushSlice(newSliceNamed('a', 1, 4));
    var sB = group.pushSlice(newSliceNamed('b', 3, 1));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(2, subRows.length);
    assert.equal(1, subRows[0].length);
    assert.equal(1, subRows[1].length);
    assert.deepEqual([sA], subRows[0]);
    assert.deepEqual([sB], subRows[1]);
  });

  test('subRowBuilderNestedExactly', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    var sB = group.pushSlice(newSliceNamed('b', 1, 4));
    var sA = group.pushSlice(newSliceNamed('a', 1, 4));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(2, subRows.length);
    assert.equal(1, subRows[0].length);
    assert.equal(1, subRows[1].length);
    assert.deepEqual([sB], subRows[0]);
    assert.deepEqual([sA], subRows[1]);
  });

  test('subRowBuilderInstantEvents', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    var sA = group.pushSlice(newSliceNamed('a', 1, 0));
    var sB = group.pushSlice(newSliceNamed('b', 2, 0));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(1, subRows.length);
    assert.equal(2, subRows[0].length);
    assert.deepEqual([sA, sB], subRows[0]);
  });

  test('subRowBuilderTwoInstantEvents', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    var sA = group.pushSlice(newSliceNamed('a', 1, 0));
    var sB = group.pushSlice(newSliceNamed('b', 1, 0));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(2, subRows.length);
    assert.deepEqual([sA], subRows[0]);
    assert.deepEqual([sB], subRows[1]);
  });

  test('subRowBuilderOutOfOrderAddition', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    // Pattern being tested:
    // [    a     ][   b   ]
    // Where insertion is done backward.
    var sB = group.pushSlice(newSliceNamed('b', 3, 1));
    var sA = group.pushSlice(newSliceNamed('a', 1, 2));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(1, subRows.length);
    assert.equal(2, subRows[0].length);
    assert.deepEqual([sA, sB], subRows[0]);
  });

  test('subRowBuilderOutOfOrderAddition2', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    // Pattern being tested:
    // [    a     ]
    //   [  b   ]
    // Where insertion is done backward.
    var sB = group.pushSlice(newSliceNamed('b', 3, 1));
    var sA = group.pushSlice(newSliceNamed('a', 1, 5));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(2, subRows.length);
    assert.equal(1, subRows[0].length);
    assert.equal(1, subRows[1].length);
    assert.deepEqual([sA], subRows[0]);
    assert.deepEqual([sB], subRows[1]);
  });

  test('subRowBuilderOnNestedZeroLength', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    // Pattern being tested:
    // [    a    ]
    // [  b1 ]  []<- b2 where b2.duration = 0 and b2.end == a.end.
    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB1 = group.pushSlice(newSliceNamed('b1', 1, 2));
    var sB2 = group.pushSlice(newSliceNamed('b2', 4, 0));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(2, subRows.length);
    assert.deepEqual([sA], subRows[0]);
    assert.deepEqual([sB1, sB2], subRows[1]);
  });

  test('subRowBuilderOnGroup1', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    // Pattern being tested:
    // [    a     ]   [  c   ]
    //   [  b   ]
    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB = group.pushSlice(newSliceNamed('b', 1.5, 1));
    var sC = group.pushSlice(newSliceNamed('c', 5, 0));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;
    var subRows = track.subRows;

    assert.equal(0, track.badSlices_.length);
    assert.equal(2, subRows.length);
    assert.deepEqual([sA, sC], subRows[0]);
    assert.deepEqual([sB], subRows[1]);
  });

  test('subRowBuilderOnGroup2', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    // Pattern being tested:
    // [    a     ]   [  d   ]
    //   [  b   ]
    //    [ c ]
    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB = group.pushSlice(newSliceNamed('b', 1.5, 1));
    var sC = group.pushSlice(newSliceNamed('c', 1.75, 0.5));
    var sD = group.pushSlice(newSliceNamed('c', 5, 0.25));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;

    var subRows = track.subRows;
    assert.equal(0, track.badSlices_.length);
    assert.equal(3, subRows.length);
    assert.deepEqual([sA, sD], subRows[0]);
    assert.deepEqual([sB], subRows[1]);
    assert.deepEqual([sC], subRows[2]);
  });

  test('trackFiltering', function() {
    var m = new tv.c.TraceModel();
    var t1 = m.getOrCreateProcess(1).getOrCreateThread(2);
    var group = t1.sliceGroup;

    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB = group.pushSlice(newSliceNamed('b', 1.5, 1));

    var track = new SliceGroupTrack(new tv.c.TimelineViewport());
    track.group = group;

    assert.equal(2, track.subRows.length);
    assert.isTrue(track.hasVisibleContent);
  });

test('sliceGroupContainerMap', function() {
    var vp = new tv.c.TimelineViewport();
    var containerToTrack = vp.containerToTrackObj;
    var model = new tv.c.TraceModel();
    var process = model.getOrCreateProcess(123);
    var thread = process.getOrCreateThread(456);
    var group = new SliceGroup(thread);

    var processTrack = new ProcessTrack(vp);
    var threadTrack = new ThreadTrack(vp);
    var groupTrack = new SliceGroupTrack(vp);
    processTrack.process = process;
    threadTrack.thread = thread;
    groupTrack.group = group;
    processTrack.appendChild(threadTrack);
    threadTrack.appendChild(groupTrack);

    assert.equal(process, processTrack.eventContainer);
    assert.equal(thread, threadTrack.eventContainer);
    assert.equal(group, groupTrack.eventContainer);

    assert.isUndefined(containerToTrack.getTrackByStableId('123'));
    assert.isUndefined(containerToTrack.getTrackByStableId('123.456'));
    assert.isUndefined(
        containerToTrack.getTrackByStableId('123.456.SliceGroup'));

    vp.modelTrackContainer = {
      addContainersToTrackMap: function(containerToTrackObj) {
        processTrack.addContainersToTrackMap(containerToTrackObj);
      },
      addEventListener: function() {}
    };
    vp.rebuildContainerToTrackMap();

    // Check that all tracks call childs' addContainersToTrackMap()
    // by checking the resulting map.
    assert.equal(processTrack, containerToTrack.getTrackByStableId('123'));
    assert.equal(threadTrack, containerToTrack.getTrackByStableId('123.456'));
    assert.equal(groupTrack,
        containerToTrack.getTrackByStableId('123.456.SliceGroup'));

    // Check the track's eventContainer getter.
    assert.equal(process, processTrack.eventContainer);
    assert.equal(thread, threadTrack.eventContainer);
    assert.equal(group, groupTrack.eventContainer);
  });
});
</script>

