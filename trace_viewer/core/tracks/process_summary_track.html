<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/tracks/rect_track.html">
<link rel="import" href="/base/ui.html">
<link rel="import" href="/base/ui/color_scheme.html">

<script>
'use strict';

tv.exportTo('tv.c.tracks', function() {
  var SliceGroup = tv.c.trace_model.SliceGroup;

  function hasSyncSlices(thread) {
    return thread.sliceGroup && thread.sliceGroup.slices.length;
  }

  function getMergedTopLevelSlices(sliceGroupA, sliceGroupB) {
    var newGroup = SliceGroup.merge(sliceGroupA, sliceGroupB);
    newGroup.createSubSlices();
    return newGroup.topLevelSlices;
  }

  /**
   * Visualizes a Process's state using a series of rects to represent activity.
   * @constructor
   */
  var ProcessSummaryTrack = tv.b.ui.define('process-summary-track',
                                           tv.c.tracks.RectTrack);

  ProcessSummaryTrack.buildRectsFromProcess = function(process) {
    if (!process)
      return [];

    // smush together all top level slices into single group
    var totalGroup = undefined;
    for (var tid in process.threads) {
      var thread = process.threads[tid];

      // usage of topLevelSlices requires createSubSlices() to have been called
      if (!thread.sliceGroup || thread.sliceGroup.topLevelSlices.length == 0)
        continue;

      var virtualGroup = new SliceGroup();
      virtualGroup.pushSlices(thread.sliceGroup.topLevelSlices);

      if (!totalGroup) {
        totalGroup = virtualGroup;
      } else {
        var newTopSlices = getMergedTopLevelSlices(totalGroup, virtualGroup);
        totalGroup = new SliceGroup();
        totalGroup.pushSlices(newTopSlices);
      }
    }

    if (!totalGroup)
      return [];

    // top level slices of that group represent process activity
    var rects = [];
    var colorId = tv.b.ui.getColorIdForReservedName('generic_work');
    totalGroup.createSubSlices();
    totalGroup.topLevelSlices.forEach(function(slice) {
      if (rects.length) {
        var lastRect = rects[rects.length - 1];
        // attempt to merge
        if (slice.start <= lastRect.end) {
          lastRect.end = slice.end;
          return;
        }
      }
      rects.push({
        start: slice.start,
        end: slice.end,
        duration: slice.duration,
        colorId: colorId
      });
    });
    return rects;
  };

  ProcessSummaryTrack.prototype = {
    __proto__: tv.c.tracks.RectTrack.prototype,

    decorate: function(viewport) {
      tv.c.tracks.RectTrack.prototype.decorate.call(this, viewport);
      this.classList.add('inverse-expand');
    },

    get process() {
      return this.process_;
    },

    set process(process) {
      this.process_ = process;
      this.rects = ProcessSummaryTrack.buildRectsFromProcess(process);
    },

    getModelEventFromItem: function(thing) {
      // Do nothing, since not selectable
      return undefined;
    }
  };

  return {
    ProcessSummaryTrack: ProcessSummaryTrack
  };
});
</script>
