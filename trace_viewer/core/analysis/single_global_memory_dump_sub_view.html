<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/analysis/analysis_sub_view.html">
<link rel="import" href="/core/analysis/size_span.html">
<link rel="import" href="/core/analysis/table_builder.html">

<polymer-element name="tv-c-single-global-memory-dump-sub-view"
    extends="tracing-analysis-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
    }
    </style>
    <tracing-analysis-nested-table id="table">
    </tracing-analysis-nested-table>
  </template>
  <script>
  'use strict';

  Polymer({
    created: function() {
      this.currentSelection_ = undefined;
    },

    set selection(selection) {
      if (selection.length !== 1)
        throw new Error('Only supports a single global memory dump');
      if (!(selection[0] instanceof tv.c.trace_model.GlobalMemoryDump))
        throw new Error('Only supports global memory dumps');
      this.setSelectionWithoutErrorChecks(selection);
    },

    get selection() {
      return this.currentSelection_;
    },

    setSelectionWithoutErrorChecks: function(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    updateContents_: function() {
      var selection = this.currentSelection_;

      var pidToProcessMemoryDump;
      if (selection)
        pidToProcessMemoryDump = selection[0].processMemoryDumps;
      else
        pidToProcessMemoryDump = {};

      var rows = [];
      tv.b.iterItems(pidToProcessMemoryDump, function(pid, processMemoryDump) {
        var allocatorObjectSizes = {};
        if (processMemoryDump.memoryAllocatorDumps !== undefined) {
          processMemoryDump.memoryAllocatorDumps.forEach(function(dump) {
            allocatorObjectSizes[dump.fullName] =
                dump.allocatedObjectsSizeInBytes;
          }, this);
        }
        rows.push({
          title: processMemoryDump.process.userFriendlyName,
          proportionalResident:
              processMemoryDump.totalProportionalResidentSizeInBytes,
          privateResident:
              processMemoryDump.totalPrivateResidentSizeInBytes,
          sharedResident:
              processMemoryDump.totalSharedResidentSizeInBytes,
          allocatorObjectSizes:
              allocatorObjectSizes
        });
      }, this);
      this.$.table.tableRows = rows;

      this.updateColumns_(rows);

      this.$.table.rebuild();
    },

    updateColumns_: function(rows) {
      function createResidentSizeColumn(title, rowKey) {
        return {
          title: title,
          value: function(row) {
            // TODO(petrcermak): Show the most recently measured size instead
            // of '<unknown>'.
            var size = row[rowKey];
            if (size === undefined)
              return '<unknown>';
            var sizeEl = document.createElement('tv-c-a-size-span');
            sizeEl.numBytes = size;
            return sizeEl;
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            var sizeA = rowA[rowKey];
            var sizeB = rowB[rowKey];
            if (sizeA === undefined && sizeB === undefined)
              return 0;
            if (sizeA === undefined)
              return -1;
            if (sizeB === undefined)
              return 1;
            return sizeA - sizeB;
          }
        };
      }

      var columns = [
        {
          title: 'Process',
          value: function(row) {
            return row.title;
          },
          width: '350px',
          cmp: function(rowA, rowB) {
            return rowA.title.localeCompare(rowB.title);
          }
        },
        createResidentSizeColumn(
            'Proportional Set Size', 'proportionalResident'),
        createResidentSizeColumn(
            'Private Memory', 'privateResident'),
        createResidentSizeColumn(
            'Shared Memory', 'sharedResident')
      ];

      var instrumentedAllocators = {};
      rows.forEach(function(row) {
        tv.b.iterItems(row.allocatorObjectSizes, function(allocatorName, size) {
          instrumentedAllocators[allocatorName] = true;
        }, this);
      }, this);

      tv.b.iterItems(instrumentedAllocators, function(allocatorName) {
        columns.push({
          title: allocatorName,
          value: function(row) {
            // TODO(petrcermak): Show the most recently measured size instead
            // of '<unknown>'.
            var size = row.allocatorObjectSizes[allocatorName];
            if (size === undefined)
              return '<unknown>';
            var sizeEl = document.createElement('tv-c-a-size-span');
            sizeEl.numBytes = size;
            return sizeEl;
          },
          width: '<upated further down>',
          cmp: function(rowA, rowB) {
            // TODO(petrcermak): Reduce duplication by sharing code with the
            // cmp function inside createResidentSizeColumn. This will not be
            // necessary once we show the most recently measured size instead
            // of '<unknown>'.
            var sizeA = rowA.allocatorObjectSizes[allocatorName];
            var sizeB = rowB.allocatorObjectSizes[allocatorName];
            if (sizeA === undefined && sizeB === undefined)
              return 0;
            if (sizeA === undefined)
              return -1;
            if (sizeB === undefined)
              return 1;
            return sizeA - sizeB;
          }
        });
      }, this);

      var columnWidth = (100 / (columns.length - 1)).toFixed(3) + '%';
      for (var i = 1; i < columns.length; i++)
        columns[i].width = columnWidth;

      this.$.table.tableColumns = columns;
    }
  });
  </script>
</polymer>
