<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/test_utils.html">
<link rel="import" href="/core/trace_model/attribute.html">

<script>
'use strict';

tv.b.unittest.testSuite(function() {
  var Attribute = tv.c.trace_model.Attribute;
  var ScalarAttribute = tv.c.trace_model.ScalarAttribute;
  var BytesAttribute = tv.c.trace_model.BytesAttribute;
  var UnknownAttribute = tv.c.trace_model.UnknownAttribute;

  test('findCommonConstructor', function() {
    // Empty list.
    var constructor = Attribute.findCommonConstructor([]);
    assert.isUndefined(constructor);

    // List containing no defined attribute values.
    var constructor = Attribute.findCommonConstructor([undefined, undefined]);
    assert.isUndefined(constructor);

    // Singleton list.
    var constructor = Attribute.findCommonConstructor([new BytesAttribute(24)]);
    assert.strictEqual(constructor, BytesAttribute);

    // Long list.
    var constructor = Attribute.findCommonConstructor([
      undefined,
      new ScalarAttribute(15),
      new ScalarAttribute(16),
      undefined,
      new ScalarAttribute(17),
      undefined
    ]);
    assert.strictEqual(constructor, ScalarAttribute);

    // List containing attribute values of different types.
    var constructor = Attribute.findCommonConstructor([
      new ScalarAttribute(15),
      undefined,
      new BytesAttribute(16)
    ]);
    assert.strictEqual(constructor, UnknownAttribute);
  });

  test('aggregate', function() {
    // No parent or children.
    var aggregatedAttr = Attribute.aggregate([], undefined);
    assert.isUndefined(aggregatedAttr);

    // No parent, children with a single type.
    var aggregatedAttr = Attribute.aggregate([
      undefined,
      new BytesAttribute(128),
      undefined,
      new BytesAttribute(64),
      undefined
    ], undefined);
    assert.isDefined(aggregatedAttr);
    assert.equal(aggregatedAttr.value, 192);
    assert.instanceOf(aggregatedAttr, BytesAttribute);

    // No parent, children with a single type.
    var aggregatedAttr = Attribute.aggregate([
      undefined,
      new BytesAttribute(128),
      undefined,
      new BytesAttribute(64),
      undefined
    ], undefined);
    assert.isDefined(aggregatedAttr);
    assert.equal(aggregatedAttr.value, 192);
    assert.instanceOf(aggregatedAttr, BytesAttribute);

    // No parent, children with multiple types.
    var aggregatedAttr = Attribute.aggregate([
      new BytesAttribute(128),
      new ScalarAttribute(64)
    ], undefined);
    assert.isUndefined(aggregatedAttr);

    // Defined parent, no children.
    var aggregatedAttr = Attribute.aggregate([], new ScalarAttribute(-12));
    assert.isDefined(aggregatedAttr);
    assert.equal(aggregatedAttr.value, -12);
    assert.instanceOf(aggregatedAttr, ScalarAttribute);

    // Defined parent, children with the same type.
    var aggregatedAttr = Attribute.aggregate([
      new ScalarAttribute(110),
      new ScalarAttribute(13)
    ], new ScalarAttribute(-123));
    assert.isDefined(aggregatedAttr);
    assert.equal(aggregatedAttr.value, -123);
    assert.instanceOf(aggregatedAttr, ScalarAttribute);

    // Defined parent, children with a different type.
    var aggregatedAttr = Attribute.aggregate([
      new BytesAttribute(640),
      new BytesAttribute(640)
    ], new ScalarAttribute(-1234));
    assert.isDefined(aggregatedAttr);
    assert.equal(aggregatedAttr.value, -1234);
    assert.instanceOf(aggregatedAttr, ScalarAttribute);

    // Defined parent, children with multiple types.
    var aggregatedAttr = Attribute.aggregate([
      new ScalarAttribute(999),
      new BytesAttribute(640)
    ], new ScalarAttribute(-12345));
    assert.isDefined(aggregatedAttr);
    assert.equal(aggregatedAttr.value, -12345);
    assert.instanceOf(aggregatedAttr, ScalarAttribute);
  });

  test('useMergedAttribute', function() {
    var importWarningCallbackFired;
    var model = {
      importWarning: function() {
        importWarningCallbackFired = true;
      }
    };

    // Same type.
    var attr = new ScalarAttribute(42);
    importWarningCallbackFired = false;
    attr.useMergedAttribute(new ScalarAttribute(24), model);
    assert.isFalse(importWarningCallbackFired);

    // Different type.
    var attr = new ScalarAttribute(42);
    importWarningCallbackFired = false;
    attr.useMergedAttribute(new BytesAttribute(24), model);
    assert.isTrue(importWarningCallbackFired);
  });

  test('scalar_construct', function() {
    var attr = new ScalarAttribute(1024);
    assert.equal(attr.value, 1024);
  });

  test('scalar_fromDict', function() {
    var attr = Attribute.fromDictIfPossible({type: 'scalar', value: '400'});
    assert.isDefined(attr);
    assert.equal(attr.value, 1024);
    assert.instanceOf(attr, ScalarAttribute);
  });

  test('scalar_merge', function() {
    var mergedAttr = ScalarAttribute.merge([
      new ScalarAttribute(10),
      new ScalarAttribute(20),
      new ScalarAttribute(-3)
    ]);
    assert.isDefined(mergedAttr);
    assert.equal(mergedAttr.value, 27);
    assert.instanceOf(mergedAttr, ScalarAttribute);
  });

  test('bytes_construct', function() {
    var attr = new BytesAttribute(1024);
    assert.equal(attr.value, 1024);
  });

  test('bytes_fromDict', function() {
    var attr = Attribute.fromDictIfPossible({type: 'bytes', value: '400'});
    assert.isDefined(attr);
    assert.equal(attr.value, 1024);
    assert.instanceOf(attr, BytesAttribute);
  });

  test('bytes_merge', function() {
    var mergedAttr = BytesAttribute.merge([
      new BytesAttribute(1024),
      new BytesAttribute(0),
      new BytesAttribute(2048)
    ]);
    assert.isDefined(mergedAttr);
    assert.equal(mergedAttr.value, 3072);
    assert.instanceOf(mergedAttr, BytesAttribute);
  });

  test('unknown_construct', function() {
    var attr = new UnknownAttribute('fail');
    assert.equal(attr.value, 'fail');
  });

  test('unknown_fromDict', function() {
    // Missing type.
    var attr = Attribute.fromDictIfPossible({value: '[]'});
    assert.isDefined(attr);
    assert.equal(attr.value, '[]');
    assert.instanceOf(attr, UnknownAttribute);

    // Non-existent type.
    var attr = Attribute.fromDictIfPossible({type: 'hashmap', value: '{}'});
    assert.isDefined(attr);
    assert.equal(attr.value, '{}');
    assert.instanceOf(attr, UnknownAttribute);
  });
});
</script>
