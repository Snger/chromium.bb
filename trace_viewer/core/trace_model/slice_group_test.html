<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/core/test_utils.html">
<link rel="import" href="/core/trace_model/slice_group.html">
<link rel="import" href="/core/trace_model/trace_model.html">

<script>
'use strict';

tv.b.unittest.testSuite(function() {
  var Slice = tv.c.trace_model.Slice;
  var SliceGroup = tv.c.trace_model.SliceGroup;
  var newSlice = tv.c.test_utils.newSlice;
  var newSliceNamed = tv.c.test_utils.newSliceNamed;

  test('basicBeginEnd', function() {
    var group = new SliceGroup({});
    assert.equal(group.openSliceCount, 0);
    var sliceA = group.beginSlice('', 'a', 1, {a: 1});
    assert.equal(1, group.openSliceCount);
    assert.equal('a', sliceA.title);
    assert.equal(1, sliceA.start);
    assert.equal(1, sliceA.args.a);

    var sliceB = group.endSlice(3);
    assert.equal(sliceA, sliceB);
    assert.equal(2, sliceB.duration);
  });

  test('subSlicesBuilderBasic', function() {
    var group = new SliceGroup({});
    var sA = group.pushSlice(newSliceNamed('a', 1, 2));
    var sB = group.pushSlice(newSliceNamed('b', 3, 1));

    group.createSubSlices();

    assert.equal(2, group.topLevelSlices.length);
    assert.deepEqual([sA, sB], group.topLevelSlices);
  });

  test('subSlicesBuilderBasic2', function() {
    var group = new SliceGroup({});
    var sA = group.pushSlice(newSliceNamed('a', 1, 4));
    var sB = group.pushSlice(newSliceNamed('b', 3, 1));

    group.createSubSlices();

    assert.equal(1, group.topLevelSlices.length);
    assert.deepEqual([sA], group.topLevelSlices);

    assert.equal(1, sA.subSlices.length);
    assert.deepEqual([sB], sA.subSlices);
    assert.equal(3, sA.selfTime);

    assert.equal(sB.parentSlice, sA);
  });

  test('subSlicesBuilderNestedExactly', function() {
    var group = new SliceGroup({});
    var sB = group.pushSlice(newSliceNamed('b', 1, 4));
    var sA = group.pushSlice(newSliceNamed('a', 1, 4));

    group.createSubSlices();

    assert.equal(1, group.topLevelSlices.length);
    assert.deepEqual([sB], group.topLevelSlices);

    assert.equal(1, sB.subSlices.length);
    assert.deepEqual([sA], sB.subSlices);
    assert.equal(0, sB.selfTime);

    assert.equal(sA.parentSlice, sB);
  });

  test('subSlicesBuilderInstantEvents', function() {
    var group = new SliceGroup({});
    var sA = group.pushSlice(newSliceNamed('a', 1, 0));
    var sB = group.pushSlice(newSliceNamed('b', 2, 0));

    group.createSubSlices();

    assert.equal(2, group.topLevelSlices.length);
    assert.deepEqual([sA, sB], group.topLevelSlices);
  });

  test('subSlicesBuilderTwoInstantEvents', function() {
    var group = new SliceGroup({});
    var sA = group.pushSlice(newSliceNamed('a', 1, 0));
    var sB = group.pushSlice(newSliceNamed('b', 1, 0));

    group.createSubSlices();

    assert.equal(1, group.topLevelSlices.length);
    assert.deepEqual([sA], group.topLevelSlices);

    assert.equal(1, sA.subSlices.length);
    assert.deepEqual([sB], sA.subSlices);
    assert.equal(0, sA.selfTime);

    assert.equal(sB.parentSlice, sA);
  });

  test('subSlicesBuilderOutOfOrderAddition', function() {
    var group = new SliceGroup({});

    // Pattern being tested:
    // [    a     ][   b   ]
    // Where insertion is done backward.
    var sB = group.pushSlice(newSliceNamed('b', 3, 1));
    var sA = group.pushSlice(newSliceNamed('a', 1, 2));

    group.createSubSlices();

    assert.equal(2, group.topLevelSlices.length);
    assert.deepEqual([sA, sB], group.topLevelSlices);
  });

  test('subRowBuilderOutOfOrderAddition2', function() {
    var group = new SliceGroup({});

    // Pattern being tested:
    // [    a     ]
    //   [  b   ]
    // Where insertion is done backward.
    var sB = group.pushSlice(newSliceNamed('b', 3, 1));
    var sA = group.pushSlice(newSliceNamed('a', 1, 5));

    group.createSubSlices();

    assert.equal(1, group.topLevelSlices.length);
    assert.deepEqual([sA], group.topLevelSlices);

    assert.equal(1, sA.subSlices.length);
    assert.deepEqual([sB], sA.subSlices);
    assert.equal(4, sA.selfTime);

    assert.equal(sB.parentSlice, sA);
  });

  test('subSlicesBuilderOnNestedZeroLength', function() {
    var group = new SliceGroup({});

    // Pattern being tested:
    // [    a    ]
    // [  b1 ]  []<- b2 where b2.duration = 0 and b2.end == a.end.
    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB1 = group.pushSlice(newSliceNamed('b1', 1, 2));
    var sB2 = group.pushSlice(newSliceNamed('b2', 4, 0));

    group.createSubSlices();

    assert.equal(1, group.topLevelSlices.length);
    assert.deepEqual([sA], group.topLevelSlices);

    assert.equal(2, sA.subSlices.length);
    assert.deepEqual([sB1, sB2], sA.subSlices);
    assert.equal(1, sA.selfTime);

    assert.equal(sB1.parentSlice, sA);
    assert.equal(sB2.parentSlice, sA);
  });

  test('subSlicesBuilderOnGroup1', function() {
    var group = new SliceGroup({});

    // Pattern being tested:
    // [    a     ]   [  c   ]
    //   [  b   ]
    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB = group.pushSlice(newSliceNamed('b', 1.5, 1));
    var sC = group.pushSlice(newSliceNamed('c', 5, 0));

    group.createSubSlices();

    assert.equal(2, group.topLevelSlices.length);
    assert.deepEqual([sA, sC], group.topLevelSlices);

    assert.equal(1, sA.subSlices.length);
    assert.deepEqual([sB], sA.subSlices);
    assert.equal(2, sA.selfTime);

    assert.equal(sB.parentSlice, sA);
  });

  test('subSlicesBuilderOnGroup2', function() {
    var group = new SliceGroup({});

    // Pattern being tested:
    // [    a     ]   [  d   ]
    //   [  b   ]
    //    [ c ]
    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB = group.pushSlice(newSliceNamed('b', 1.5, 1));
    var sC = group.pushSlice(newSliceNamed('c', 1.75, 0.5));
    var sD = group.pushSlice(newSliceNamed('d', 5, 0.25));

    group.createSubSlices();

    assert.equal(2, group.topLevelSlices.length);
    assert.deepEqual([sA, sD], group.topLevelSlices);

    assert.equal(1, sA.subSlices.length);
    assert.deepEqual([sB], sA.subSlices);
    assert.equal(2, sA.selfTime);

    assert.equal(sB.parentSlice, sA);
    assert.equal(1, sB.subSlices.length);
    assert.deepEqual([sC], sB.subSlices);
    assert.equal(0.5, sB.selfTime);

    assert.equal(sC.parentSlice, sB);
  });

  test('subSlicesBuilderTolerateFPInaccuracy', function() {
    var group = new SliceGroup({});

    // Pattern being tested:
    // [  a  ]
    // [  b  ] where b.end contains a tiny FP calculation error.
    var sA = group.pushSlice(newSliceNamed('a', 1, 3));
    var sB = group.pushSlice(newSliceNamed('b', 1, 3.0000000001));

    group.createSubSlices();

    assert.equal(1, group.topLevelSlices.length);
    assert.deepEqual([sA], group.topLevelSlices);

    assert.equal(1, sA.subSlices.length);
    assert.deepEqual([sB], sA.subSlices);
    assert.equal(sB.parentSlice, sA);
  });

  test('basicMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 1);
    a.endSlice(2);
    b.beginSlice('', 'two', 3);
    b.endSlice(5);

    var m = SliceGroup.merge(a, b);
    assert.equal(2, m.slices.length);

    assert.equal('one', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(1, m.slices[0].duration);

    assert.equal('two', m.slices[1].title);
    assert.equal(3, m.slices[1].start);
    assert.equal(2, m.slices[1].duration);
  });

  test('nestedMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 1);
    a.endSlice(4);
    b.beginSlice('', 'two', 2);
    b.endSlice(3);

    var m = SliceGroup.merge(a, b);
    assert.equal(2, m.slices.length);

    assert.equal('one', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(3, m.slices[0].duration);

    assert.equal('two', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(1, m.slices[1].duration);
  });

  test('startSplitMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 2);
    a.endSlice(4);
    b.beginSlice('', 'two', 1);
    b.endSlice(3);

    var m = SliceGroup.merge(a, b);
    assert.equal(3, m.slices.length);

    assert.equal('two', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(1, m.slices[0].duration);

    assert.equal('one', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(2, m.slices[1].duration);

    assert.equal('two (cont.)', m.slices[2].title);
    assert.equal(2, m.slices[2].start);
    assert.equal(1, m.slices[2].duration);
  });

  test('startSplitTwoMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 3);
    a.endSlice(6);
    b.beginSlice('', 'two', 1);
    b.beginSlice('', 'three', 2);
    b.endSlice(4);
    b.endSlice(5);

    var m = SliceGroup.merge(a, b);
    assert.equal(5, m.slices.length);

    assert.equal('two', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(2, m.slices[0].duration);

    assert.equal('three', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(1, m.slices[1].duration);

    assert.equal('one', m.slices[2].title);
    assert.equal(3, m.slices[2].start);
    assert.equal(3, m.slices[2].duration);

    assert.equal('two (cont.)', m.slices[3].title);
    assert.equal(3, m.slices[3].start);
    assert.equal(2, m.slices[3].duration);

    assert.equal('three (cont.)', m.slices[4].title);
    assert.equal(3, m.slices[4].start);
    assert.equal(1, m.slices[4].duration);
  });

  test('startSplitTwiceMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 2);
    a.beginSlice('', 'two', 3);
    a.endSlice(5);
    a.endSlice(6);
    b.beginSlice('', 'three', 1);
    b.endSlice(4);

    var m = SliceGroup.merge(a, b);
    assert.equal(5, m.slices.length);

    assert.equal('three', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(1, m.slices[0].duration);

    assert.equal('one', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(4, m.slices[1].duration);

    assert.equal('three (cont.)', m.slices[2].title);
    assert.equal(2, m.slices[2].start);
    assert.equal(1, m.slices[2].duration);

    assert.equal('two', m.slices[3].title);
    assert.equal(3, m.slices[3].start);
    assert.equal(2, m.slices[3].duration);

    assert.equal('three (cont.)', m.slices[4].title);
    assert.equal(3, m.slices[4].start);
    assert.equal(1, m.slices[4].duration);
  });

  test('endSplitMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 1);
    a.endSlice(3);
    b.beginSlice('', 'two', 2);
    b.endSlice(4);

    var m = SliceGroup.merge(a, b);
    assert.equal(3, m.slices.length);

    assert.equal('one', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(2, m.slices[0].duration);

    assert.equal('two', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(1, m.slices[1].duration);

    assert.equal('two (cont.)', m.slices[2].title);
    assert.equal(3, m.slices[2].start);
    assert.equal(1, m.slices[2].duration);
  });

  test('endSplitTwoMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 1);
    a.endSlice(4);
    b.beginSlice('', 'two', 2);
    b.beginSlice('', 'three', 3);
    b.endSlice(5);
    b.endSlice(6);

    var m = SliceGroup.merge(a, b);
    assert.equal(5, m.slices.length);

    assert.equal('one', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(3, m.slices[0].duration);

    assert.equal('two', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(2, m.slices[1].duration);

    assert.equal('three', m.slices[2].title);
    assert.equal(3, m.slices[2].start);
    assert.equal(1, m.slices[2].duration);

    assert.equal('two (cont.)', m.slices[3].title);
    assert.equal(4, m.slices[3].start);
    assert.equal(2, m.slices[3].duration);

    assert.equal('three (cont.)', m.slices[4].title);
    assert.equal(4, m.slices[4].start);
    assert.equal(1, m.slices[4].duration);
  });

  test('endSplitTwiceMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 1);
    a.beginSlice('', 'two', 2);
    a.endSlice(4);
    a.endSlice(5);
    b.beginSlice('', 'three', 3);
    b.endSlice(6);

    var m = SliceGroup.merge(a, b);
    assert.equal(5, m.slices.length);

    assert.equal('one', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(4, m.slices[0].duration);

    assert.equal('two', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(2, m.slices[1].duration);

    assert.equal('three', m.slices[2].title);
    assert.equal(3, m.slices[2].start);
    assert.equal(1, m.slices[2].duration);

    assert.equal('three (cont.)', m.slices[3].title);
    assert.equal(4, m.slices[3].start);
    assert.equal(1, m.slices[3].duration);

    assert.equal('three (cont.)', m.slices[4].title);
    assert.equal(5, m.slices[4].start);
    assert.equal(1, m.slices[4].duration);
  });

  // Input:
  // A:  |    one     |       |     two     |
  //
  // B:       |         three         |
  //
  // Output:
  //     |    one     | three |     two     |
  //          | three |       | three |
  test('splitTwiceMerge', function() {
    var thread = {};
    var a = new SliceGroup(thread);
    var b = new SliceGroup(thread);
    a.beginSlice('', 'one', 1);
    a.endSlice(3);
    a.beginSlice('', 'two', 4);
    a.endSlice(6);
    b.beginSlice('', 'three', 2);
    b.endSlice(5);

    var m = SliceGroup.merge(a, b);
    assert.equal(5, m.slices.length);

    assert.equal('one', m.slices[0].title);
    assert.equal(1, m.slices[0].start);
    assert.equal(2, m.slices[0].duration);

    assert.equal('three', m.slices[1].title);
    assert.equal(2, m.slices[1].start);
    assert.equal(1, m.slices[1].duration);

    assert.equal('three (cont.)', m.slices[2].title);
    assert.equal(3, m.slices[2].start);
    assert.equal(1, m.slices[2].duration);

    assert.equal('two', m.slices[3].title);
    assert.equal(4, m.slices[3].start);
    assert.equal(2, m.slices[3].duration);

    assert.equal('three (cont.)', m.slices[4].title);
    assert.equal(4, m.slices[4].start);
    assert.equal(1, m.slices[4].duration);
  });

  test('bounds', function() {
    var group = new SliceGroup({});
    group.updateBounds();
    assert.equal(group.bounds.min, undefined);
    assert.equal(group.bounds.max, undefined);

    group.pushSlice(newSlice(1, 3));
    group.pushSlice(newSlice(7, 2));
    group.updateBounds();
    assert.equal(1, group.bounds.min);
    assert.equal(9, group.bounds.max);
  });

  test('boundsWithPartial', function() {
    var group = new SliceGroup({});
    group.beginSlice('', 'a', 7);
    group.updateBounds();
    assert.equal(7, group.bounds.min);
    assert.equal(7, group.bounds.max);
  });

  test('boundsWithTwoPartials', function() {
    var group = new SliceGroup({});
    group.beginSlice('', 'a', 0);
    group.beginSlice('', 'a', 1);
    group.updateBounds();
    assert.equal(0, group.bounds.min);
    assert.equal(1, group.bounds.max);
  });

  test('boundsWithBothPartialAndRegular', function() {
    var group = new SliceGroup({});
    group.updateBounds();
    assert.equal(undefined, group.bounds.min);
    assert.equal(undefined, group.bounds.max);

    group.pushSlice(newSlice(1, 3));
    group.beginSlice('', 'a', 7);
    group.updateBounds();
    assert.equal(1, group.bounds.min);
    assert.equal(7, group.bounds.max);
  });

  test('autocloserBasic', function() {
    var group = new SliceGroup({});
    assert.equal(group.openSliceCount, 0);

    group.pushSlice(newSliceNamed('a', 1, 0.5));

    group.beginSlice('', 'b', 2);
    group.beginSlice('', 'c', 2.5);
    group.endSlice(3);

    group.autoCloseOpenSlices();
    group.updateBounds();

    assert.equal(1, group.bounds.min);
    assert.equal(3, group.bounds.max);
    assert.equal(3, group.slices.length);

    assert.equal('a', group.slices[0].title);
    assert.isFalse(group.slices[0].didNotFinish);

    assert.equal('b', group.slices[1].title);
    assert.isTrue(group.slices[1].didNotFinish);
    assert.equal(1, group.slices[1].duration);

    assert.equal('c', group.slices[2].title);
    assert.isFalse(group.slices[2].didNotFinish);
  });

  test('autocloserWithSubTasks', function() {
    var group = new SliceGroup({});
    assert.equal(group.openSliceCount, 0);

    group.beginSlice('', 'a', 1);
    group.beginSlice('', 'b1', 2);
    group.endSlice(3);
    group.beginSlice('', 'b2', 3);

    group.autoCloseOpenSlices();
    assert.equal(3, group.slices.length);

    assert.equal('a', group.slices[0].title);
    assert.isTrue(group.slices[0].didNotFinish);
    assert.equal(2, group.slices[0].duration);

    assert.equal('b1', group.slices[1].title);
    assert.isFalse(group.slices[1].didNotFinish);
    assert.equal(1, group.slices[1].duration);

    assert.equal('b2', group.slices[2].title);
    assert.isTrue(group.slices[2].didNotFinish);
    assert.equal(0, group.slices[2].duration);
  });

  test('autocloseCompleteSlice', function() {
    var group = new SliceGroup({});

    group.pushCompleteSlice('', 'a', 1, undefined);
    group.pushCompleteSlice('', 'b', 2, 3);

    group.autoCloseOpenSlices();
    assert.equal(2, group.slices.length);

    assert.equal('a', group.slices[0].title);
    assert.isTrue(group.slices[0].didNotFinish);
    assert.equal(4, group.slices[0].duration);

    assert.equal('b', group.slices[1].title);
    assert.isFalse(group.slices[1].didNotFinish);
    assert.equal(3, group.slices[1].duration);
  });

  test('sliceGroupStableId', function() {
    var model = new tv.c.TraceModel();
    var process = model.getOrCreateProcess(123);
    var thread = process.getOrCreateThread(456);
    var group = new SliceGroup(thread);

    assert.equal(123, process.stableId);
    assert.equal('123.456', thread.stableId);
    assert.equal('123.456.SliceGroup', group.stableId);
  });

  test('getSlicesOfName', function() {
    var group = new SliceGroup({});
    var expected = [];

    for (var i = 0; i < 10; i++) {
      var aSlice = newSliceNamed('a', i, i + 1);
      group.pushSlice(aSlice);
      group.pushSlice(newSliceNamed('b', i + 1, i + 2));
      expected.push(aSlice);
    }

    assert.deepEqual(expected, group.getSlicesOfName('a'));
  });
});
</script>

