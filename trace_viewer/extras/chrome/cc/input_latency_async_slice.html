<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/core/trace_model/async_slice.html">
<link rel="import" href="/extras/chrome/chrome_model_helper.html">

<script>
'use strict';

tr.exportTo('tr.e.cc', function() {
  var AsyncSlice = tr.c.trace_model.AsyncSlice;

  var UI_COMP_NAME = 'INPUT_EVENT_LATENCY_UI_COMPONENT';
  var ORIGINAL_COMP_NAME = 'INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';
  var BEGIN_COMP_NAME = 'INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';
  var END_COMP_NAME = 'INPUT_EVENT_LATENCY_TERMINATED_FRAME_SWAP_COMPONENT';

  function InputLatencyAsyncSlice() {
    AsyncSlice.apply(this, arguments);
    this.associatedEvents_ = undefined;
  }

  InputLatencyAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    getRendererHelper: function() {
      var traceModel = this.startThread.parent.model;
      if (tv.e.audits.ChromeModelHelper.supportsModel(traceModel)) {
        var modelHelper = new tv.e.audits.ChromeModelHelper(traceModel);
        var rendererHelpers = modelHelper.rendererHelpers;

        // Assuming we only have one renderer process for now.
        // It's totally possible that there are multiple tabs open when
        // users collect the trace file. The logic would be pretty hairy.
        return rendererHelpers[Object.keys(rendererHelpers)[0]];
      }

      return undefined;
    },

    constructFlowPath: function(flowEvents) {
      var flowPath = [];

      flowEvents.forEach(function(flowEvent) {
        flowPath.push(flowEvent.startSlice.mostTopLevelSlice);
      }, this);
      var lastFlowEvent = flowEvents[flowEvents.length - 1];
      flowPath.push(lastFlowEvent.endSlice.mostTopLevelSlice);

      return flowPath;
    },

    addDirectlyAssociatedEvents: function(eventGUIDs, flowEvents) {
      flowEvents.forEach(function(flowEvent, index, matchedFlowEvents) {
        this.associatedEvents_.push(flowEvent);

        flowEvent.startSlice.ancestorAndSubsequentSlices.forEach(function(s) {
          if (!eventGUIDs[s.guid]) {
            this.associatedEvents_.push(s);
            eventGUIDs[s.guid] = true;
          }
        }, this);
      }, this);

      // Only process the endSlice for the last flowEvent
      // this is assuming flowEvents are always followable
      var lastFlowEvent = flowEvents[flowEvents.length - 1];
      lastFlowEvent.endSlice.ancestorAndSubsequentSlices.forEach(function(s) {
        if (!eventGUIDs[s.guid]) {
          this.associatedEvents_.push(s);
          eventGUIDs[s.guid] = true;
        }
      }, this);
    },

    findFirstRendererSlice: function(flowPath) {
      for (var i in flowPath) {
        if (flowPath[i].parentThread.name === 'CrRendererMain')
          return flowPath[i];
      }

      return undefined;
    },

    findLastRendererSlice: function(flowPath) {
      for (var i in flowPath) {
        // TODO (Yuhao): Is there a more general method?
        // If we could trace the renderer commit, it would make this part of
        // implementation much cleaner
        var commitMaker = 'Scheduler::OnBeginImplFrameDeadline';
        if (flowPath[i].findDescendentSlice(commitMaker))
          return flowPath[i];
      }

      return flowPath[flowPath.length - 1];
    },

    getSlicesBetweenFirstAndLast: function(eventGUIDs, firstSlice,
        lastSlice, rendererHelper) {
      var started = false;

      var allRendererSlices = rendererHelper.mainThread.sliceGroup.slices;
      for (var i in allRendererSlices) {
        var slice = allRendererSlices[i];

        if (slice.end > lastSlice.start)
          break;

        if (started) {
          // If we see another handleInputMaker inbetween the first and last
          // renderer slice, it is mostly likely (counter-example??) responsible
          // for another input and needs to be excluded.
          var handleInputMarker = 'WebViewImpl::handleInputEvent';
          if (slice.mostTopLevelSlice.findDescendentSlice(handleInputMarker))
            continue;

          if (!eventGUIDs[slice.guid]) {
            this.associatedEvents_.push(slice);
            eventGUIDs[slice.guid] = true;
          }
        }
        else
          started = (slice.guid === firstSlice.guid);
      }
    },

    // Find the Latency::ScrollUpdate slice that started between the start
    // and end of InputLatency::GestureScrollUpdate
    getScrollUpdateEvents: function(compositorThread) {
      var gestureScrollUpdateStart = this.start;
      var gestureScrollUpdateEnd = this.end;

      var allCompositorAsyncSlices =
        compositorThread.asyncSliceGroup.slices;

      for (var i in allCompositorAsyncSlices) {
        var slice = allCompositorAsyncSlices[i];

        if (slice.start >= gestureScrollUpdateStart &&
            slice.start < gestureScrollUpdateEnd) {
          // Found Latency::ScrollUpdate; push all its associatedEvents
          slice.associatedEvents.forEach(function(event) {
            this.associatedEvents_.push(event);
          }, this);
          break;
        }
      }
    },

    addOtherCasuallyRelatedEvents: function(eventGUIDs, flowEvents) {
      var rendererHelper = this.getRendererHelper();

      if (rendererHelper === undefined ||
          rendererHelper.mainThread === undefined)
        return;

      var flowPath = this.constructFlowPath(flowEvents);

      // Find the first renderer slice from the flow path. It might not
      // exist because some inputs (e.g., scroll update) are
      //  1) taken over by the compositor and thus bypass the renderer,
      //  2) directly consumed by the browser process..
      var firstRendererSlice = this.findFirstRendererSlice(flowPath);

      if (firstRendererSlice === undefined) {
        // Scroll update doesn't go through the main thread, but the compositor
        // may go back to the main thread if there is an onscrolle event handler
        // This is captured by a different flow event, which does not have the
        // same ID as the Input Latency Event, but it is technically casually
        // related to the GestureScrollUpdate input. Add them manually for now.
        var latencyScrollUpdateMaker = 'InputLatency::GestureScrollUpdate';
        if (this.title === latencyScrollUpdateMaker)
          this.getScrollUpdateEvents(rendererHelper.compositorThread);

        return;
      }

      // If the first renderer slice exist, we look for the last renderer slice.
      // There are two cases:
      //  1) the slice that commits to the compositor thread
      //  2) renderer didn't commit, then for now we fall back to the last slice
      //  in the flow path (which might not be a renderer slice)
      var lastRendererSlice = this.findLastRendererSlice(flowPath);

      // Push relevant slices between first and last slice
      this.getSlicesBetweenFirstAndLast(
          eventGUIDs, firstRendererSlice, lastRendererSlice, rendererHelper);
    },

    get associatedEvents() {
      if (this.associatedEvents_ !== undefined)
        return this.associatedEvents_;

      this.associatedEvents_ = [];
      var traceModelIndices = this.startThread.parent.model.traceModelIndices;
      var flowEvents = traceModelIndices.getFlowEventsWithId(this.id);

      if (flowEvents.length == 0)
        return this.associatedEvents_;

      var eventGUIDs = {};
      // Step 1: Get all the events that are directly connected by the flow
      this.addDirectlyAssociatedEvents(eventGUIDs, flowEvents);

      // Step 2: Get events that are casually related but not connect by flow
      // It only takes care of the main renderer thread for now
      this.addOtherCasuallyRelatedEvents(eventGUIDs, flowEvents);

      return this.associatedEvents_;
    },

    get inputLatency() {
      if (!('data' in this.args))
        return undefined;

      var data = this.args.data;
      if (!(END_COMP_NAME in data))
        return undefined;

      var latency = 0;
      var endTime = data[END_COMP_NAME].time;
      if (ORIGINAL_COMP_NAME in data) {
        latency = endTime - data[ORIGINAL_COMP_NAME].time;
      } else if (UI_COMP_NAME in data) {
        latency = endTime - data[UI_COMP_NAME].time;
      } else if (BEGIN_COMP_NAME in data) {
        latency = endTime - data[BEGIN_COMP_NAME].time;
      } else {
        throw new Error('No valid begin latency component');
      }
      return latency;
    }
  };

  var eventTypeNames = [
    'Char',
    'GestureFlingCancel',
    'GestureFlingStart',
    'GestureScrollBegin',
    'GestureScrollEnd',
    'GestureScrollUpdate',
    'GestureShowPress',
    'GestureTap',
    'GestureTapCancel',
    'GestureTapDown',
    'KeyUp',
    'MouseDown',
    'MouseMove',
    'MouseUp',
    'MouseWheel',
    'RawKeyDown',
    'ScrollUpdate',
    'TouchEnd',
    'TouchMove',
    'TouchStart'
  ];
  var allTypeNames = ['InputLatency'];
  eventTypeNames.forEach(function(eventTypeName) {
    // Old style.
    allTypeNames.push('InputLatency:' + eventTypeName);

    // New style.
    allTypeNames.push('InputLatency::' + eventTypeName);
  });

  AsyncSlice.register(
    InputLatencyAsyncSlice,
    {
      typeNames: allTypeNames,
      categoryParts: ['latencyInfo']
    });

  return {
    InputLatencyAsyncSlice: InputLatencyAsyncSlice
  };
});
</script>
