<!DOCTYPE HTML>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/tracing/base/units/histogram.html">
<link rel="import" href="/tracing/ui/base/dom_helpers.html">
<link rel="import" href="/tracing/ui/base/info_bar_group.html">
<link rel="import" href="/tracing/ui/base/overlay.html">
<link rel="import" href="/tracing/ui/base/table.html">
<link rel="import" href="/tracing/ui/units/histogram_span.html">
<link rel="import" href="/tracing/ui/units/time_duration_span.html">
<link rel="import" href="/perf_insights/results/results.html">
<link rel="import" href="/perf_insights/ui/reports/pi_report.html">
<link rel="import" href="/perf_insights/ui/generic_results_view.html">
<link rel="import" href="/perf_insights/ui/grouping_table.html">
<link rel="import" href="/perf_insights/mappers/reduce.html">
<link rel="import" href="/perf_insights/mappers/slice_cost.html">

<polymer-element name="pi-ui-r-task-info-report"
    extends="pi-ui-r-pi-report"
    map-function-href="/perf_insights/mappers/task_info_map_function.html"
    map-function-name="taskInfoMapFunction">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }
      top-controls {
        display: flex;
        flex: 0 0 auto;
        background-color: rgb(236, 236, 236);
        border-bottom: 1px solid #8e8e8e;
        padding: 4px;
      }
      #table {
        flex: 1 1 auto;
      }
    </style>
    <tr-ui-b-info-bar-group id="infobars"></tr-ui-b-info-bar-group>
    <pi-ui-grouping-table id="table"></pi-ui-grouping-table>
    <h1>Histogram</h1>
    <tr-ui-u-histogram-span id="histogram"></tr-ui-u-histogram-span>
  </template>
  <script>
  'use strict';

  var COLUMN_INFOS = [
    {
      columnHeader: 'Avg. Time in queue',
      type: 'time_spent_in_queue',
      statSetter: function(stat, value) {
        stat.waitTime = value;
      },
      statGetter: function(stat) {
        return stat.waitTime;
      }
    },
    {
      columnHeader: 'Avg. Self time',
      type: 'time_spent_in_top_level_task',
      statSetter: function(stat, value) {
        stat.duration = value;
      },
      statGetter: function(stat) {
        return stat.duration;
      }
    },
    {
      columnHeader: 'Avg. CPU time',
      type: 'cpu_time_spent_in_top_level_task',
      statSetter: function(stat, value) {
        stat.cpuDuration = value;
      },
      statGetter: function(stat) {
        return stat.cpuDuration;
      }
    }
  ];

  Polymer({
    created: function() {
      this.mapResults_ = undefined;
    },

    ready: function() {
      this.$.table.addEventListener('selection-changed',
          function(tableEvent) {
        tableEvent.stopPropagation();
        this.setHistogramBasedOnSelection_();
      }.bind(this));
    },

    get mapResults() {
      return this.mapResults_;
    },

    set mapResults(mapResults) {
      this.mapResults_ = mapResults;
      this.updateContents_();
    },

    updateContents_: function() {
      var table = this.$.table;

      var results = this.mapResults_;
      if (!results)
        results = new tr.r.Results();

      this.$.infobars.clearMessages();
      this.maybeAddFailuresInfoBarMessage_(results);

      var columns = this.createColumns_();
      table.tableColumns = columns;
      table.sortColumnIndex = 3;
      table.sortDescending = true;

      var rows = [];
      results.allValuesFromFailureFreeRuns.forEach(function(result) {
        for (var process in result.value) {
          for (var thread in result.value[process]) {
            rows.push({
              process: process,
              thread: thread,
              type: result.name,
              histogram:
                  tr.b.u.Histogram.fromDict(result.value[process][thread])
            });
          }
        }
      });

      var groupBy = [];
      groupBy.push(function(datum) {
        return datum.process;
      });
      groupBy.push(function(datum) {
        return datum.thread;
      });
      table.supportsSelection = true;
      table.groupBy = groupBy;
      table.groupBy = groupBy;
      table.dataToGroup = rows;
      table.supportsSelection = true;
      table.cellSelectionMode = true;
      table.rowHighlightEnabled = true;
      table.rebuild();
    },

    maybeAddFailuresInfoBarMessage_: function(results) {
      if (!results.hadFailures)
        return;

      function onTellMeMore() {
        var dlg = new tr.ui.b.Overlay();
        dlg.dlg = 'Results summary';

        var grv = document.createElement('pi-ui-generic-results-view');

        grv.mapResults = results;
        grv.style.minHeight = '500px';
        dlg.appendChild(grv);
        dlg.visible = true;
      }

      var numFailedRuns = results.failedRunInfos.length;
      this.$.infobars.addMessage(
          'There were ' + numFailedRuns + ' traces that did not process.',
          [
            {
              buttonText: 'Tell me more...',
              onClick: onTellMeMore
            }
          ]);
    },

    createColumns_: function() {

      function averageFromHistograms(desiredType, datum) {
        var runningSum = 0;
        var numValues = 0;
        datum.forEach(function(data) {
          if (data.type !== desiredType)
            return;
          runningSum += data.histogram.runningSum;
          numValues += data.histogram.numValues;
        });
        if (numValues === 0)
          return 0;
        return runningSum / numValues;
      }

      function getStatsForRow(row) {
        if (row.stats_ === undefined) {
          row.stats_ = {};
          COLUMN_INFOS.forEach(function(info) {
            info.statSetter(row.stats_,
                averageFromHistograms(info.type, row.data));
          });
        }
        return row.stats_;
      }

      var columns = [{
        title: 'Title',
        value: function(row) {
          return row.title;
        },
        cmp: function(a, b) {
          var sA = a.title;
          var sB = b.title;
          if (sA < sB)
            return -1;
          if (sA > sB)
            return 1;
          return 0;
        },
        width: '500px'
      }];

      COLUMN_INFOS.forEach(function(info) {
        columns.push({
          title: info.columnHeader,
          value: function(row) {
            var stat = info.statGetter(getStatsForRow(row));
            if (stat === undefined)
              return;
            return tr.ui.units.createTimeDurationSpan(stat);
          },
          cmp: function(x, y) {
            var sX = info.statGetter(getStatsForRow(x));
            var sY = info.statGetter(getStatsForRow(y));
            return tr.b.comparePossiblyUndefinedValues(sX, sY,
                function(x, y) {
                  return x - y;
                });
          }
        });
      });
      return columns;
    },

    setHistogramBasedOnSelection_: function() {
      var selectedRow = this.$.table.selectedTableRow;
      var selectedColumn = this.$.table.selectedColumnIndex;
      // Don't display a histogram if the user selects the title.
      if (selectedColumn === 0)
        return;

      function getHistogramForRow(row, desiredType) {
        var histogram;
        row.data.forEach(function(data) {
          if (data.type !== desiredType)
            return;
          if (!histogram)
            histogram = data.histogram.clone();
          else
            histogram.addHistogram(data.histogram);
        });
        return histogram;
      }

      var info = COLUMN_INFOS[selectedColumn - 1];
      this.$.histogram.histogram = getHistogramForRow(selectedRow, info.type);
    }

  });
  </script>
</polymer-element>
