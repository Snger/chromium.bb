<!DOCTYPE HTML>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/perf_insights/value/value.html">
<link rel="import" href="/perf_insights/results/progress_reporter.html">
<link rel="import" href="/perf_insights/results/output_formatter.html">

<script>
'use strict';

tr.exportTo('pi.r', function() {
  var ProgressReporter = pi.r.ProgressReporter;

  function Results(opt_output_formatters, opt_progress_reporter) {
    this.output_formatters = opt_output_formatters || [];
    if (!(this.output_formatters instanceof Array))
      throw new Error('output_formatters must be array');

    this.progress_reporter = opt_progress_reporter ||
        new ProgressReporter();
    if (!(this.progress_reporter instanceof ProgressReporter))
      throw new Error('output_formatters must be array');

    this.all_values = [];
    this._run_ids_that_have_failures = {};
  }

  Results.fromDict = function(dict) {
    if (dict.runs === undefined)
      throw new Error('Expected: run_info');
    if (dict.values === undefined)
      throw new Error('Expected: run_info');

    var runInfosById = tr.b.mapItems(dict.runs, function(run_id, dict) {
      return pi.v.RunInfo.fromDict(dict);
    });

    var results = new Results();
    dict.values.forEach(function(valueDict) {
      var runInfo = runInfosById[valueDict.run_id];
      if (runInfo === undefined) {
        debugger;
        throw new Error('run_info not found');
      }
      var value = pi.v.Value.fromDict(runInfo, valueDict);
      results.addValue(value);
    });
    return results;
  }

  Results.prototype = {
    willRun: function(run_info) {
      this.progress_reporter.willRun(run_info);
    },

    addValue: function(value) {
      if (value instanceof pi.v.FailureValue)
        this._run_ids_that_have_failures[value.run_info.run_id] = true;
      this.all_values.push(value);
      this.progress_reporter.didAddValue(value);
    },

    didRun: function(run_info) {
      this.progress_reporter.didRun(run_info);
    },

    didFinishAllRuns: function() {
      this.progress_reporter.didFinishAllRuns();
      this.output_formatters.forEach(function(of) {
        of.format(this);
      }, this);
    },

    get hadFailures() {
      return this.failureValues.length > 0;
    },

    get failureValues() {
      return this.all_values.filter(function(x) {
        return x instanceof pi.v.FailureValue;
      });
    },

    doesRunContainFailure: function(run_info) {
      return this._run_ids_that_have_failures[run_info.run_id] === true;
    },

    get allValuesFromFailureFreeRuns() {
      return this.all_values.filter(function(x) {
        if (this.doesRunContainFailure(x.run_info))
          return false;
        return true;
      }, this);
    },

    getValuesFromFailureFreeRunsNamed: function(name) {
      return this.allValuesFromFailureFreeRuns.filter(function(value) {
        return value.name === name;
      });
    }
  };

  return {
    Results: Results
  };
});
</script>