# -*- python -*-
# Copyright 2010 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can
# be found in the LICENSE file.

Import('env')

# Use of "-nostdlib" means these tests produce statically-linked
# executables.  This does not work with the test runner for
# nacl-glibc, which always runs the executables via ld.so.  However,
# we want to keep building the tests.
# TODO(mseaborn): To fix this, either switch these tests to
# dynamically link against libc, or make use of ld.so optional.
is_glibc = env.Bit('nacl_glibc')

env.Replace(LIBS=[],
            EXTRA_LIBS=[],
            LINKFLAGS=['-nostdlib'],
            TRANSLATEFLAGS=['-nostdlib'])

# This setting will affect the barebones_regs.c test
if env.Bit('build_arm'):
  env.Append(CPPDEFINES='SMALL_REGS_TEST')


# NOTE: the x86 linker wants _start() to be the very first function
FAKE_STARTUP = env.ComponentObject('fake_startup', 'fake_startup.c')

barebones_tests = ['addr_modes',
                   'stack_alignment8',
                   'stack_alignment16',
                   'exit',
                   'fib',
                   'hello_world',
                   'negindex',
                   'only_bss',
                   'regs',
                   'reloc',
                   'switch',
                   'vtable',
                   'vaarg',
                   ]

for basename in barebones_tests:
  # TODO(kcc): the barebones tests confuse the current nacl-ified valgrind.
  if env.IsRunningUnderValgrind(): continue
  # NOTE: the expected alignments are described via NACL_STACK_ALIGN_MASK in
  # src/trusted/service_runtime/nacl_config.h
  # For x86-32 and x86-64 we currently rely on startup code (crt1_*)
  # to fix the stack alignment which does not help for barebones tests, c.f.
  # http://code.google.com/p/nativeclient/issues/detail?id=651
  if basename == 'stack_alignment16' and not env.Bit('build_x86'):
    continue
  if basename == 'stack_alignment8' and not env.Bit('build_arm'):
    continue
  is_broken = is_glibc
  # This is generating a (probably invalid) relocation on PNaCl GlibC X86-64
  # which cannot be handled by the TLS rewrite in binutils.
  if basename == 'reloc' and is_glibc and env.Bit('build_x86_64'):
    continue

  # TODO(robertm): enable this when ready (see above)
  if basename == 'stack_alignment16' and env.Bit('build_x86'):
    is_broken = True

  src = 'barebones_' + basename + '.c'
  nexe_name = 'barebones_' + basename
  out = 'barebones_' + basename + '.out'
  test = 'run_barebones_' + basename + '_test'
  test = 'run_barebones_' + basename + '_test'
  nexe = env.ComponentProgram(nexe_name, [FAKE_STARTUP, src])

  # NOTE: we avoid using zero as the "good" exit status and just
  #       arbitrarily picked 55. All tests are coded to follow this model.
  node = env.CommandSelLdrTestNacl(out, nexe, exit_status='55')

  env.AddNodeToTestSuite(node,
                         ['small_tests', 'sel_ldr_tests', 'barebones_tests'],
                         test,
                         is_broken=is_broken)


# a test that the validator can handle an empty segment after the last
# real segment. The gold linker produces files this
if env.Bit('build_arm') and not env.Bit('bitcode'):
  nexe = env.File(
  '${SCONSTRUCT_DIR}/tests/prebuilt/arm/gold-barebones_hello_world${PROGSUFFIX}'
  )
  node = env.CommandSelLdrTestNacl(
      'gold-barebones_hello_world.out',
      nexe,
      exit_status='55',)
  env.AddNodeToTestSuite(node,
                         ['small_tests', 'sel_ldr_tests'],
                         'run_gold-barebones_hello_world_test',
                         is_broken=is_glibc)
