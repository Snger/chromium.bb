# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import platform
import re        # For StripArchFromLDCommand hack.
import os.path   # For getting basenames.

Import('env')

# Browser tests for the pnacl translator.

# TODO(jvoung): allow pnacl to reuse normal NaCl browser tests.
if not env.Bit('bitcode'):
  Return()

#----------------------------------------------------------------------
# Get list of translator files

# Seriously, we need to make up our minds about whether or not we
# want a dash in the ISA string. My vote is for keeping the dash,
# since that is what the plugin will respond with.
def DashFreeArch(arch):
  return arch.replace('-', '')

# Sigh, cases where we use the dash.
def ArchFromTargetPlatform():
  if env.Bit('target_x86_32'):
    return 'x86-32'
  elif env.Bit('target_x86_64'):
    return 'x86-64'
  elif env.Bit('target_arm'):
    return 'arm'
  else:
    raise Exception('unknown architecture')

# Return a pair of files, representing a mapping
# from an URL to path in the staging directory.
def MappingForStagedFile(f):
  return (f.replace('${STAGING_DIR}/', ''), f)

def ReplicateAndMap(files, arch, replicates, map_files):
  # Replicate to STAGING (files can be copied from there).
  replicates += env.Replicate('${STAGING_DIR}/pnacl_support/%s' %
                              arch,
                              files)
  # Above, we have the full path w/ variables like ${TARGET_ROOT}.
  # Here, we need an "evaluated" string. Hack that w/ basename...
  basefiles = [ os.path.basename(f) for f in files ]
  # Set up file mapping for test runner:
  map_files += [MappingForStagedFile('${STAGING_DIR}/pnacl_support/%s/%s' %
                                     (arch, f))
                for f in basefiles]

# TODO(jvoung): Try using env.Publish()
def LayoutTranslatorBinariesOnServer():
  ''' Lay out the translator support files in a way that imitates
      any old webserver hosting pnacl bitcode for all 3 arches.
      Simple server directory layout for each arch-specific-support file:
         ./pnacl_support/${arch}/${file}

      Location of test-page, bitcode, etc.:
         ./mypage.html
         ./mybitcode.pexe
  '''
  # TODO(jvoung): simplify how utman installs these files in the first
  # place so that mapping is pretty much one-to-one (someone could just
  # copy the files from the toolchain-dir to their webserver).
  map_files = []
  replicates = [] # track staging dependencies

  # We need to pull some files from extra_sdk. Unfortunately, this is
  # only guaranteed to be built for the current target platform.
  # TODO(jvoung): stage the sdk libs for other platforms, not
  # just the one that you are building.
  sdk_lib_dir = '${TARGET_ROOT}/lib/'
  sdk_native_libs = [(sdk_lib_dir + x)
                     for x in ['crt1.o', 'libcrt_platform.a']]

  arch = ArchFromTargetPlatform()
  ReplicateAndMap(sdk_native_libs, arch, replicates, map_files)

  toolchain_dir = '${PNACL_ROOT}'
  for arch in ['arm', 'x86-32', 'x86-64']:
    toolchain_bin = '%s/tools-sb/%s/srpc/bin/' % (toolchain_dir,
                                                  DashFreeArch(arch))
    toolchain_binaries = [toolchain_bin + 'llc', toolchain_bin + 'ld']
    toolchain_lib_dir = '%s/lib-%s/' % (toolchain_dir, arch)
    toolchain_native_libs = [(toolchain_lib_dir + x)
                             for x in ['libgcc.a','libgcc_eh.a']]

    toolchain_local_files = toolchain_native_libs + toolchain_binaries
    ReplicateAndMap(toolchain_local_files,
                    arch,
                    replicates,
                    map_files)

  # Stage the nacltest.js too, so that you can run this test by starting up
  # your own http server, your own browser, and visit the staging directory.
  replicates += env.Replicate('${STAGING_DIR}',
              '${SCONSTRUCT_DIR}/tools/browser_tester/browserdata/nacltest.js')
  # Don't need to add nacltest.js to map_files, since the browser tester
  # always loads up that file.
  return (map_files, replicates)


def LayoutPageAssetsOnServer(files):
  map_files = []
  replicates = []
  for f in files:
    replicates += env.Replicate('${STAGING_DIR}', f)
    map_files.append(MappingForStagedFile('${STAGING_DIR}/%s' % f))
  return (map_files, replicates)

#----------------------------------------------------------------------
# SRPC

# Usually the scons link step produces a nexe. We massage the commandline
# here to generate pexes, i.e. fully linked bitcode files.
# TODO(pdox): Clean this up if/when scons leaves a bitcode artifact more
# naturally for testing the translator inside and outside the browser.
def StripArchFromLDCommand(env):
  bitcode_env = env.Clone()
  old_link = bitcode_env.get('LINK')
  new_link = re.sub('-arch [\w\d-]+', '', old_link)
  bitcode_env.Replace(LINK=new_link)
  return bitcode_env

bitcode_env = StripArchFromLDCommand(env)

# Specify the object file to prevent junk from getting left over
# in source directory. SCons will default to point "-o" to the source
# directory if it is an absolute directory.
test_example_obj = bitcode_env.ComponentObject(
    'pnacl_test_example_obj',
    '${SCONSTRUCT_DIR}/tests/ppapi_test_example/ppapi_test_example.cc')

test_example_pexe = bitcode_env.ComponentProgram(
    'pnacl_test_example.pexe',
    [ test_example_obj ],
    EXTRA_LIBS=['${PPAPI_LIBS}',
                'ppapi_test_lib',
                'platform',
                'pthread',
                'gio',
                ])

# Page independent support assets.
(map_files_toolchain, replicates_toolchain) = LayoutTranslatorBinariesOnServer()

# Assets for the page.
(map_files_page, replicates_page) = LayoutPageAssetsOnServer(
    [test_example_pexe,
     'pnacl_test_example.nmf',
     'pnacl_test_example.html',
     ])

# Grab test routines.
borrowed_file = '${STAGING_DIR}/ppapi_test_example.js',

node = bitcode_env.PPAPIBrowserTester(
    'pnacl_test_example.out',
    url='pnacl_test_example.html',
    files=[borrowed_file], # the rest are in "map_files"
    map_files=map_files_toolchain + map_files_page,
    args=['--prefer_portable_in_manifest'])

# Make sure the files are actually staged when this test runs.
env.Depends(node, replicates_toolchain + replicates_page)

bitcode_env.AddNodeToTestSuite(node,
                               ['chrome_browser_tests'],
                               'run_pnacl_example_browser_test',
                               is_broken=(
                                   bitcode_env.PPAPIBrowserTesterIsBroken()))
