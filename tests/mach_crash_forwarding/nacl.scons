# -*- python -*-
# Copyright 2011 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can
# be found in the LICENSE file.

Import('env')


# This tests an interface that is specific to Mac OS X and/or Mach and
# that is only implemented for x86-32.
if not env.Bit('host_mac') or not env.Bit('build_x86_32'):
  Return()

if 'TRUSTED_ENV' not in env:
  Return()
trusted_env = env['TRUSTED_ENV']

# This duplicates the library list in src/trusted/service_runtime/build.scons.
# We would not have to do this if we could get Scons to track dependencies
# between libraries.
VALIDATOR_LIBS = []
if trusted_env.Bit('target_x86'):
  VALIDATOR_LIBS += [trusted_env.NaClTargetArchSuffix('ncvalidate')]
elif trusted_env.Bit('target_arm'):
  VALIDATOR_LIBS += ['ncvalidate_arm_v2']

runner = trusted_env.ComponentProgram(
    'mach_crash_forwarding_test', ['mach_crash_forwarding_test.c'],
    EXTRA_LIBS=['sel',
                'sel_debug_dummy',
                'manifest_proxy',
                'simple_service',
                'thread_interface',
                'gio_wrapped_desc',
                'nonnacl_srpc',
                'nrd_xfer',
                'nacl_perf_counter',
                'nacl_base',
                'imc',
                'container',
                'nacl_fault_inject',
                'platform',
                'platform_qual_lib',
                'gio',
                ] + VALIDATOR_LIBS)

untrusted_caught_nexe = env.File('${STAGING_DIR}/exception_test${PROGSUFFIX}')
untrusted_crash_nexe = env.File('${STAGING_DIR}/crash_test${PROGSUFFIX}')
trusted_crash_nexe = env.File('${STAGING_DIR}/crash_in_syscall${PROGSUFFIX}')
is_broken = not env.Bit('nacl_static_link')

node = env.CommandTest('mach_forward_untrusted_crash_test.out',
                       [runner, 'untrusted', untrusted_crash_nexe],
                       declares_exit_status=True)
env.AddNodeToTestSuite(node, ['small_tests', 'exception_tests',],
                       'run_mach_forward_untrusted_crash_test',
                       is_broken=is_broken)

node = env.CommandTest('mach_forward_untrusted_caught_test.out',
                       [runner, 'untrusted_caught', untrusted_caught_nexe],
                       declares_exit_status=True)
env.AddNodeToTestSuite(node, ['small_tests', 'exception_tests',],
                       'run_mach_forward_untrusted_caught_test',
                       is_broken=is_broken)

node = env.CommandTest('mach_forward_trusted_crash_test.out',
                       [runner, 'trusted', trusted_crash_nexe],
                       declares_exit_status=True)
env.AddNodeToTestSuite(node, ['small_tests', 'exception_tests'],
                       'run_mach_forward_trusted_crash_test',
                       is_broken=is_broken)

node = env.CommandTest('mach_unforwarded_trusted_crash_test.out',
                       [runner, 'unforwarded_trusted', trusted_crash_nexe],
                       declares_exit_status=True)
env.AddNodeToTestSuite(node, ['small_tests', 'exception_tests'],
                       'run_mach_unforwarded_trusted_crash_test',
                       is_broken=is_broken)

node = env.CommandTest('mach_forward_early_trusted_crash_test.out',
                       [runner, 'early_trusted'], declares_exit_status=True)
env.AddNodeToTestSuite(node, ['small_tests', 'exception_tests'],
                       'run_mach_forward_early_trusted_crash_test',
                       is_broken=is_broken)
