# -*- python -*-
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

Import('env')

if 'TRUSTED_ENV' not in env:
  Return()

if env.Bit('target_arm'):
  # The test fails in our ARM cross-compile/QEMU environment, but only
  # because the environment lacks libraries, which causes the dlopen()
  # to fail.
  Return()

trusted_env = env['TRUSTED_ENV'].Clone()

if trusted_env.Bit('coverage_enabled') and trusted_env.Bit('windows'):
  # Disable the coverage test on Windows.  This is related to bug:
  # http://code.google.com/p/nativeclient/issues/detail?id=1030
  # TODO(dspringer): re-enable this test once the bug is fixed.
  Return()

if not trusted_env.Bit('mac'):
  trusted_env['COMPONENT_STATIC'] = False


if trusted_env.Bit('linux'):
    trusted_env.Append(
        CCFLAGS=['-fPIC', '-Wno-long-long',],
        # Catch unresolved symbols in libraries.
        LINKFLAGS=['-Wl,-z,defs'],
        )

    # We usually try to build things statically, but the plugin is a .so
    trusted_env.FilterOut(LINKFLAGS=['-static'])
    trusted_env.Append(LIBS=['dl', 'pthread'])

if trusted_env.Bit('windows'):
    trusted_env.Append(
        CPPDEFINES = ['WIN32', '_WINDOWS'],
    )


trusted_env.Append(LIBS=['ppapi_browser', 'ppapi_plugin', 'platform', 'gio'])

fake_browser = trusted_env.ComponentProgram('fake_browser_ppapi',
                                            ['fake_core.cc',
                                             'fake_file_io.cc',
                                             'fake_file_io_trusted.cc',
                                             'fake_file_ref.cc',
                                             'fake_host.cc',
                                             'fake_instance.cc',
                                             'fake_nacl_private.cc',
                                             'fake_object.cc',
                                             'fake_resource.cc',
                                             'fake_url_loader.cc',
                                             'fake_url_request_info.cc',
                                             'fake_url_response_info.cc',
                                             'fake_url_util.cc',
                                             'fake_window.cc',
                                             'main.cc',
                                             'test_scriptable.cc',
                                             'utility.cc'])

target_nmf = 'basic_object.nmf';
basic_object_nmf = env.File('${STAGING_DIR}/' + target_nmf)

basic_object_target = env.File(
    '$STAGING_DIR/ppapi_basic_object_${TARGET_FULLARCH}${PROGSUFFIX}')

if trusted_env.Bit('mac'):
  plugin = trusted_env.File('${STAGING_DIR}/ppNaClPlugin')
else:
  plugin = trusted_env.File('${STAGING_DIR}/${SHLIBPREFIX}'
                            'ppNaClPlugin${SHLIBSUFFIX}')
sel_ldr = trusted_env.File('${STAGING_DIR}/${PROGPREFIX}sel_ldr${PROGSUFFIX}')
log_file = env.MakeNaClLogOption('fake_browser_ppapi.out')

test_env_vars = ['NACL_SEL_LDR=%s' % sel_ldr,
                 'NACLLOG=%s' % log_file]
if env.Bit('irt'):
  test_env_vars.append('NACL_IRT_LIBRARY=%s' % env.GetIrtNexe())

node = env.CommandTest('fake_browser_ppapi.out',
                       [fake_browser,
                        plugin,
                        'http://localhost:5103/basic_object.html',
                        # Must use relative nexe url for the test to work.
                        # See TODO in URLLoader::FinishStreamingToFile().
                        '"id=nacl_module;src=%s"' % target_nmf,
                        '${STAGING_DIR}'
                       ],
                       'medium',
                       osenv=test_env_vars,
                       extra_deps=[sel_ldr,
                                   basic_object_nmf,
                                   basic_object_target])

env.AddNodeToTestSuite(node, ['medium_tests'], 'run_fake_browser_ppapi_test')
