# -*- python -*-
# Copyright 2011 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

Import('env')

# This test does not make any sense for pure pnacl
if env.Bit('pnacl_generate_pexe'):
  Return()

# If this test is failing on the bots, you can find the seed
# from the output of the bot. Look for "--seed=".
# To reproduce the exact problem, set settings['seed'] below
# to the fixed seed you found on the bot.

#
# Calling Convention Test
#
# The "generate.py" script generates 4 modules (module0.c ... module3.c).
# Each module has functions, and calls to other functions in other modules.
# Each function has multiple fixed and variable arguments.
# This tests (by brute force) the correctness of the calling convention.
#
# To test toolchain compatibility, some of the modules are built
# using PNaCl, and some with NNaCl.

import random

base_env = env.Clone()
callingconv_h = base_env.File('callingconv.h').srcnode()
extra_cflags = [ '-Wno-long-long', '-I' + callingconv_h.dir.abspath ]

settings = {
  'num_functions'    : 200,
  'calls_per_func'   : 4,
  'max_args_per_func': 16,
}

# va_arg of struct types is broken in PNaCl
if env.Bit('bitcode'):
  settings['allow_struct_va_arg'] = 0

# Structure passing in PNaCl is broken.
# On X86-32, long long and double in structures are passed
# with the wrong alignment.
# On X86-64, the ABI is not implemented.
# There's a good chance ARM has similar problems.
if env.Bit('bitcode'):
  settings['allow_struct'] = 0

# Environments for building module sources
envlist = []

if env.Bit('bitcode'):
  # For PNaCl, we do a mixed test.
  # Create environments for pnacl-clang, pnacl-gcc, and nacl-gcc.
  # For each environment, we compile a test module straight to native code.
  pnacl_env = base_env.Clone()
  pnacl_env.PNaClForceNative()
  envlist.append(pnacl_env)

  # On X86-32 and X86-64, test against nacl-gcc also.
  # For ARM, we can only test PNaCl's self-consistency.
  if not base_env.Bit('target_arm'):
    native_env = base_env.PNaClGetNNaClEnv()
    envlist.append(native_env)

  link_env = pnacl_env
else:
  # For NNaCl toolchain, just test self-consistency
  link_env = base_env
  envlist.append(base_env)

# Add custom CFLAGS
# This must be done here, since PNaClGetNNaClEnv and
# PNaclChangeFrontend wipe CFLAGS.
for e in envlist:
  e.Append(CFLAGS = extra_cflags)

# Create two modules for each environment,
# so that we test toolchain self-interaction.
envlist = envlist + envlist

num_modules = len(envlist)
settings['num_modules'] = num_modules
module_filenames = [ 'module%d.c' % i for i in xrange(num_modules) ]

# Generate the module source files (module0.c, module1.c, ...)
settings_args = ['--%s=%s' % (k,str(v)) for k,v in settings.iteritems()]
base_env['GENERATOR_SETTINGS'] = ' '.join(settings_args)

nodes = base_env.Command(
          ['callingconv.golden'] + module_filenames,
          base_env.File('generate.py'),
          Action('${PYTHON} ${SOURCE} ${GENERATOR_SETTINGS} -- ${TARGETS}'))

# Create the module objects
modules = []
for i in xrange(num_modules):
  obj = envlist[i].ComponentObject(nodes[i+1])
  envlist[i].Depends(obj, callingconv_h)
  modules.append(obj)

# Compile callingconv.c
callingconv = link_env.ComponentObject('callingconv.c')
link_env.Depends(callingconv, callingconv_h)


prog = link_env.ComponentProgram('callingconv',
                                 [callingconv] + modules,
                                 EXTRA_LIBS=['${NONIRT_LIBS}'])

node = link_env.CommandSelLdrTestNacl(
         'callingconv.out',
         prog,
         stdout_golden=nodes[0])

env.AddNodeToTestSuite(node, ['medium_tests'], 'run_callingconv_test',
                       # This test takes too long to compile for ARM
                       # and the resulting code doesn't pass this test.
                       is_broken=env.Bit('target_arm'))
