# -*- python -*-
# Copyright 2012 The Native Client Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Calling convention test to ensure interoperabilty of nacl-gcc and
# pnacl generated code

Import('env')

# This test does not make any sense for pure pnacl
if not env.Bit('bitcode'):
  Return()

if env.Bit('pnacl_generate_pexe'):
  Return()

if env.Bit('built_elsewhere'):
  Return()

env.PNaClForceNative()
# for ppapi headers which include other ppapi headers
env.Append(CPPPATH='${SCONSTRUCT_DIR}/tests/callingconv_ppapi')
env_pnacl_calling = env.Clone()
env_pnacl_calling.Append(
    # force invoked functions to have "gcc" prefix
    CPPDEFINES=['INVOCATION_PREFIX=gcc'])
env_pnacl_called = env.Clone()
env_pnacl_called.Append(
    # force both defined and invoked functions to have the "pnacl" prefix
    CPPDEFINES=['FUNCTION_PREFIX=pnacl', 'INVOCATION_PREFIX=pnacl'])

# hack to keep this file readable - most of the arm tests are
# disabled via BROKEN_CONFIGS
# This should be removed once we have access to a gcc/arm TC
if env.Bit('target_arm'):
  # the  gcc_env is bogus but we do not really use anything produced
  # within it.
  gcc_env = env.Clone()
else:
  gcc_env = env.PNaClGetNNaClEnv()
env_gcc_calling = gcc_env.Clone()
env_gcc_calling.Append(
    # force invoked functions to have "pnacl" prefix
    CPPDEFINES=['INVOCATION_PREFIX=pnacl'])
env_gcc_called = gcc_env.Clone()
env_gcc_called.Append(
    # force both defined and invoked functions to have the "gcc" prefix
    CPPDEFINES=['FUNCTION_PREFIX=gcc', 'INVOCATION_PREFIX=gcc'])

# Note: this file is alwyas built with the pnacl TC
obj_support = env.ComponentObject('support.c')

env_pnacl_called.ComponentObject('obj_pnacl_called',
                                 'ppapi_callingconv_test.cpp')

env_pnacl_calling.ComponentObject('obj_pnacl_calling',
                                  'ppapi_callingconv_test.cpp')
env.ComponentObject('obj_pnacl_both',
                    'ppapi_callingconv_test.cpp')

env_gcc_called.ComponentObject('obj_gcc_called',
                               'ppapi_callingconv_test.cpp')

env_gcc_calling.ComponentObject('obj_gcc_calling',
                                'ppapi_callingconv_test.cpp')

gcc_env.ComponentObject('obj_gcc_both',
                        'ppapi_callingconv_test.cpp')


TARGETS = [
  # pnacl self consistency tests
  ('pnacl_both', ['obj_pnacl_both', obj_support]),
  # gcc self consistency tests
  ('gcc_both', ['obj_gcc_both', obj_support]),
  # gcc compiled code invoking pnacl compiled code:
  # * obj_gcc_calling contains gcc compiled code invoking functions
  #   with the "pnacl" prefix
  # * obj_pnacl_called contains pnacl compiled functions with the "pnacl"
  #   prefix
  ('gcc_calls_pnacl', ['obj_gcc_calling', 'obj_pnacl_called', obj_support]),
  # pnacl compiled code invoking gcc compiled code:
  # * obj_pnacl_calling contains pnacl compiled code invoking functions
  #   with the "gcc" prefix
  # * obj_gcc_called contains gcc compiled functions with the "gcc"
  #   prefix
  ('pnacl_calls_gcc',['obj_pnacl_calling', 'obj_gcc_called', obj_support]),
]


BROKEN_CONFIGS = set([
    # we need the nacl-gcc/arm TC or anything generating eabi calls
    # before we can enable the ARM tests
  ('arm', 'gcc_both'),
  ('arm', 'gcc_calls_pnacl'),
  ('arm', 'pnacl_calls_gcc'),

  ('x86-64', 'gcc_calls_pnacl'),
  ('x86-64', 'pnacl_calls_gcc'),
  ])

for name, objs in TARGETS:
  is_broken = (env.get('TARGET_FULLARCH'), name) in BROKEN_CONFIGS
  nexe = env.ComponentProgram('callingconv_ppapi_%s' % name,
                              objs,
                              EXTRA_LIBS=['${NONIRT_LIBS}'])
  test= env.CommandSelLdrTestNacl('callingconv_ppapi_%s.out' % name,
                                  nexe,
                                  stdout_golden=env.File('golden.out'))
  env.AddNodeToTestSuite(test,
                         ['medium_tests', 'nonpexe_tests'],
                         'run_callingconv_ppapi_%s_test' % name,
                         is_broken=is_broken)

