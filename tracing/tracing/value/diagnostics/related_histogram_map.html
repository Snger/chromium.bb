<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic.html">
<link rel="import" href="/tracing/value/diagnostics/histogram_ref.html">

<script>
'use strict';

tr.exportTo('tr.v.d', function() {
  class RelatedHistogramMap extends tr.v.d.Diagnostic {
    constructor() {
      super();
      this.histogramsByName_ = new Map();
    }

    /**
     * Lookup a Histogram by name. Returns undefined if |name| is not found.
     *
     * @param {string} name
     * @return {!tr.v.d.HistogramRef|!tr.v.Histogram|undefined}
     */
    get(name) {
      return this.histogramsByName_.get(name);
    }

    /**
     * Add a Histogram by an explicit name to this map.
     *
     * @param {string} name
     * @param {!(tr.v.d.HistogramRef|tr.v.Histogram)} hist
     */
    set(name, hist) {
      if (!(hist instanceof tr.v.Histogram) &&
          !(hist instanceof tr.v.d.HistogramRef)) {
        throw new Error('Must be instanceof Histogram or HistogramRef: ' +
            hist);
      }

      this.histogramsByName_.set(name, hist);
    }

    /**
     * Add a Histogram implicitly by its own name to this map.
     *
     * @param {!(tr.v.d.HistogramRef|tr.v.Histogram)} hist
     */
    add(hist) {
      this.set(hist.name, hist);
    }

    get length() {
      return this.histogramsByName_.size;
    }

    * [Symbol.iterator]() {
      for (let pair of this.histogramsByName_)
        yield pair;
    }

    /**
     * Resolve all HistogramRefs into Histograms by looking up their guids in
     * |histograms|.
     * If a Histogram cannot be found and |opt_required| is true, then throw an
     * Error.
     * If a Histogram cannot be found and |opt_required| is false, then the
     * HistogramRef will remain a HistogramRef.
     *
     * @param {!tr.v.HistogramSet} histograms
     * @param {boolean=} opt_required
     */
    resolve(histograms, opt_required) {
      for (let [name, hist] of this) {
        if (!(hist instanceof tr.v.d.HistogramRef)) continue;

        let guid = hist.guid;
        hist = histograms.lookupHistogram(guid);
        if (hist instanceof tr.v.Histogram) {
          this.histogramsByName_.set(name, hist);
        } else if (opt_required) {
          throw new Error('Unable to find Histogram ' + guid);
        }
      }
    }

    asDictInto_(d) {
      d.values = {};
      for (let [name, hist] of this) {
        d.values[name] = hist.guid;
      }
    }

    static fromDict(d) {
      let map = new RelatedHistogramMap();
      tr.b.iterItems(d.values, function(name, guid) {
        map.set(name, new tr.v.d.HistogramRef(guid));
      });
      return map;
    }
  }

  tr.v.d.Diagnostic.register(RelatedHistogramMap, {
    elementName: 'tr-v-ui-related-histogram-map-span'
  });

  return {
    RelatedHistogramMap,
  };
});
</script>
