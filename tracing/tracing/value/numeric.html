<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/unit.html">

<script>
'use strict';

tr.exportTo('tr.v', function() {
  var MAX_DIAGNOSTIC_MAPS = 16;

  class NumericBase {
    constructor(unit) {
      if (!(unit instanceof tr.v.Unit))
        throw new Error('Expected provided unit to be instance of Unit');

      this.unit = unit;
    }

    merge(other) {
      if (this.unit !== other.unit)
        throw new Error('Merging Numerics with different units');

      // Two Numerics that were built with the same boundaries
      // can be merged using addNumeric().
      if (this instanceof tr.v.Histogram && other instanceof tr.v.Histogram &&
          this.canAddNumeric(other)) {
        var result = this.clone();
        result.addNumeric(other.clone());
        return result;
      }

      // Either a Scalar and a Histogram, or two Scalars...
      // or two Numerics that were not built with the same boundaries should be
      // built from their raw samples.
      var samples = [];
      this.sampleValuesInto(samples);
      other.sampleValuesInto(samples);
      return tr.v.Histogram.buildFromSamples(this.unit, samples);
    }

    sampleValuesInto(samples) {
      throw new Error('Not implemented');
    }

    asDict() {
      var d = {
        unit: this.unit.asJSON()
      };

      this.asDictInto_(d);
      return d;
    }

    static fromDict(d) {
      if (d.type === 'scalar')
        return ScalarNumeric.fromDict(d);

      if (d.type === 'numeric')
        return tr.v.Histogram.fromDict(d);

      throw new Error('Not implemented');
    }
  };

  class ScalarNumeric extends NumericBase {
    constructor(unit, value) {
      if (!(unit instanceof tr.v.Unit))
        throw new Error('Expected Unit');

      if (!(typeof(value) == 'number'))
        throw new Error('Expected value to be number');

      super(unit);
      this.value = value;
    }

    asDictInto_(d) {
      d.type = 'scalar';

      // Infinity and NaN are left out of JSON for security reasons that do not
      // apply to our use cases.
      if (this.value === Infinity)
        d.value = 'Infinity';
      else if (this.value === -Infinity)
        d.value = '-Infinity';
      else if (isNaN(this.value))
        d.value = 'NaN';
      else
        d.value = this.value;
    }

    sampleValuesInto(samples) {
      samples.push(this.value);
    }

    toString() {
      return this.unit.format(this.value);
    }

    static fromDict(d) {
      // Infinity and NaN are left out of JSON for security reasons that do not
      // apply to our use cases.
      if (typeof(d.value) === 'string') {
        if (d.value === '-Infinity') {
          d.value = -Infinity;
        } else if (d.value === 'Infinity') {
          d.value = Infinity;
        } else if (d.value === 'NaN') {
          d.value = NaN;
        }
      }

      return new ScalarNumeric(tr.v.Unit.fromJSON(d.unit), d.value);
    }
  };

  return {
    NumericBase: NumericBase,
    ScalarNumeric: ScalarNumeric
  };
});
</script>
