// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_BROWSER_RENDERER_HOST_INPUT_GESTURE_EVENT_QUEUE_H_
#define CONTENT_BROWSER_RENDERER_HOST_INPUT_GESTURE_EVENT_QUEUE_H_

#include <deque>
#include <queue>

#include "content/browser/renderer_host/input/gesture_event_packet.h"
#include "content/common/content_export.h"
#include "content/port/common/input_event_ack_state.h"
#include "third_party/WebKit/public/web/WebInputEvent.h"

namespace content {

// Interface with which the |GestureEventQueue| forwards gestures for a given
// touch event.
class CONTENT_EXPORT GestureEventQueueClient {
 public:
  virtual void ForwardGestureEvent(const blink::WebGestureEvent&) = 0;
};

// Handles dispatch of touch-derived gestures created by the platform.
// Gestures are forwarded or dropped depending on the ack dispositions of the
// generating touch sequence.
class CONTENT_EXPORT GestureEventQueue {
 public:
  explicit GestureEventQueue(GestureEventQueueClient* client);
  ~GestureEventQueue();

  // To be called upon receipt of gesture-related events.  In particular,
  // |packet| contains [0, n] gestures that correspond to a given event.  That
  // event may be a touch, or a touch timeout for certain stationary gestures.
  // It is imperative that a single packet is received for *each* touch event,
  // even those that did not produce a gesture.
  void OnGestureEventPacket(const GestureEventPacket& packet);

  // To be called upon receipt of *all* touch event acks.
  void OnTouchEventAck(InputEventAckState ack_state);

 private:
  // Utility class for tracking gesture events and dispositions for a single
  // gesture sequence. A single sequence corresponds to all gestures created
  // between the first finger down and the last finger up, including gestures
  // generated by timeouts from a statinoary finger.
  class GestureSequence {
   public:
    GestureSequence();
    ~GestureSequence();

    void Push(const GestureEventPacket& packet);
    void Pop();
    const GestureEventPacket& Front() const;
    void UpdateState(InputEventAckState ack_state);
    bool IsGesturePrevented() const;
    bool IsEmpty() const;

   private:
    std::queue<GestureEventPacket> packets_;
    enum GestureHandlingState {
      PENDING,                 // The sequence has yet to receive an ack.
      ALLOWED_UNTIL_PREVENTED, // Gestures in the sequence are allowed until
                               // a source touch is preventDefault'ed.
      ALWAYS_ALLOWED,          // All remaining sequence gestures are forwarded.
      ALWAYS_PREVENTED         // All remaining sequence gestures are dropped.
    };
    GestureHandlingState state_;
  };
  void UpdateAndDispatchPackets(GestureSequence* sequence,
                                InputEventAckState ack_result);
  void SendPacket(const GestureEventPacket& packet);
  void SendGesture(const blink::WebGestureEvent& gesture);
  void CancelTapIfNecessary();
  void CancelFlingIfNecessary();
  GestureSequence& Head();
  GestureSequence& Tail();

  GestureEventQueueClient* client_;
  std::queue<GestureSequence> sequences_;

  // Bookkeeping for inserting synthetic Gesture{Tap,Fling}Cancel events
  // when necessary, e.g., GestureTapCancel when scrolling begins, or
  // GestureFlingCancel when a user taps following a GestureFlingStart.
  bool needs_tap_ending_event_;
  bool needs_fling_ending_event_;

  DISALLOW_COPY_AND_ASSIGN(GestureEventQueue);
};

}  // namespace content

#endif  // CONTENT_BROWSER_RENDERER_HOST_INPUT_GESTURE_EVENT_QUEUE_H_
