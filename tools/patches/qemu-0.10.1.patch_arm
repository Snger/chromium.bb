diff -Naur qemu-0.10.1.orig/cpu-all.h qemu-0.10.1/cpu-all.h
--- qemu-0.10.1.orig/cpu-all.h	2009-03-21 19:05:48.000000000 -0400
+++ qemu-0.10.1/cpu-all.h	2011-03-28 14:22:39.000000000 -0400
@@ -817,6 +817,7 @@
 #define CPU_LOG_IOPORT     (1 << 7)
 #define CPU_LOG_TB_CPU     (1 << 8)
 #define CPU_LOG_RESET      (1 << 9)
+#define CPU_LOG_SERVICE_RUNTIME      (1 << 10) /* @LOCALMOD */
 
 /* define log items */
 typedef struct CPULogItem {
diff -Naur qemu-0.10.1.orig/cpu-exec.c qemu-0.10.1/cpu-exec.c
--- qemu-0.10.1.orig/cpu-exec.c	2009-03-21 19:05:48.000000000 -0400
+++ qemu-0.10.1/cpu-exec.c	2011-03-28 14:22:39.000000000 -0400
@@ -48,8 +48,10 @@
 
 int tb_invalidated_flag;
 
-//#define DEBUG_EXEC
-//#define DEBUG_SIGNAL
+// @@LOCALMOD-BEGIN
+#define DEBUG_EXEC
+#define DEBUG_SIGNAL
+// @@LOCALMOD-END
 
 void cpu_loop_exit(void)
 {
@@ -531,10 +533,40 @@
                     env->exception_index = EXCP_INTERRUPT;
                     cpu_loop_exit();
                 }
+
+
+                // @LOCALMOD-BEGIN
+                spin_lock(&tb_lock);
+#define VLINE_NACL     "@@NACL =========================================================\n"
+#define VLINE_SR       "@@SERV =========================================================\n"
+#define VLINE_UNKNOWN  "@@???? =========================================================\n"                                
+
+                int loglevel_saved = loglevel;
+                long curr_pc = (long)cpu_get_pc(env);
+                if (curr_pc < 0) {
+                  qemu_log_mask(CPU_LOG_TB_CPU, VLINE_UNKNOWN);
+                } else if (curr_pc < 0x00100000) {
+                  qemu_log_mask(CPU_LOG_TB_CPU, VLINE_NACL);
+                } else {
+                  if (!qemu_loglevel_mask(CPU_LOG_SERVICE_RUNTIME)) {
+                    /* temporary disable logging  */
+                    /* log modes are explained in exec.c */
+                    loglevel &= ~(CPU_LOG_TB_CPU|
+                                  CPU_LOG_EXEC|
+                                  CPU_LOG_TB_IN_ASM|
+                                  CPU_LOG_TB_OUT_ASM|
+                                  CPU_LOG_TB_OP);
+                                  }
+                  qemu_log_mask(CPU_LOG_TB_CPU, VLINE_SR);
+                }
+
+                // @LOCALMOD-END
+
 #ifdef DEBUG_EXEC
                 if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {
                     /* restore flags in standard format */
                     regs_to_env();
+
 #if defined(TARGET_I386)
                     env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);
                     log_cpu_state(env, X86_DUMP_CCOP);
@@ -564,8 +596,14 @@
 #endif
                 }
 #endif
-                spin_lock(&tb_lock);
+
+                // @LOCALMOD-BEGIN
+
+                //spin_lock(&tb_lock);
                 tb = tb_find_fast();
+                // @LOCALMOD-END
+
+
                 /* Note: we do it here to avoid a gcc bug on Mac OS X when
                    doing it in tb_find_slow */
                 if (tb_invalidated_flag) {
@@ -592,6 +630,9 @@
                     tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);
                 }
                 }
+
+                loglevel = loglevel_saved;  /* @LOCALMOD */
+
                 spin_unlock(&tb_lock);
                 env->current_tb = tb;
 
@@ -760,6 +801,8 @@
     if (cpu_single_env)
         env = cpu_single_env; /* XXX: find a correct solution for multithread */
 #if defined(DEBUG_SIGNAL)
+    qemu_log_mask(CPU_LOG_EXEC,"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\n",
+                pc, address, is_write, *(unsigned long *)old_set);
     qemu_printf("qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\n",
                 pc, address, is_write, *(unsigned long *)old_set);
 #endif
@@ -938,6 +981,7 @@
 #if defined(DEBUG_SIGNAL)
     printf("qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\n",
            pc, address, is_write, *(unsigned long *)old_set);
+
 #endif
     /* XXX: locking issue */
     if (is_write && page_unprotect(address, pc, puc)) {
diff -Naur qemu-0.10.1.orig/disas.c qemu-0.10.1/disas.c
--- qemu-0.10.1.orig/disas.c	2009-03-21 19:05:48.000000000 -0400
+++ qemu-0.10.1/disas.c	2011-03-28 14:22:39.000000000 -0400
@@ -10,7 +10,9 @@
 
 /* Filled in by elfload.c.  Simplistic, but will do for now. */
 struct syminfo *syminfos = NULL;
-
+// @LOCALMOD
+struct syminfo *syminfos2 = NULL;
+// @LOCALMOD
 /* Get LENGTH bytes from info's buffer, at target address memaddr.
    Transfer them to myaddr.  */
 int
@@ -299,11 +301,21 @@
     for (s = syminfos; s; s = s->next) {
         symbol = s->lookup_symbol(s, orig_addr);
         if (symbol[0] != '\0') {
-            break;
+            return symbol;
         }
     }
 
+    // @LOCALMOD
+    for (s = syminfos2; s; s = s->next) {
+        symbol = s->lookup_symbol(s, orig_addr);
+        if (symbol[0] != '\0') {
     return symbol;
+        }
+    }
+
+    // @LOCALMOD
+
+    return "";
 }
 
 #if !defined(CONFIG_USER_ONLY)
diff -Naur qemu-0.10.1.orig/disas.h qemu-0.10.1/disas.h
--- qemu-0.10.1.orig/disas.h	2009-03-21 19:05:48.000000000 -0400
+++ qemu-0.10.1/disas.h	2011-03-28 14:22:39.000000000 -0400
@@ -29,5 +29,8 @@
 
 /* Filled in by elfload.c.  Simplistic, but will do for now. */
 extern struct syminfo *syminfos;
+// @LOCALMOD
+extern struct syminfo *syminfos2;
+// @LOCALMOD
 
 #endif /* _QEMU_DISAS_H */
diff -Naur qemu-0.10.1.orig/exec.c qemu-0.10.1/exec.c
--- qemu-0.10.1.orig/exec.c	2009-03-21 19:05:48.000000000 -0400
+++ qemu-0.10.1/exec.c	2011-03-28 14:22:39.000000000 -0400
@@ -1570,6 +1570,10 @@
     { CPU_LOG_IOPORT, "ioport",
       "show all i/o ports accesses" },
 #endif
+    /* @LOCALMOD-START */
+    { CPU_LOG_SERVICE_RUNTIME, "service_runtime",
+      "log service runtime activity" },
+    /* @LOCALMOD-END */
     { 0, NULL, NULL },
 };
 
diff -Naur qemu-0.10.1.orig/i386.ld qemu-0.10.1/i386.ld
--- qemu-0.10.1.orig/i386.ld	2009-03-21 19:05:48.000000000 -0400
+++ qemu-0.10.1/i386.ld	2011-03-28 14:22:39.000000000 -0400
@@ -40,8 +40,23 @@
   .rela.fini     : { *(.rela.fini)	}
   .rel.bss       : { *(.rel.bss)		}
   .rela.bss      : { *(.rela.bss)		}
-  .rel.plt       : { *(.rel.plt)		}
-  .rela.plt      : { *(.rela.plt)		}
+   /* LOCALMOD-START */
+  .rel.plt       : 
+  {
+    PROVIDE_HIDDEN (__rel_iplt_start = .);
+    *(.rel.plt)
+    *(.rel.iplt)
+    PROVIDE_HIDDEN (__rel_iplt_end = .);
+  }
+
+  .rela.plt      : 
+  {
+    PROVIDE_HIDDEN (__rela_iplt_start = .);
+    *(.rela.plt)
+    *(.rela.iplt)
+    PROVIDE_HIDDEN (__rela_iplt_end = .);
+  }
+   /* LOCALMOD-END */
   .init          : { *(.init)	} =0x47ff041f
   .text      :
   {
diff -Naur qemu-0.10.1.orig/linux-user/elfload.c qemu-0.10.1/linux-user/elfload.c
--- qemu-0.10.1.orig/linux-user/elfload.c	2009-03-21 19:05:41.000000000 -0400
+++ qemu-0.10.1/linux-user/elfload.c	2011-03-28 14:22:39.000000000 -0400
@@ -1030,18 +1030,22 @@
 }
 
 /* Best attempt to load symbols from this ELF object. */
-static void load_symbols(struct elfhdr *hdr, int fd)
+// @LOCALMOD
+static struct syminfo*  load_symbols(struct elfhdr *hdr, int fd, int dummy)
+// @LOCALMOD
 {
     unsigned int i, nsyms;
     struct elf_shdr sechdr, symtab, strtab;
     char *strings;
-    struct syminfo *s;
+    struct syminfo* s;
     struct elf_sym *syms;
-
+    // @LOCALMOD
+    printf("loading symbols\n");
+    // @LOCALMOD
     lseek(fd, hdr->e_shoff, SEEK_SET);
     for (i = 0; i < hdr->e_shnum; i++) {
         if (read(fd, &sechdr, sizeof(sechdr)) != sizeof(sechdr))
-            return;
+            return 0;
 #ifdef BSWAP_NEEDED
         bswap_shdr(&sechdr);
 #endif
@@ -1051,28 +1055,28 @@
                   + sizeof(sechdr) * sechdr.sh_link, SEEK_SET);
             if (read(fd, &strtab, sizeof(strtab))
                 != sizeof(strtab))
-                return;
+                return 0;
 #ifdef BSWAP_NEEDED
             bswap_shdr(&strtab);
 #endif
             goto found;
         }
     }
-    return; /* Shouldn't happen... */
+    return 0; /* Shouldn't happen... */
 
  found:
     /* Now know where the strtab and symtab are.  Snarf them. */
     s = malloc(sizeof(*s));
     syms = malloc(symtab.sh_size);
     if (!syms)
-        return;
+        return 0;
     s->disas_strtab = strings = malloc(strtab.sh_size);
     if (!s->disas_strtab)
-        return;
+        return 0;
 
     lseek(fd, symtab.sh_offset, SEEK_SET);
     if (read(fd, syms, symtab.sh_size) != symtab.sh_size)
-        return;
+        return 0;
 
     nsyms = symtab.sh_size / sizeof(struct elf_sym);
 
@@ -1103,7 +1107,7 @@
 
     lseek(fd, strtab.sh_offset, SEEK_SET);
     if (read(fd, strings, strtab.sh_size) != strtab.sh_size)
-        return;
+        return 0;
     s->disas_num_syms = nsyms;
 #if ELF_CLASS == ELFCLASS32
     s->disas_symtab.elf32 = syms;
@@ -1113,8 +1117,29 @@
     s->lookup_symbol = lookup_symbolxx;
 #endif
     s->next = syminfos;
-    syminfos = s;
+
+    // @LOCALMOD
+    return s;
+    // @LOCALMOD
+}
+
+
+// @@LOCAL-MOD
+void load_elf_secondary(const char* filename)
+{
+  struct elfhdr elf_ex;
+  int fd;
+  fd = open(filename, O_RDONLY);
+  if (fd <= 0)
+  {
+    printf("ERROR: opening secondary exe %s\n", filename);
+    return;
+  }
+
+  read(fd, &elf_ex, sizeof elf_ex);
+  syminfos2 = load_symbols(&elf_ex, fd, 0);
 }
+// @@LOCAL-MOD
 
 int load_elf_binary(struct linux_binprm * bprm, struct target_pt_regs * regs,
                     struct image_info * info)
@@ -1455,7 +1480,7 @@
     free(elf_phdata);
 
     if (qemu_log_enabled())
-	load_symbols(&elf_ex, bprm->fd);
+      syminfos = load_symbols(&elf_ex, bprm->fd, 0);
 
     if (interpreter_type != INTERPRETER_AOUT) close(bprm->fd);
     info->personality = (ibcs2_interpreter ? PER_SVR4 : PER_LINUX);
diff -Naur qemu-0.10.1.orig/linux-user/main.c qemu-0.10.1/linux-user/main.c
--- qemu-0.10.1.orig/linux-user/main.c	2009-03-21 19:05:42.000000000 -0400
+++ qemu-0.10.1/linux-user/main.c	2011-03-28 14:22:39.000000000 -0400
@@ -2351,7 +2351,25 @@
     filename = argv[optind];
     exec_path = argv[optind];
 
-    /* Zero out regs */
+    // @LOCALMOD
+    extern void load_elf_secondary(const char* s);
+    if (qemu_loglevel_mask(CPU_LOG_EXEC))
+    {
+      printf("qemu with NACL mods\n");
+      int i;
+      for (i = optind + 1; i < argc; ++i ) {
+        int len = strlen(argv[i]);
+        if (len > 5 && 0 == strcmp(".nexe", &argv[i][len - 5])) {
+          printf("FOUND NACL IMAGE: %s\n", argv[i]);
+          load_elf_secondary(argv[i]);
+        }
+      }
+
+    }
+    // @LOCALMOD
+
+
+/* Zero out regs */
     memset(regs, 0, sizeof(struct target_pt_regs));
 
     /* Zero out image_info */
diff -Naur qemu-0.10.1.orig/linux-user/syscall.c qemu-0.10.1/linux-user/syscall.c
--- qemu-0.10.1.orig/linux-user/syscall.c	2009-03-21 19:05:41.000000000 -0400
+++ qemu-0.10.1/linux-user/syscall.c	2011-03-28 16:19:58.000000000 -0400
@@ -4879,6 +4879,20 @@
             }
         }
         break;
+/* @LOCALMOD-BEGIN */
+/* NOTE: this adds limited support for syscall shmctl.
+ * We do not support any use that requires arg3 at this time.
+ */
+#ifdef TARGET_NR_shmctl
+/* from /usr/include/linux/ipc.h */
+#define IPC_64  0x0100 
+     case TARGET_NR_shmctl:
+      if (arg2 != IPC_RMID && arg2 != (IPC_RMID|IPC_64)) goto  unimplemented;
+        
+      ret = get_errno(shmctl(arg1, arg2, 0));
+      break;
+#endif
+/* @LOCALMOD-END */      
 #ifdef TARGET_NR_ipc
     case TARGET_NR_ipc:
 	ret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);
diff -Naur qemu-0.10.1.orig/target-arm/cpu.h qemu-0.10.1/target-arm/cpu.h
--- qemu-0.10.1.orig/target-arm/cpu.h	2009-03-21 19:05:47.000000000 -0400
+++ qemu-0.10.1/target-arm/cpu.h	2011-03-28 14:22:39.000000000 -0400
@@ -446,4 +446,11 @@
         *flags |= (1 << 7);
 }
 
+
+/* LOCALMOD-START */
+static inline  target_ulong cpu_get_pc(CPUState *env) {
+  return  env->regs[15];
+}
+/* LOCALMOD-END */
+
 #endif
diff -Naur qemu-0.10.1.orig/x86_64.ld qemu-0.10.1/x86_64.ld
--- qemu-0.10.1.orig/x86_64.ld	2009-03-21 19:05:48.000000000 -0400
+++ qemu-0.10.1/x86_64.ld	2011-03-28 14:22:39.000000000 -0400
@@ -36,8 +36,23 @@
   .rela.got       : { *(.rela.got) }
   .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }
   .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }
-  .rel.plt        : { *(.rel.plt) }
-  .rela.plt       : { *(.rela.plt) }
+  /* LOCALMOD-START */
+  .rel.plt       : 
+  {
+    PROVIDE_HIDDEN (__rel_iplt_start = .);
+    *(.rel.plt)
+    *(.rel.iplt)
+    PROVIDE_HIDDEN (__rel_iplt_end = .);
+  }
+
+  .rela.plt      : 
+  {
+    *(.rela.plt)
+    PROVIDE_HIDDEN (__rela_iplt_start = .);
+    *(.rela.iplt)
+    PROVIDE_HIDDEN (__rela_iplt_end = .);
+  }
+   /* LOCALMOD-END */
   .init           :
   {
     KEEP (*(.init))
