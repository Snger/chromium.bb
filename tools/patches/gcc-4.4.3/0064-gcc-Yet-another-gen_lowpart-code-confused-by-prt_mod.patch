From ffc2ce5a7dcff445bdf2b10a5e1f83e4a563be13 Mon Sep 17 00:00:00 2001
From: Evgeny Eltsin <eaeltsin@google.com>
Date: Fri, 24 Dec 2010 18:25:41 +0300
Subject: [PATCH 64/64] [gcc] Yet another gen_lowpart code confused by prt_mode != Pmode

Test from David Meyer, 64-bit mode with -O1:

typedef unsigned int size_t;

extern "C" {
  size_t strlen (const char *);
};

class StringRef {
private:
  const char *Data;
  size_t Length;

public:
 StringRef(const char *Str)
    : Data(Str), Length(::strlen(Str)) {}
};

StringRef GetDLLSuffix() {
  return &(".so"[1]);
}

Reports internal error while trying to replace Pmode register with ptr_mode CONST.

The change fixes the origin of such a CONST in gen_lowpart_for_combine. This is kinda hacky and clearly not upstreamable...

BUG=http://code.google.com/p/nativeclient/issues/detail?id=1279
TEST=see above

Review URL: http://codereview.chromium.org/5968010
---
 gcc/gcc/combine.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/gcc/gcc/combine.c b/gcc/gcc/combine.c
index 5078f3e..3eb2123 100644
--- a/gcc/gcc/combine.c
+++ b/gcc/gcc/combine.c
@@ -9892,8 +9892,11 @@ gen_lowpart_for_combine (enum machine_mode omode, rtx x)
     return x;
 
   /* Return identity if this is a CONST or symbolic reference.  */
+  /* HACK?
+     When ptr_mode != Pmode, we should not return CONST:ptr_mode for Pmode
+     and vice versa as this confuses SUBST.  */
   if (omode == Pmode
-      && (GET_CODE (x) == CONST
+      && ((GET_CODE (x) == CONST && ptr_mode == Pmode)
 	  || GET_CODE (x) == SYMBOL_REF
 	  || GET_CODE (x) == LABEL_REF))
     return x;
-- 
1.7.3.1

