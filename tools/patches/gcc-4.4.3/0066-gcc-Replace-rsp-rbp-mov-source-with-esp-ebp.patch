From 3416f7e9ec16bff06074f7a87ca4a7f950602703 Mon Sep 17 00:00:00 2001
From: Evgeny Eltsin <eaeltsin@google.com>
Date: Tue, 18 Jan 2011 21:40:19 +0300
Subject: [PATCH 66/66] [gcc] Replace rsp/rbp mov source with esp/ebp

The problem is that with POINTERS_EXTEND_UNSIGNED > 0 gcc considers high part of rsp and rbp to be zero, which is not true. This seems to be backend design flaw.

Fixing this by changing POINTERS_EXTEND_UNSIGNED to -1 and defining ptr_extend solves the problem but is likely to hit the performance of pointer arithmetics that does not involve rsp and rbp.

This fix fights the particular and most common case when rsp or rbp are sources of the mov instruction, by forcing this instructions to operate on low parts of the registers only. This is not the complete solution, and more changes will follow.

Test (-O1) must return 0 but returns high part of rsp without the fix:

struct StringRef {
  const char *Data;
  unsigned Length;
};

// Prevent inlining with 'weak' attribute
int print_size(struct StringRef Data) __attribute__((weak));

int print_size(struct StringRef Data) {
  return Data.Length;
}

int main() {
  char str[6]; // NEEDED!

  struct StringRef s;
  s.Data = str; // NEEDED!
  s.Length = 0;

  return print_size(s);
}

BUG=http://code.google.com/p/nativeclient/issues/detail?id=1304
TEST=see above

Review URL: http://codereview.chromium.org/6304009
---
 gcc/gcc/config/i386/i386.md |   43 +++++++++++++++++++++++++++----------------
 1 files changed, 27 insertions(+), 16 deletions(-)

diff --git a/gcc/gcc/config/i386/i386.md b/gcc/gcc/config/i386/i386.md
index 1192ce6..93223b2 100644
--- a/gcc/gcc/config/i386/i386.md
+++ b/gcc/gcc/config/i386/i386.md
@@ -2423,24 +2423,35 @@
 	return "mov{l}\t{%k1, %k0|%k0, %k1}";
       else if (which_alternative == 2)
 	return "movabs{q}\t{%1, %0|%0, %1}";
-      else if (!TARGET_NACL)
-	return "mov{q}\t{%1, %0|%0, %1}";
-      else if (REGNO (operands[0]) == SP_REG)
-	{
-	  if (REGNO (operands[1]) == BP_REG)
-	    return "mov{q}\t{%1, %0|%0, %1}";
-	  else
-	    return "naclrestsp\t{%k1, %%r15|%%r15, %k1}";
-	}
-      else if (REGNO (operands[0]) == BP_REG)
+      if (TARGET_NACL)
 	{
-	  if (REGNO (operands[1]) == SP_REG)
-	    return "mov{q}\t{%1, %0|%0, %1}";
-	  else
-	    return "naclrestbp\t{%k1, %%r15|%%r15, %k1}";
+	  /* Set RSP.  */
+	  if (REG_P (operands[0]) && REGNO (operands[0]) == SP_REG)
+	    if (!(REG_P (operands[1]) && REGNO (operands[1]) == BP_REG))
+	      return "naclrestsp\t{%k1, %%r15|%%r15, %k1}";
+
+	  /* Set RBP.  */
+	  if (REG_P (operands[0]) && REGNO (operands[0]) == BP_REG)
+	    if (!(REG_P (operands[1]) && REGNO (operands[1]) == SP_REG))
+	      return "naclrestbp\t{%k1, %%r15|%%r15, %k1}";
+
+	  /* Get RSP.  */
+	  if (REG_P (operands[1]) && REGNO (operands[1]) == SP_REG)
+	    {
+	      gcc_assert (REG_P (operands[0]));
+	      if (REGNO (operands[0]) != BP_REG)
+		return "mov{l}\t{%k1, %k0|%k0, %k1}";
+	    }
+
+	  /* Get RBP.  */
+	  if (REG_P (operands[1]) && REGNO (operands[1]) == BP_REG)
+	    {
+	      gcc_assert (REG_P (operands[0]));
+	      if (REGNO (operands[0]) != SP_REG)
+		return "mov{l}\t{%k1, %k0|%k0, %k1}";
+	    }
 	}
-      else
-	return "mov{q}\t{%1, %0|%0, %1}";
+      return "mov{q}\t{%1, %0|%0, %1}";
     }
 }
   [(set (attr "type")
-- 
1.7.3.1

